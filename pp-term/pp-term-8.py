# Englisch | Peharge: This source code is released under the MIT License.
#
# Usage Rights:
# The source code may be copied, modified, and adapted to individual requirements.
# Users are permitted to use this code in their own projects, both for private and commercial purposes.
# However, it is recommended to modify the code only if you have sufficient programming knowledge,
# as changes could cause unintended errors or security risks.
#
# Dependencies and Additional Frameworks:
# The code relies on the use of various frameworks and executes additional files.
# Some of these files may automatically install further dependencies required for functionality.
# It is strongly recommended to perform installation and configuration in an isolated environment
# (e.g., a virtual environment) to avoid potential conflicts with existing software installations.
#
# Disclaimer:
# Use of the code is entirely at your own risk.
# Peharge assumes no liability for damages, data loss, system errors, or other issues
# that may arise directly or indirectly from the use, modification, or redistribution of the code.
#
# Please read the full terms of the MIT License to familiarize yourself with your rights and obligations.

# Deutsch | Peharge: Dieser Quellcode wird unter der MIT-Lizenz veröffentlicht.
#
# Nutzungsrechte:
# Der Quellcode darf kopiert, bearbeitet und an individuelle Anforderungen angepasst werden.
# Nutzer sind berechtigt, diesen Code in eigenen Projekten zu verwenden, sowohl für private als auch kommerzielle Zwecke.
# Es wird jedoch empfohlen, den Code nur dann anzupassen, wenn Sie über ausreichende Programmierkenntnisse verfügen,
# da Änderungen unbeabsichtigte Fehler oder Sicherheitsrisiken verursachen könnten.
#
# Abhängigkeiten und zusätzliche Frameworks:
# Der Code basiert auf der Nutzung verschiedener Frameworks und führt zusätzliche Dateien aus.
# Einige dieser Dateien könnten automatisch weitere Abhängigkeiten installieren, die für die Funktionalität erforderlich sind.
# Es wird dringend empfohlen, die Installation und Konfiguration in einer isolierten Umgebung (z. B. einer virtuellen Umgebung) durchzuführen,
# um mögliche Konflikte mit bestehenden Softwareinstallationen zu vermeiden.
#
# Haftungsausschluss:
# Die Nutzung des Codes erfolgt vollständig auf eigene Verantwortung.
# Peharge übernimmt keinerlei Haftung für Schäden, Datenverluste, Systemfehler oder andere Probleme,
# die direkt oder indirekt durch die Nutzung, Modifikation oder Weitergabe des Codes entstehen könnten.
#
# Bitte lesen Sie die vollständigen Lizenzbedingungen der MIT-Lizenz, um sich mit Ihren Rechten und Pflichten vertraut zu machen.

# Français | Peharge: Ce code source est publié sous la licence MIT.
#
# Droits d'utilisation:
# Le code source peut être copié, édité et adapté aux besoins individuels.
# Les utilisateurs sont autorisés à utiliser ce code dans leurs propres projets, à des fins privées et commerciales.
# Il est cependant recommandé d'adapter le code uniquement si vous avez des connaissances suffisantes en programmation,
# car les modifications pourraient provoquer des erreurs involontaires ou des risques de sécurité.
#
# Dépendances et frameworks supplémentaires:
# Le code est basé sur l'utilisation de différents frameworks et exécute des fichiers supplémentaires.
# Certains de ces fichiers peuvent installer automatiquement des dépendances supplémentaires requises pour la fonctionnalité.
# Il est fortement recommandé d'effectuer l'installation et la configuration dans un environnement isolé (par exemple un environnement virtuel),
# pour éviter d'éventuels conflits avec les installations de logiciels existantes.
#
# Clause de non-responsabilité:
# L'utilisation du code est entièrement à vos propres risques.
# Peharge n'assume aucune responsabilité pour tout dommage, perte de données, erreurs système ou autres problèmes,
# pouvant découler directement ou indirectement de l'utilisation, de la modification ou de la diffusion du code.
#
# Veuillez lire l'intégralité des termes et conditions de la licence MIT pour vous familiariser avec vos droits et responsabilités.

import sys
import getpass
import subprocess
import threading
import time
import importlib.util
import os
import logging
from cgitb import strong
from dotenv import load_dotenv
from subprocess import run
import readline
from bs4 import BeautifulSoup
import datetime
import socket
import platform
import webbrowser
import random
import zipfile
import requests
import psutil
import pyperclip
import ctypes
import speedtest
import colorama
from colorama import Fore, Style, Back
import ollama
from termcolor import colored
import venv
import selectors
import signal
import shutil
import shlex
from typing import Union, List, Optional
import json
import msvcrt
from pathlib import Path
import code
from datetime import datetime
from deep_translator import GoogleTranslator
from io import BytesIO
from PIL import Image
from duckduckgo_search import DDGS
import multiprocessing
from concurrent.futures import ThreadPoolExecutor, as_completed
from shutil import which
import tempfile
import http.server
import socketserver
import re
import contextlib
from IPython import get_ipython
import urllib.request
import urllib.error
import nbformat
import cirq
import sqlite3
import urllib.parse
import html
import faiss
import pandas as pd
import traceback
import numpy as onp
import pythoncom
import win32com.client
import glob
import configparser

try:
    import ujson as _json
except ImportError:
    _json = json


colorama.init()
current_theme = "dark"


"""
log_path = Path(__file__).parent / "pp-term-compiler.log"
logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s.%(msecs)03d] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[
        logging.FileHandler(log_path, encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
"""

logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s.%(msecs)03d] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)


user_name = getpass.getuser()
sys.stdout.reconfigure(encoding='utf-8')


# Constants
APP_NAME = "p-terminal\\pp-term"
STATE_FILE = Path(f"C:/Users/{user_name}/{APP_NAME}/current_env.json")
DEFAULT_ENV_DIR = os.path.join("p-terminal", "pp-term", ".env")
DEFAULT_PYTHON_EXECUTABLE = os.path.join(DEFAULT_ENV_DIR, "Scripts", "python.exe")


# Farbcodes definieren (kleingeschrieben)
red = "\033[91m"
green = "\033[92m"
yellow = "\033[93m"
blue = "\033[94m"
magenta = "\033[95m"
cyan = "\033[96m"
white = "\033[97m"
black = "\033[30m"
orange = "\033[38;5;214m"
purple = "\033[95m"
dim = "\033[2m"
reset = "\033[0m"
bold = "\033[1m"


COMMANDS_FILE = f"C:/Users/{user_name}/p-terminal/pp-term/commands.json"

if not os.path.exists(COMMANDS_FILE):
    with open(COMMANDS_FILE, 'w') as f:
        json.dump({}, f)

with open(COMMANDS_FILE, 'r') as f:
    commands = json.load(f)


def loading_bar(text: str = "Processing", duration: int = 3, color: str = "") -> None:
    print(f"{color}{text} ", end="", flush=True)
    for _ in range(duration):
        print(".", end="", flush=True)
        time.sleep(0.5)
    print(Style.RESET_ALL)


def timestamp() -> str:
    """Returns current time formatted with milliseconds"""
    now = datetime.now()
    return now.strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]


def hyperlink(text, url):
    return f"\033]8;;{url}\033\\{text}\033]8;;\033\\"


def state_info():
    with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "r") as file:
        data = json.load(file)
    return data["state"]


if "adv" in state_info():
    main_color = "\033[92m"
elif "evil" in state_info():
    main_color = "\033[91m"
else:
    main_color = "\033[94m"


def print_banner():
    def get_commit_info(local_path):
        branch = subprocess.check_output(
            ["git", "-C", local_path, "rev-parse", "--abbrev-ref", "HEAD"],
            text=True).strip()

        subprocess.run(["git", "-C", local_path, "fetch"], check=True)

        remote_total = subprocess.check_output(
            ["git", "-C", local_path, "rev-list", "--count", f"origin/{branch}"],
            text=True).strip()

        behind = subprocess.check_output(
            ["git", "-C", local_path, "rev-list", "--count", f"{branch}..origin/{branch}"],
            text=True).strip()

        return int(remote_total), int(behind)

    user_name = os.getlogin()
    local_repo_path = fr"C:/Users/{user_name}/p-terminal"

    remote_total, behind = get_commit_info(local_repo_path)
    remote_total_all = 500 + 971 + remote_total
    if behind != 0:
        print(f"[{timestamp()}] [INFO] The local repository is {main_color}{behind}{reset} commits behind the remote repository, which contains a total of main {main_color}{remote_total}{reset}/ hole {main_color}{remote_total_all}{reset} commits. You can easily update by running 'update' in the PP-terminal.")

    print(f"""
{main_color}██████╗ ██████╗{reset}{white}    ████████╗███████╗██████╗ ███╗   ███╗██╗███╗   ██╗ █████╗ ██╗     {reset}
{main_color}██╔══██╗██╔══██╗{reset}{white}   ╚══██╔══╝██╔════╝██╔══██╗████╗ ████║██║████╗  ██║██╔══██╗██║     {reset}
{main_color}██████╔╝██████╔╝{reset}{white}█████╗██║   █████╗  ██████╔╝██╔████╔██║██║██╔██╗ ██║███████║██║     {reset}
{main_color}██╔═══╝ ██╔═══╝ {reset}{white}╚════╝██║   ██╔══╝  ██╔══██╗██║╚██╔╝██║██║██║╚██╗██║██╔══██║██║     {reset}
{main_color}██║     ██║     {reset}{white}      ██║   ███████╗██║  ██║██║ ╚═╝ ██║██║██║ ╚████║██║  ██║███████╗{reset}
{main_color}╚═╝     ╚═╝     {reset}{white}      ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚══════╝{reset}
""")
    print(f"""A warm welcome, {main_color}{user_name}{reset}, to Peharge Python Terminal!
Developed by Peharge and JK (Peharge Projects 2025)
Thank you so much for using PP-Terminal. We truly appreciate your support ❤️\n
{hyperlink("[GitHub Repository]", "https://github.com/Peharge/p-terminal")} {hyperlink("[Project Website]", f"file:///C:/Users/{user_name}/peharge-web/p-term.html")} {hyperlink("[Learn PP-Term]", f"file:///C:/Users/{user_name}/peharge-web/pp-term-hole.html")}""")

    print()

    # JSON-Datei laden
    json_path = f'C:\\Users\\{os.getlogin()}\\p-terminal\\pp-term\\pp-term-versions.json'
    try:
        with open(json_path, 'r') as f:
            versions = json.load(f)

        # Versionsinformationen ausgeben
        for key, value in versions.items():
            print(f"{main_color}{key}{reset}: {value}")
    except FileNotFoundError:
        print(f"[{timestamp()}] [INFO] Version file not found under{json_path}")
    except json.JSONDecodeError:
        print(f"[{timestamp()}] [ERROR] JSON format error in {json_path}")

    print()

    # Funktion zur Anzeige der 16 Farbpaletten ohne Abstände und Zahlen
    def show_color_palette():
        for i in range(8):
            print(f"\033[48;5;{i}m  \033[0m", end="")  # Farben ohne Zahlen und ohne Abstände

        print()  # Zeilenumbruch nach der ersten Reihe

        # Anzeige der helleren Farben (8-15) ohne Abstände und Zahlen
        for i in range(8, 16):
            print(f"\033[48;5;{i}m  \033[0m", end="")

        print()

    show_color_palette()


def shutdown_jupyter_kernel():
    ipython = get_ipython()
    if ipython:
        ipython.kernel.do_shutdown(restart=False)
        

def set_kernel_in_notebook(notebook_path, kernel_name, display_name):
    nb = nbformat.read(notebook_path, as_version=4)
    nb['metadata']['kernelspec'] = {
        'name': kernel_name,
        'display_name': display_name,
        'language': 'python'
    }
    with open(notebook_path, 'w', encoding='utf-8') as f:
        nbformat.write(nb, f)


def set_python_path(user_input: Optional[str] = None) -> None:
    """
    Setzt PYTHON_PATH basierend auf dem gefundenen Environment.
    Wenn `user_input` gesetzt und != "cd"/"pcd", wird es priorisiert.
    """
    active_env = find_active_env(user_input)

    python_executable = os.path.join(active_env, "Scripts", "python.exe")
    if not os.path.exists(python_executable):
        # Fallback auf default
        python_executable = os.path.abspath(DEFAULT_PYTHON_EXECUTABLE)

    os.environ["PYTHON_PATH"] = python_executable


def ensure_state_dir_exists():
    STATE_FILE.parent.mkdir(parents=True, exist_ok=True)


def save_empty_env():
    ensure_state_dir_exists()
    payload = {"active_env": ""}
    tmp_file = STATE_FILE.with_suffix(".tmp")
    tmp_file.write_text(_json.dumps(payload), encoding="utf-8")
    tmp_file.replace(STATE_FILE)


def load_saved_env() -> Optional[str]:
    try:
        ensure_state_dir_exists()
        if not STATE_FILE.exists():
            save_empty_env()
            return None

        raw = STATE_FILE.read_text(encoding="utf-8").strip()
        if not raw:
            # Datei ist leer, neu initialisieren
            save_empty_env()
            return None

        data = _json.loads(raw)
        val = data.get("active_env", "")
        if val and Path(val).is_dir():
            return val
    except Exception as e:
        logging.warning(f"Error loading status file: {e}")
    return None


def save_current_env(env_path: str | Path) -> None:
    try:
        ensure_state_dir_exists()
        full_path = str(Path(env_path).resolve())

        current_saved = load_saved_env()
        if current_saved == full_path:
            return  # nichts speichern, wenn gleich

        payload = {"active_env": full_path}
        tmp_file = STATE_FILE.with_suffix(".tmp")
        tmp_file.write_text(_json.dumps(payload), encoding="utf-8")
        tmp_file.replace(STATE_FILE)
        logging.debug(f"Saved active_env: {full_path}")
    except Exception as e:
        logging.error(f"Error saving status file: {e}")


def _check_env_dir(path: Path) -> Optional[Path]:
    """Hilfsfunktion: gibt den Pfad zurück, wenn es ein Env ist."""
    activate = path / "Scripts" / "activate"
    return path if activate.is_file() else None


def find_env_in_current_dir(max_workers: int = None) -> Optional[str]:
    """
    Durchsucht das aktuelle Arbeitsverzeichnis nach Virtualenvs.
    Nutzt Multithreading, um Verzeichnisse parallel zu prüfen.
    Gibt den ersten gefundenen Pfad zurück.
    """
    cwd = Path.cwd()
    dirs = [Path(entry.path) for entry in os.scandir(cwd) if entry.is_dir()]
    if not dirs:
        return None

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        future_to_path = {executor.submit(_check_env_dir, d): d for d in dirs}
        for future in as_completed(future_to_path):
            result = future.result()
            if result:
                return str(result.resolve())
    return None


def find_active_env(user_input: Optional[str] = None) -> str:
    """
    Bestimmt den aktiven Virtualenv-Pfad:

    1. Wenn user_input gesetzt und ungleich "cd"/"pcd":
       - Speichert den Pfad immer und gibt ihn zurück.
    2. Wenn user_input == "cd" oder "pcd":
       - Sucht im aktuellen Verzeichnis nach einem Virtualenv.
       - Wenn gefunden und von gespeichertem abweichend, speichert und gibt diesen zurück.
       - Wenn nicht gefunden, aber ein gespeicherter Pfad existiert, gibt diesen zurück.
    3. Wenn user_input == None:
       - Sucht im aktuellen Verzeichnis nach einem Virtualenv.
       - Gibt gefundenes zurück (speichert aber nicht).
       - Wenn nicht gefunden, aber gespeicherte Env vorhanden, gibt diese zurück.
    4. Sonst Fallback auf DEFAULT_ENV_DIR.
    """
    saved = load_saved_env()
    user_str = str(user_input).lower() if user_input is not None else None

    # 1. Direkteingabe (außer "cd" oder "pcd") sofort übernehmen und speichern
    if user_str and user_str not in ("cd", "pcd"):
        save_current_env(user_input)
        return user_str

    # 2. user_input == "cd" oder "pcd"
    if user_str in ("cd", "pcd"):
        found = find_env_in_current_dir()
        if found:
            if found != saved:
                save_current_env(found)
            return found
        if saved:
            return saved
        return str(Path(DEFAULT_ENV_DIR).resolve())

    # 3. user_input == None
    if user_str is None:
        found = find_env_in_current_dir()
        if found:
            # Speichern NICHT bei None
            return found
        if saved:
            return saved
        return str(Path(DEFAULT_ENV_DIR).resolve())

    # 4. Fallback (eigentlich unreachable)
    return str(Path(DEFAULT_ENV_DIR).resolve())


def run_command(command, shell=False, cwd=None, extra_env=None):
    """
    Führt einen externen Befehl aus und leitet stdout/stderr interaktiv ans Terminal weiter.

    Args:
        command (str | List[str]): Der auszuführende Befehl.
        shell (bool): Wenn True, über die Shell ausführen und direkte Weiterleitung an stdout/stderr.
        cwd (str | None): Arbeitsverzeichnis.
        extra_env (dict | None): Zusätzliche Umgebungsvariablen.

    Returns:
        int: Exit-Code des Prozesses.
    """

    # Load JSON
    json_path = Path(f"C:/Users/{user_name}/p-terminal/pp-term/current_env.json")

    try:
        with open(json_path, 'r') as file:
            data = json.load(file)
            active = data.get("active_env")

        if active:
            active_env_path = Path(active)  # Convert to Path object

            # Example usage
            python_exe = active_env_path / "Scripts" / "python.exe"

            if python_exe.exists():
                pass
            else:
                print(f"[{timestamp()}] [ERROR] Python executable not found.")
        else:
            print(f"[{timestamp()}] [ERROR] Key 'active_env' not found.")

    except FileNotFoundError:
        print(f"[{timestamp()}] [ERROR] File not found: {json_path}")
    except json.JSONDecodeError:
        print(f"[{timestamp()}] [ERROR] Error decoding JSON file: {json_path}")

    # Erwarte entweder ein Tuple(path, env_dict) oder nur den Pfad als String
    if isinstance(active, tuple) and len(active) == 2 and isinstance(active[1], dict):
        active_env, venv_env = active
    else:
        active_env = active
        venv_env = {}

    # Unter Windows nutzen wir python.exe, sonst python
    python_name = "python.exe" if os.name == "nt" else "python"
    python_exe = os.path.join(
        active_env,
        "Scripts" if os.name == "nt" else "bin",
        python_name
    )

    # command in Liste umwandeln (nur wenn shell=False und command ist str)
    if isinstance(command, str) and not shell:
        command = shlex.split(command, posix=(os.name != "nt"))

    # pip- und python-Wrapper
    if isinstance(command, list) and command:
        base = os.path.basename(command[0]).lower()
        if base == "pip" or base.startswith("pip"):
            command = [python_exe, "-m", "pip"] + command[1:]
        elif base == "python" or base.startswith("python"):
            command = [python_exe] + command[1:]

    # Umgebung zusammenbauen: zuerst das Venv-Env, dann System-Env, dann extra_env
    env = {}
    env.update(venv_env)
    env.update(os.environ)
    # Setze VIRTUAL_ENV und passe PATH an, falls nicht bereits gesetzt
    env.setdefault("VIRTUAL_ENV", active_env)
    venv_bin = os.path.join(active_env, "Scripts" if os.name == "nt" else "bin")
    # Pfad voranstellen
    original_path = env.get("PATH", "")
    env["PATH"] = venv_bin + os.pathsep + original_path
    if extra_env:
        env.update(extra_env)

    # Wenn shell=True: einfache Ausführung mit direktem Stream-Passing
    if shell:
        proc = subprocess.Popen(
            command,
            shell=True,
            cwd=cwd,
            env=env,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            text=True
        )
        try:
            return proc.wait()
        except KeyboardInterrupt:
            proc.send_signal(signal.SIGINT)
            return proc.wait()

    # Ansonsten: non-shell mit PIPEs und selectors für Zeilen-Output
    proc = subprocess.Popen(
        command,
        shell=False,
        cwd=cwd,
        env=env,
        stdin=sys.stdin,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        bufsize=1,  # Zeilenweises Buffering
        text=True
    )

    sel = selectors.DefaultSelector()
    sel.register(proc.stdout, selectors.EVENT_READ)
    sel.register(proc.stderr, selectors.EVENT_READ)

    # SIGINT sauber weiterleiten
    def _handle_sigint(signum, frame):
        proc.send_signal(signal.SIGINT)

    old_handler = signal.signal(signal.SIGINT, _handle_sigint)

    try:
        # Loop, bis Prozess fertig und alle Streams EOF
        while True:
            events = sel.select(timeout=0.1)
            for key, _ in events:
                line = key.fileobj.readline()
                if not line:
                    sel.unregister(key.fileobj)
                    continue
                if key.fileobj is proc.stdout:
                    print(line, end='', flush=True)
                else:
                    print(line, end='', file=sys.stderr, flush=True)

            if proc.poll() is not None and not sel.get_map():
                break
    finally:
        signal.signal(signal.SIGINT, old_handler)
        sel.close()
        proc.wait()

    return proc.returncode


def quantum_decision(force=None):
    """
    Liefert 0 oder 1.
    - force=True  => immer ausführen
    - force=False => nie ausführen
    - None        => Zufall
    """
    if force is True:
        return 1
    if force is False:
        return 0
    return random.randint(0, 1)


def _stream_reader(pipe, out_func):
    for line in iter(pipe.readline, ''):
        out_func(line.rstrip())
    pipe.close()


def run_quantum_command(
    command,
    shell=False,
    cwd=None,
    extra_env=None,
    force_quantum=None,
    verbose=True,
    dry_run=False,
    logfile=None,
    callback=None
):
    """
    Führt einen externen Befehl auf Quantenbasis aus.

    Zusätzliche Features:
    - dry_run: nur anzeigen, nicht ausführen
    - verbose: mehr Details
    - logfile: Pfad für zusätzliches Logging
    - callback: Funktion(exit_code, output) nach Ausführung

    Returns:
        int: Exit-Code oder -1 bei Übersprungung
    """
    # Quantum Decision
    decision = quantum_decision(force_quantum)
    logging.info(f"[INFO] Quantum decision: {decision}")
    if decision == 0:
        logging.info("[INFO] Command skipped by quantum decision.")
        return -1

    # dry run?
    if dry_run:
        logging.info(f"[DRY RUN] Would execute: {command}")
        return 0

    # Environment laden
    user = os.getlogin()
    cfg_path = Path(f"C:/Users/{user}/p-terminal/pp-term/current_env.json")
    active_env = None
    venv_env = {}
    try:
        with open(cfg_path) as f:
            data = json.load(f)
            active_env = data.get('active_env')
    except Exception as e:
        logging.warning(f"[INFO] Could not read config: {e}")

    if not active_env:
        active_env = os.getcwd()

    python_exe = os.path.join(
        active_env,
        "Scripts" if os.name=='nt' else "bin",
        "python.exe" if os.name=='nt' else "python"
    )

    # Kommando anpassen
    if isinstance(command, str) and not shell:
        command = shlex.split(command, posix=(os.name!='nt'))
    if isinstance(command, (list, tuple)) and command:
        base = os.path.basename(command[0]).lower()
        if base.startswith('pip'):
            command = [python_exe, '-m', 'pip'] + list(command[1:])
        elif base.startswith('python'):
            command = [python_exe] + list(command[1:])

    # Env zusammenbauen
    env = os.environ.copy()
    env.update(venv_env)
    env.setdefault('VIRTUAL_ENV', active_env)
    venv_bin = os.path.join(active_env, "Scripts" if os.name=='nt' else "bin")
    env['PATH'] = venv_bin + os.pathsep + env['PATH']
    if extra_env:
        env.update(extra_env)

    # Logging to file
    if logfile:
        fh = logging.FileHandler(logfile)
        fh.setFormatter(logging.Formatter('[%(asctime)s] %(levelname)s: %(message)s'))
        logging.getLogger().addHandler(fh)

    # Ausführen
    logging.info(f"[INFO] Running command: {command}")
    try:
        proc = subprocess.Popen(
            command,
            shell=shell,
            cwd=cwd,
            env=env,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        # Threads für stdout/stderr
        out_lines = []
        err_lines = []
        t_out = threading.Thread(
            target=_stream_reader,
            args=(proc.stdout, lambda l: (print(l), out_lines.append(l)) if verbose else out_lines.append(l))
        )
        t_err = threading.Thread(
            target=_stream_reader,
            args=(proc.stderr, lambda l: (print(l, file=sys.stderr), err_lines.append(l)) if verbose else err_lines.append(l))
        )
        t_out.start(); t_err.start()
        exit_code = proc.wait()
        t_out.join(); t_err.join()
        logging.info(f"[INFO] Command finished with exit code {exit_code}")
    except KeyboardInterrupt:
        proc.send_signal(signal.SIGINT)
        exit_code = proc.wait()
        logging.info("[INFO] Interrupted by user (SIGINT)")
    except Exception as e:
        logging.error(f"[ERROR] Execution error: {e}")
        exit_code = -1

    # callback
    if callback:
        try:
            callback(exit_code, {'stdout': out_lines, 'stderr': err_lines})
        except Exception as e:
            logging.error(f"[ERROR] Callback error: {e}")

    return exit_code


def run_command_ov(command, shell=False, cwd=None, extra_env=None):
    """
    Führt beliebige Befehle aus und verwaltet virtuelle Umgebungen dynamisch.
    """

    user_name = os.getlogin()
    current_env_path = Path(f"C:/Users/{user_name}/p-terminal/pp-term/current_env.json")
    info_main_path = Path(f"C:/Users/{user_name}/p-terminal/pp-term/info-main-v-3.json")

    def save_json(path, content):
        with open(path, 'w') as f:
            json.dump(content, f, indent=4)

    def load_json(path):
        try:
            with open(path, 'r') as f:
                return json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            return {}

    current_env = load_json(current_env_path)
    info_data = load_json(info_main_path)

    if isinstance(command, str) and not shell:
        cmd_list = shlex.split(command, posix=(os.name != "nt"))
    elif isinstance(command, list):
        cmd_list = command
    else:
        cmd_list = []

    # Versuche zu erkennen, ob es sich um ein "env"-Kommando handelt
    is_env_command = False
    if len(cmd_list) >= 2:
        tool = cmd_list[0].lower()
        action = cmd_list[1].lower()
        version = cmd_list[2] if len(cmd_list) > 2 else None

        if action in {"use", "activate"} and version:
            is_env_command = True
            # Aktiviere Umgebung
            display = f"({tool}-v{version})"
            bin_path = f"C:/Users/{user_name}/.virtualenvs/{tool}/{version}/bin"  # Beispielpfad
            info_data[tool] = {
                "version": version,
                "display": display,
                "bin_path": bin_path,
                "activated_at": timestamp()
            }
            current_env["active_env"] = current_env.get("active_env", {})
            current_env["active_env"][tool] = version
            save_json(info_main_path, info_data)
            save_json(current_env_path, current_env)
            print(f"[{timestamp()}] [{tool}] aktiviert: Version {version} {display}")

        elif action in {"deactivate", "off", "none"}:
            is_env_command = True
            if tool in info_data:
                del info_data[tool]
            if "active_env" in current_env and tool in current_env["active_env"]:
                del current_env["active_env"][tool]
            save_json(info_main_path, info_data)
            save_json(current_env_path, current_env)
            print(f"[{timestamp()}] [{tool}] deaktiviert.")

        if is_env_command:
            proc = subprocess.Popen(
                command if shell else cmd_list,
                shell=shell,
                cwd=cwd,
                env=os.environ,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                text=True
            )
            try:
                return proc.wait()
            except KeyboardInterrupt:
                proc.send_signal(signal.SIGINT)
                return proc.wait()

    # Wenn es KEIN spezielles Aktivierungs-/Deaktivierungs-Kommando war, führe unter Umgebung aus
    env = os.environ.copy()

    for tool, info in info_data.items():
        version = info.get("version")
        bin_path = info.get("bin_path")
        env[f"{tool.upper()}_VERSION"] = version
        if bin_path:
            env["PATH"] = bin_path + os.pathsep + env.get("PATH", "")

        # Optionale Variable z.B. VIRTUAL_ENV
        if tool == "venv":
            env["VIRTUAL_ENV"] = bin_path

    if extra_env:
        env.update(extra_env)

    if shell:
        proc = subprocess.Popen(
            command,
            shell=True,
            cwd=cwd,
            env=env,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            text=True
        )
        try:
            return proc.wait()
        except KeyboardInterrupt:
            proc.send_signal(signal.SIGINT)
            return proc.wait()

    # Non-shell-Ausführung mit selektiver Ausgabe
    proc = subprocess.Popen(
        cmd_list,
        shell=False,
        cwd=cwd,
        env=env,
        stdin=sys.stdin,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        bufsize=1,
        text=True
    )

    sel = selectors.DefaultSelector()
    sel.register(proc.stdout, selectors.EVENT_READ)
    sel.register(proc.stderr, selectors.EVENT_READ)

    def _handle_sigint(signum, frame):
        proc.send_signal(signal.SIGINT)

    old_handler = signal.signal(signal.SIGINT, _handle_sigint)

    try:
        while True:
            events = sel.select(timeout=0.1)
            for key, _ in events:
                line = key.fileobj.readline()
                if not line:
                    sel.unregister(key.fileobj)
                    continue
                if key.fileobj is proc.stdout:
                    print(line, end='', flush=True)
                else:
                    print(line, end='', file=sys.stderr, flush=True)

            if proc.poll() is not None and not sel.get_map():
                break
    finally:
        signal.signal(signal.SIGINT, old_handler)
        sel.close()
        proc.wait()

    return proc.returncode


def change_directory(path):
    try:
        os.chdir(path)
    except FileNotFoundError:
        print(f"[{timestamp()}] [INFO] Directory not found: {path}", file=sys.stderr)
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] {str(e)}", file=sys.stderr)


def handle_special_commands(user_input):
    user_input = user_input.strip()

    # Lade Umgebungsvariablen
    load_dotenv(dotenv_path=f"C:\\Users\\{os.getlogin()}\\p-terminal\\pp-term\\.env")
    python_path = f"C:\\Users\\{os.getlogin()}\\p-terminal\\pp-term\\.env\\Scripts\\python.exe"

    # Spezielle Scripts
    commands = {
        "peharge": "pp-commands\\peharge.py",
        "pp-term": "pp-commands\\pp-term.py",
        "pp-terminal": "pp-commands\\pp-term.py",
        "mavis env install": "mavis-install\\install-info-mavis-4.py",
        "install mavis env": "mavis-install\\install-info-mavis-4.py",
        "install mavis-3": "mavis-install\\install-info-mavis-4.py",  # new
        "install mavis-3.3": "mavis-install\\install-info-mavis-4.py",  # new
        "install mavis-3-3": "mavis-install\\install-info-mavis-4.py",  # new
        "install mavis-4": "mavis-install\\install-info-mavis-4.py",  # new
        "install mavis-4.3": "mavis-install\\install-info-mavis-4.py",  # new
        "install mavis-4-3": "mavis-install\\install-info-mavis-4.py",  # new
        "mavis env update": "mavis-install\\install-info-mavis-4.py",
        "update pp-term env": "mavis-install\\update-pp-term-venv.py",  # new
        "update mavis env": "mavis-install\\install-info-mavis-4.py",
        "mavis update": "mavis-update\\update-mavis-repository-windows.py",
        "update mavis": "mavis-update\\update-mavis-repository-windows.py",
        "security": "security\\security_check-mavis-4.py",
        "p-terminal security": "security\\security_check-mavis-4.py",
        "securitycheck": "security\\security_check-mavis-4.py",
        "info": "pp-commands\\info.py",
        "mavis info": "pp-commands\\info.py",
        "info mavis": "pp-commands\\info.py",
        "p-term info": "pp-commands\\info.py",
        "info p-term": "pp-commands\\info.py",
        "neofetch": "pp-commands\\neofetch.py",
        "fastfetch": "pp-commands\\neofetch.py",  # new
        "screenfetch": "pp-commands\\neofetch.py",  # new
        "pfetch": "pp-commands\\neofetch.py",  # new
        "neofetch-1": "pp-commands\\neofetch.py",
        "fastfetch-1": "pp-commands\\neofetch.py",  # new
        "screenfetch-1": "pp-commands\\neofetch.py",  # new
        "pfetch-1": "pp-commands\\neofetch.py",  # new
        "neofetch-2": "pp-commands\\neofetch-2.py",  # new
        "fastfetch-2": "pp-commands\\neofetch-2.py",  # new
        "screenfetch-2": "pp-commands\\neofetch-2.py",  # new
        "pfetch-2": "pp-commands\\neofetch-2.py",  # new
        "neofetch-3": "pp-commands\\neofetch-3.py",  # new
        "fastfetch-3": "pp-commands\\neofetch-3.py",  # new
        "screenfetch-3": "pp-commands\\neofetch-3.py",  # new
        "pfetch-3": "pp-commands\\neofetch-3.py",  # new
        "neofetch-4": "pp-commands\\neofetch-4.py",  # new
        "fastfetch-4": "pp-commands\\neofetch-4.py",  # new
        "screenfetch-4": "pp-commands\\neofetch-4.py",  # new
        "pfetch-4": "pp-commands\\neofetch-4.py",  # new
        "run mavis-4": "pp-commands\\run-mavis-4.py",  # new
        "run mavis-4-3": "pp-commands\\run-mavis-4-3.py",  # new
        "run mavis-4-fast": "mavis-4-main.py",  # new
        "run mavis-4-3-fast": "mavis-4-3-main.py",  # new
        "run mavis-launcher-4": "pp-commands\\run-launcher-4.py",  # new
        "run ollama mavis-4": "mavis-install\\install-ollama-mavis-4.py",  # new
        "run mavis-4": "pp-commands\\run-mavis-4.py",  # new
        "pr mavis-4-3": "pp-commands\\run-mavis-4-3.py",  # new
        "pr mavis-4-fast": "mavis-4-main.py",  # new
        "pr mavis-4-3-fast": "mavis-4-3-main.py",  # new
        "pr mavis-launcher-4": "pp-commands\\run-launcher-4.py",  # new
        "pr ollama mavis-4": "mavis-install\\install-ollama-mavis-4.py",  # new
        "install ollama mavis-4": "mavis-install\\install-ollama-mavis-4.py",  # new
        "change models mavis-4": "mavis-install\\install-ollama-mavis-4.py",  # new
        "change models": "mavis-install\\install-ollama-mavis-4.py",  # new
        "run solution": "mavis-solution\\run-solution-4.py",
        "run solution-3": "mavis-solution\\run-solution-3.py",
        "run solution-4": "mavis-solution\\run-solution-4.py",
        "pr solution": "mavis-solution\\run-solution-4.py",
        "pr solution-3": "mavis-solution\\run-solution-3.py",
        "pr solution-4": "mavis-solution\\run-solution-4.py",
        "account": "mavis-account\\account.py",
        "mr deepseek-r1:1.5b": "pp-commands\\deepseek-r1-1-5b.py",
        "mr deepseek-r1:7b": "pp-commands\\deepseek-r1-7b.py",
        "mr deepseek-r1:8b": "pp-commands\\deepseek-r1-8b.py",
        "mr deepseek-r1:14b": "pp-commands\\deepseek-r1-14b.py",
        "mr deepseek-r1:32b": "pp-commands\\deepseek-r1-32b.py",
        "mr deepseek-r1:70b": "pp-commands\\deepseek-r1-70b.py",
        "mr deepseek-r1:671b": "pp-commands\\deepseek-r1-671b.py",
        "mr deepscaler": "pp-commands\\deepscaler.py",
        "mr llama3.1:8b": "pp-commands\\llama-3-1-8b.py",
        "mr llama3.1:70b": "pp-commands\\llama-3-1-70b.py",
        "mr llama3.1:405": "pp-commands\\llama-3-1-405b.py",
        "mr llama3.2:1b": "pp-commands\\llama-3-2-1b.py",
        "mr llama3.2:3b": "pp-commands\\llama-3-2-3b.py",
        "mr llama3.3": "pp-commands\\llama-3-3.py",
        "mr llama3:8b": "pp-commands\\llama-3-8b.py",
        "mr llama3:70b": "pp-commands\\llama-3-70b.py",
        "mr mistral": "pp-commands\\mistral.py",
        "mr mistral-large": "pp-commands\\mistral-large.py",  # new
        "mr mistral-nemo": "pp-commands\\mistral-nemo.py",  # new
        "mr mistral-openorca": "pp-commands\\mistral-openorca.py",  # new
        "mr mistral-small:22b": "pp-commands\\mistral-small-22b.py",  # new
        "mr mistral-small:24b": "pp-commands\\mistral-small-24b.py",  # new
        "mr phi4": "pp-commands\\phi-4.py",
        "mr qwen2.5:0.5b": "pp-commands\\qwen-2-5-0.5b.py",
        "mr qwen2.5:1.5b": "pp-commands\\qwen-2-5-1.5b.py",
        "mr qwen2.5:3b": "pp-commands\\qwen-2-5-3b.py",
        "mr qwen2.5:7b": "pp-commands\\qwen-2-5-7b.py",
        "mr qwen2.5:14b": "pp-commands\\qwen-2-5-14b.py",
        "mr qwen2.5:32b": "pp-commands\\qwen-2-5-32b.py",
        "mr qwen2.5:72b": "pp-commands\\qwen-2-5-72b.py",
        "mr qwen2.5-coder:0.5b": "pp-commands\\qwen-2-5-coder-0.5b.py",
        "mr qwen2.5-coder:1.5b": "pp-commands\\qwen-2-5-coder-0.5b.py",
        "mr qwen2.5-coder:3b": "pp-commands\\qwen-2-5-coder-0.5b.py",
        "mr qwen2.5-coder:7b": "pp-commands\\qwen-2-5-coder-0.5b.py",
        "mr qwen2.5-coder:14b": "pp-commands\\qwen-2-5-coder-0.5b.py",
        "mr qwen2.5-coder:32b": "pp-commands\\qwen-2-5-coder-0.5b.py",
        "mr qwen3:0.6b": "pp-commands\\qwen-3-0-6b.py",  # new
        "mr qwen3:1.7b": "pp-commands\\qwen-3-1-7b.py",  # new
        "mr qwen3:4b": "pp-commands\\qwen-3-4b.py",  # new
        "mr qwen3:8b": "pp-commands\\qwen-3-8b.py",  # new
        "mr qwen3:14b": "pp-commands\\qwen-3-14b.py",  # new
        "mr qwen3:32b": "pp-commands\\qwen-3-32.py",  # new
        "mr qwen3:30b": "pp-commands\\qwen-3-30.py",  # new
        "mr qwen3:235b": "pp-commands\\qwen-3-235.py",  # new
        "mr gemma3:1b": "pp-commands\\gemma-3-1b.py",  # new
        "mr gemma3:4b": "pp-commands\\gemma-3-4b.py",  # new
        "mr gemma3:12b": "pp-commands\\gemma-3-12b.py",  # new
        "mr gemma3:27b": "pp-commands\\gemma-3-27b.py",  # new
        "mr qwq": "pp-commands\\qwq.py",  # new
        "mr command-a": "pp-commands\\command-a.py",  # new
        "mr phi4-mini": "pp-commands\\phi-4-mini.py",  # new
        "mr granite3.2:8b": "pp-commands\\granite-3-2-8b.py",  # new
        "mr granite3.2:2b": "pp-commands\\granite-3-2-2b.py",  # new
        "mr granite3.2-vision:2b": "pp-commands\\granite-3-2-2b-vision.py",  # new
        "mr qwen2.5-omni:7b": "pp-commands\\qwen-2-5-omni-7b.py",  # new
        "mr qvq:72b": "pp-commands\\qvq-72b.py",  # new
        "mr qwen2.5-vl:32b": "pp-commands\\qwen-2-5-vl-32b.py",  # new
        "mr qwen2.5-vl:72b": "pp-commands\\qwen-2-5-vl-72b.py",  # new
        "mr llama4-maverick:17b": "pp-commands\\llama-4-maverick-17b-ollama.py",  # new
        "mr llama4-scout:17b": "pp-commands\\llama-4-scout-17b-ollama.py",  # new
        "mr llama4-maverick:17b hg": "pp-commands\\llama-4-maverick-17b.py",  # new
        "mr llama4-scout:17b hg": "pp-commands\\llama-4-scout-17b.py",  # new
        "mr deepcoder:1.5b": "pp-commands\\deepcoder-1-5b.py",  # new
        "mr deepcoder:14b": "pp-commands\\deepcoder-14b.py",  # new
        "mr mistral-small3.1": "pp-commands\\mistral-small-3-1.py",  # new
        "install deepseek-r1:1.5b": "pp-commands\\deepseek-r1-1-5b.py",
        "install deepseek-r1:7b": "pp-commands\\deepseek-r1-7b.py",
        "install deepseek-r1:8b": "pp-commands\\deepseek-r1-8b.py",
        "install deepseek-r1:14b": "pp-commands\\deepseek-r1-14b.py",
        "install deepseek-r1:32b": "pp-commands\\deepseek-r1-32b.py",
        "install deepseek-r1:70b": "pp-commands\\deepseek-r1-70b.py",
        "install deepseek-r1:671b": "pp-commands\\deepseek-r1-671b.py",
        "install deepscaler": "pp-commands\\deepscaler.py",
        "install llama3.1:8b": "pp-commands\\llama-3-1-8b.py",
        "install llama3.1:70b": "pp-commands\\llama-3-1-70b.py",
        "install llama3.1:405": "pp-commands\\llama-3-1-405b.py",
        "install llama3.2:1b": "pp-commands\\llama-3-2-1b.py",
        "install llama3.2:3b": "pp-commands\\llama-3-2-3b.py",
        "install llama3.3": "pp-commands\\llama-3-3.py",
        "install llama3:8b": "pp-commands\\llama-3-8b.py",
        "install llama3:70b": "pp-commands\\llama-3-70b.py",
        "install mistral": "pp-commands\\mistral.py",
        "install mistral-large": "pp-commands\\mistral-large.py",  # new
        "install mistral-nemo": "pp-commands\\mistral-nemo.py",  # new
        "install mistral-openorca": "pp-commands\\mistral-openorca.py",  # new
        "install mistral-small:22b": "pp-commands\\mistral-small-22b.py",  # new
        "install mistral-small:24b": "pp-commands\\mistral-small-24b.py",  # new
        "install phi4": "pp-commands\\phi-4.py",
        "install qwen2.5:0.5b": "pp-commands\\qwen-2-5-0.5b.py",
        "install qwen2.5:1.5b": "pp-commands\\qwen-2-5-1.5b.py",
        "install qwen2.5:3b": "pp-commands\\qwen-2-5-3b.py",
        "install qwen2.5:7b": "pp-commands\\qwen-2-5-7b.py",
        "install qwen2.5:14b": "pp-commands\\qwen-2-5-14b.py",
        "install qwen2.5:32b": "pp-commands\\qwen-2-5-32b.py",
        "install qwen2.5:72b": "pp-commands\\qwen-2-5-72b.py",
        "install qwen2.5-coder:0.5b": "pp-commands\\qwen-2-5-coder-0.5b.py",
        "install qwen2.5-coder:1.5b": "pp-commands\\qwen-2-5-coder-0.5b.py",
        "install qwen2.5-coder:3b": "pp-commands\\qwen-2-5-coder-0.5b.py",
        "install qwen2.5-coder:7b": "pp-commands\\qwen-2-5-coder-0.5b.py",
        "install qwen2.5-coder:14b": "pp-commands\\qwen-2-5-coder-0.5b.py",
        "install qwen2.5-coder:32b": "pp-commands\\qwen-2-5-coder-0.5b.py",
        "install gemma3:1b": "pp-commands\\gemma-3-1b.py",  # new
        "install gemma3:4b": "pp-commands\\gemma-3-4b.py",  # new
        "install gemma3:12b": "pp-commands\\gemma-3-12b.py",  # new
        "install gemma3:27b": "pp-commands\\gemma-3-27b.py",  # new
        "install qwq": "pp-commands\\qwq.py",  # new
        "install command-a": "pp-commands\\command-a.py",  # new
        "install phi4-mini": "pp-commands\\phi-4-mini.py",  # new
        "install granite3.2:8b": "pp-commands\\granite-3-2-8b.py",  # new
        "install granite3.2:2b": "pp-commands\\granite-3-2-2b.py",  # new
        "install granite3.2-vision:2b": "pp-commands\\granite-3-2-2b-vision.py",  # new
        "install qwen-2-5-omni:7b": "pp-commands\\qwen-2-5-omni-7b.py",  # new
        "install qvq:72b": "pp-commands\\qvq-72b.py",  # new
        "install qwen-2-5-vl:32b": "pp-commands\\qwen-2-5-vl-32b.py",  # new
        "install qwen-2-5-vl:72b": "pp-commands\\qwen-2-5-vl-72b.py",  # new
        "install llama-4-maverick:17b": "pp-commands\\llama-4-maverick-17b.py",  # new
        "install llama-4-scout:17b": "pp-commands\\llama-4-scout-17b.py",  # new
        "install deepcoder:1.5b": "pp-commands\\deepcoder-1-5b.py",  # new
        "install deepcoder:14b": "pp-commands\\deepcoder-14b.py",  # new
        "install mistral-small3.1": "pp-commands\\mistral-small-3-1.py",  # new
        "help": "pp-commands\\help.py",
        "image generation": "pp-commands\\stable-diffusion-3-5-large-turbo.py",
        "video generation": "pp-commands\\wan-2-1-t2v-14b.py",
        "run mavis": "mavis-installer-3-main-windows.py",
        "pr mavis": "mavis-installer-3-main-windows.py",
        "pmr run all": "pp-commands\\p-run-all.py",  # new
        "pmr htop": "pp-commands\\p-htop.py",  # new
        "pmr run gemma3": "pp-commands\\p-gemma-3.py",  # new
        "pmr run deepseek-r1": "pp-commands\\p-deepseek-r1.py",  # new
        "pmr run qwen2.5": "pp-commands\\p-qwen-2-5.py",  # new
        "pmr run qwen2.5-coder": "pp-commands\\p-qwen-2-5-coder.py",  # new
        "p python frameworks": "pp-commands\\p-python-frameworks.py",  # new
        "p pip list": "pp-commands\\p-python-frameworks.py",  # new
        "p pip ls": "pp-commands\\p-python-frameworks.py",  # new
        "p git ls": "pp-commands\\p-git.py",  # new
        "p git": "pp-commands\\p-git.py",  # new
        "p git p-terminal-old": "pp-commands\\p-git-p-terminal-old.py",  # new
        "p git p-terminal": "pp-commands\\p-git.py",  # new
        "p git mavis": "pp-commands\\p-git-mavis.py",  # new
        "p git mavis-web": "pp-commands\\p-git-mavis-web.py",  # new
        "p git simon": "pp-commands\\p-git-simon.py",  # new
        "p git llama.cpp": "pp-commands\\p-git-llama-cpp.py",  # new
        "p git pytorch": "pp-commands\\p-git-pytorch.py",  # new
        "p git tensorflow": "pp-commands\\p-git-tensorflow.py",  # new
        "p git jax": "pp-commands\\p-git-jax.py",  # new
        "p git ollama": "pp-commands\\p-git-ollama.py",  # new
        "p git transformer": "pp-commands\\p-git-transformer.py",  # new
        "p git slicer": "pp-commands\\p-git-slicer.py",  # new
        "p git linux": "pp-commands\\p-git-linux.py",  # new
        "p git python": "pp-commands\\p-git-python.py",  # new
        "p ls": "pp-commands\\p-ls.py",  # new
        "p ls pp-term": "pp-commands\\p-ls.py",  # new
        "p ls p-terminal": "pp-commands\\p-ls-p-terminal.py",  # new
        "p ls mavis": "pp-commands\\p-ls-mavis.py",  # new
        "p ls mavis-web": "pp-commands\\p-ls-mavis-web.py",  # new
        "p ls simon": "pp-commands\\p-ls-simon.py",  # new
        "models": "pp-commands\\models-ls.py",  # new
        "models ls": "pp-commands\\models-ls.py",  # new
        "p models": "pp-commands\\p-models-ls.py",  # new
        "p models ls": "pp-commands\\p-models-ls.py",  # new
        "p github p-terminal": "pp-commands\\p-github-p-terminal.py",  # new
        "p github mavis": "pp-commands\\p-github-mavis.py",  # new
        "p github commits": "pp-commands\\p-github-commits.py",  # new
        "p github issues": "pp-commands\\p-github-issues.py",  # new
        "p github peharge": "pp-commands\\p-github-peharge.py",  # new
        "p github pulls": "pp-commands\\p-github-pulls.py",  # new
        "p github readme": "pp-commands\\p-github-readme.py",  # new
        "p github releases": "pp-commands\\p-github-releases.py",  # new
        "p github": "pp-commands\\p-github.py",  # new
        "p p-terminal": "pp-commands\\p-p-terminal.py",  # new
        "p p-terminal.com": "pp-commands\\p-p-terminal-com.py",  # new
        "p mavis.com": "pp-commands\\p-mavis-com.py",  # new
        "p search": "pp-commands\\p-search.py",  # new
        "p google": "pp-commands\\p-google.py",  # new
        "p ollama": "pp-commands\\p-ollama.py",  # new
        "p huggingface": "pp-commands\\p-huggingface.py",  # new
        "p github.com": "pp-commands\\p-github.py",  # new
        "p wikipedia": "pp-commands\\p-wikipedia.py",  # new
        "p youtube": "pp-commands\\p-youtube.py",  # new
        "p kali.com": "pp-commands\\p-kali.py",  # new
        "p mint.com": "pp-commands\\p-mint.py",  # new
        "p monai.com": "pp-commands\\p-monai.py",  # new
        "p monai-github.com": "pp-commands\\p-monai-git.py",  # new
        "p python.com": "pp-commands\\p-python.py",  # new
        "p pytorch.com": "pp-commands\\p-pytorch.py",  # new
        "p pytorch-github.com": "pp-commands\\p-pytorch-git.py",  # new
        "p ubuntu.com": "pp-commands\\p-ubuntu.py",  # new
        "p 3dslicer-github.com": "pp-commands\\p-3dslicer-git.py",  # new
        "p 3dslicer.com": "pp-commands\\p-3dslicer-web.py",  # new
        "p arch.com": "pp-commands\\p-arch.py",  # new
        "p debian.com": "pp-commands\\p-debian.py",  # new
        "p google.com": "pp-commands\\p-google.py",  # new
        "p ollama.com": "pp-commands\\p-ollama.py",  # new
        "p huggingface.com": "pp-commands\\p-huggingface.py",  # new
        "p mavis": "pp-commands\\p-github-mavis.py",  # new
        "p mavis.com": "pp-commands\\p-mavis.py",  # new
        "p simon": "pp-commands\\p-simon.py",  # new
        "p simon.com": "pp-commands\\p-simon-git.py",  # new
        "wsl info": "pp-commands\\wsl-info.py",  # new
        "p wsl": "pp-commands\\p-wsl.py",  # new
        "p pip": "pp-commands\\p-pip.py",  # new
        "p ubuntu": "pp-commands\\p-wsl-ubuntu.py",  # new
        "p debian": "pp-commands\\p-wsl-debian.py",  # new
        "p kali": "pp-commands\\p-wsl-kali.py",  # new
        "p arch": "pp-commands\\p-wsl-arch.py",  # new
        "p mint": "pp-commands\\p-wsl-mint.py",  # new
        "p opensuse": "pp-commands\\p-wsl-opensuse.py",  # new
        "p fedora": "pp-commands\\p-wsl-fedora.py",  # new
        "p redhat": "pp-commands\\p-wsl-redhat.py",  # new
        "p alpine": "pp-commands\\p-wsl-alpine.py",  # new
        "p clear": "pp-commands\\p-wsl-clearlinux.py",  # new
        "p oracle": "pp-commands\\p-wsl-oracle.py",  # new
        "p pengwin": "pp-commands\\p-wsl-pengwin.py",  # new
        "p sles": "pp-commands\\p-wsl-sles.py",  # new
        "p neofetch": "pp-commands\\p-neofetch.py",  # new
        "p fastfetch": "pp-commands\\p-neofetch.py",  # new
        "p screenfetch": "pp-commands\\p-neofetch.py",  # new
        "p vswhere": "pp-commands\\p-vswhere.py",  # new
        "p speedtest": "pp-commands\\p-speedtest.py",  # new
        "p compiler": "pp-commands\\p-compiler.py",  # new
        "install 3d-slicer": "run\\simon\\3d-slicer\\install-3d-slicer.py",  # new
        "run 3d-slicer": "run\\simon\\3d-slicer\\run-3d-slicer.py",  # new
        "pr 3d-slicer": "run\\simon\\3d-slicer\\run-3d-slicer.py",  # new
        "run 3dslicer": "run\\simon\\3d-slicer\\run-3d-slicer.py",  # new
        "pr 3dslicer": "run\\simon\\3d-slicer\\run-3d-slicer.py",  # new
        "install simon": "run\\simon\\install-simon-3.py",  # new
        "install simo1": "run\\simon\\install-simon-1.py",  # new
        "install simo3": "run\\simon\\install-simon-3.py",  # new
        "run simon": "mavis-run-jup\\run-jup.py",  # new
        "pr simon": "mavis-run-jup\\run-jup.py",  # new
        "jupyter --version": "pp-commands\\jupyter-version.py",  # new
        "grafana --version": "pp-commands\\grafana-version.py",  # new
        "3d-slicer --version": "pp-commands\\3d-slicer-version.py",  # new
        "doctor": "pp-commands\\doctor.py",  # new
        "hole doctor": "pp-commands\\doctor-hole.py",  # new
        "install cool pin": "pp-commands\\theme-pcc.py",  # new
        "install cool pin-2": "pp-commands\\theme-pcc-2.py",  # new
        "install cool pin-3": "pp-commands\\theme-pcc-3.py",  # new
        "install cool pin-4": "pp-commands\\theme-pcc-4.py",  # new
        "install cool pin-5": "pp-commands\\theme-pcc-5.py",  # new
        "install cool pin-6": "pp-commands\\theme-pcc-6.py",  # new
        "install cool pin-7": "pp-commands\\theme-pcc-7.py",  # new
        "install cool pin-8": "pp-commands\\theme-pcc-8.py",  # new
        "install cool pin-9": "pp-commands\\theme-pcc-9.py",  # new
        "install cool pin-10": "pp-commands\\theme-pcc-10.py",  # new
        "install cool pin-11": "pp-commands\\theme-pcc-11.py",  # new
        "install cool pin-13": "pp-commands\\theme-pcc-13.py",  # new
        "install cool pin-14": "pp-commands\\theme-pcc-14.py",  # new
        "install cool pin-15": "pp-commands\\theme-pcc-15.py",  # new
        "install cool pin-16": "pp-commands\\theme-pcc-16.py",  # new
        "install cool pin-17": "pp-commands\\theme-pcc-17.py",  # new
        "install cool pin-18": "pp-commands\\theme-pcc-18.py",  # new
        "install cool pin-19": "pp-commands\\theme-pcc-19.py",  # new
        "install cool pin-20": "pp-commands\\theme-pcc-20.py",  # new
        "install cool pin-21": "pp-commands\\theme-pcc-21.py",  # new
        "install cool pin-22": "pp-commands\\theme-pcc-22.py",  # new
        "install cool pin-23": "pp-commands\\theme-pcc-23.py",  # new
        "run githubdesktop": "pp-commands\\githubdesktop.py",  # new
        "run ghd": "pp-commands\\githubdesktop.py",  # new
        "run dockerdesktop": "pp-commands\\dockerdesktop.py",  # new
        "run pycharm": "pp-commands\\run-pycharm.py",  # new
        "run vs-code": "pp-commands\\run-vs-code.py",  # new
        "run vs": "pp-commands\\run-vs.py",  # new
        "pr githubdesktop": "pp-commands\\githubdesktop.py",  # new
        "pr ghd": "pp-commands\\githubdesktop.py",  # new
        "pr dockerdesktop": "pp-commands\\dockerdesktop.py",  # new
        "pr pycharm": "pp-commands\\run-pycharm.py",  # new
        "pr vs-code": "pp-commands\\run-vs-code.py",  # new
        "pr vs": "pp-commands\\run-vs.py",  # new
        "p map": "pp-commands\\p-map.py",  # new
        "p weather": "pp-commands\\p-weather.py",  # new
        "p you": "pp-commands\\you.py",  # new
        "p qwen": "pp-commands\\qwen.py",  # new
        "p poe": "pp-commands\\poe.py",  # new
        "p perplexity": "pp-commands\\perplexity.py",  # new
        "p mistral": "pp-commands\\mistral.py",  # new
        "p jasper": "pp-commands\\jasper.py",  # new
        "p grok": "pp-commands\\grok.py",  # new
        "p gemini": "pp-commands\\gemini.py",  # new
        "p deepseek": "pp-commands\\deepseek.py",  # new
        "p copy": "pp-commands\\copy.py",  # new
        "p claude": "pp-commands\\claude.py",  # new
        "p chatgpt": "pp-commands\\chatgpt.py",  # new
        "p savannah gnu": "pp-commands\\p-savannah-gnu.py",  # new
        "p gnu": "pp-commands\\p-gnu.py",  # new
        "p gnu software": "pp-commands\\p-gnu-software.py",  # new
        "p git.com": "pp-commands\\p-git-com.py",  # new
        "run mavis main": "pp-commands\\run-mavis-main.py",  # new
        "run mavis main fast": "pp-commands\\run-mavis-main-fast.py",  # new
        "pr mavis main": "pp-commands\\run-mavis-main.py",  # new
        "pr mavis main fast": "pp-commands\\run-mavis-main-fast.py"  # new
    }

    commands3 = {
        "fun": "pp-commands\\fun-matrix.py",  # new
        "fun sl": "pp-commands\\fun-sl.py",  # new
        "fun aafire": "pp-commands\\fun-aafire.py",  # new
        "fun cmatrix": "pp-commands\\fun-cmatrix.py",  # new
        "fun cow": "pp-commands\\fun-cow.py",  # new
        "fun dragon": "pp-commands\\fun-dragon.py",  # new
        "fun figlet": "pp-commands\\fun-figlet.py",  # new
        "fun fortune": "pp-commands\\fun-fortune.py",  # new
        "install fun main": "pp-commands\\fun-install.py",  # new
        "install fun games main": "pp-commands\\fun-install.py",  # new
        "install fun calc main": "pp-commands\\fun-install.py",  # new
        "fun ponysay": "pp-commands\\fun-ponysay.py",  # new
        "fun telnet": "pp-commands\\fun-telnet.py",  # new
        "fun train": "pp-commands\\fun-train.py",  # new
        "fun train a": "pp-commands\\fun-train-a.py",  # new
        "fun train F": "pp-commands\\fun-train-F.py",  # new
        "fun train l": "pp-commands\\fun-train-l.py",  # new
        "fun train S": "pp-commands\\fun-train-S.py",  # new
        "fun train t": "pp-commands\\fun-train-t.py",  # new
        "fun install games": "pp-commands\\fun-install-games.py",  # new
        "fun bastet": "pp-commands\\fun-bashtet.py",  # new
        "fun chess": "pp-commands\\fun-gnuchess.py",  # new
        "fun moon-buggy": "pp-commands\\fun-moon-buggy.py",  # new
        "fun nethack": "pp-commands\\fun-nethack-console.py",  # new
        "fun nsnake": "pp-commands\\fun-nsnake.py",  # new
        "fun pacman": "pp-commands\\fun-pacman4console.py",  # new
        "fun tictactoe": "pp-commands\\fun-tictactoe-ng.py",  # new
        "fun tint": "pp-commands\\fun-tint.py",  # new
        "fun tetris": "pp-commands\\fun-vitetris.py",  # new
        "fun calculator": "pp-commands\\fun-calc.py",  # new
        "fun calc": "pp-commands\\fun-calc.py",  # new
        "fun install calculator": "pp-commands\\fun-install-calc.py",  # new
        "fun matrix": "pp-commands\\fun-matrix.py",  # new
        "fun matrix green": "pp-commands\\fun-matrix-green.py",  # new
        "fun aquarium": "pp-commands\\fun-asciiquarium.py",  # new
        "fun aqua": "pp-commands\\fun-asciiquarium.py",  # new
        "fun bb": "pp-commands\\fun-bb.py",  # new
        "install fun": "pp-commands\\fun-matrix.py",  # new
        "install fun sl": "pp-commands\\fun-sl.py",  # new
        "install fun aafire": "pp-commands\\fun-aafire.py",  # new
        "install fun cmatrix": "pp-commands\\fun-cmatrix.py",  # new
        "install fun cow": "pp-commands\\fun-cow.py",  # new
        "install fun dragon": "pp-commands\\fun-dragon.py",  # new
        "install fun figlet": "pp-commands\\fun-figlet.py",  # new
        "install fun fortune": "pp-commands\\fun-fortune.py",  # new
        "install fun ponysay": "pp-commands\\fun-ponysay.py",  # new
        "install fun telnet": "pp-commands\\fun-telnet.py",  # new
        "install fun train": "pp-commands\\fun-train.py",  # new
        "install fun install games": "pp-commands\\fun-install-games.py",  # new
        "install fun bastet": "pp-commands\\fun-bashtet.py",  # new
        "install fun chess": "pp-commands\\fun-gnuchess.py",  # new
        "install fun moon-buggy": "pp-commands\\fun-moon-buggy.py",  # new
        "install fun nethack": "pp-commands\\fun-nethack-console.py",  # new
        "install fun nsnake": "pp-commands\\fun-nsnake.py",  # new
        "install fun pacman": "pp-commands\\fun-pacman4console.py",  # new
        "install fun tictactoe": "pp-commands\\fun-tictactoe-ng.py",  # new
        "install fun tint": "pp-commands\\fun-tint.py",  # new
        "install fun tetris": "pp-commands\\fun-vitetris.py",  # new
        "install fun calculator": "pp-commands\\fun-calc.py",  # new
        "install fun calc": "pp-commands\\fun-calc.py",  # new
        "install fun install calculator": "pp-commands\\fun-install-calc.py",  # new
        "install fun matrix": "pp-commands\\fun-matrix.py",  # new
        "install fun matrix green": "pp-commands\\fun-matrix-green.py",  # new
        "install fun aquarium": "pp-commands\\fun-asciiquarium.py",  # new
        "install fun aqua": "pp-commands\\fun-asciiquarium.py",  # new
        "install fun bb": "pp-commands\\fun-bb.py",  # new
        "jupyter": "mavis-run-jup\\run-jup.py",
        "run jupyter": "mavis-run-jup\\run-jup.py",
        "pr jup": "mavis-run-jup\\run-jup.py",  # new
        "pr jupyter": "mavis-run-jup\\run-jup.py",
        "pr jup": "mavis-run-jup\\run-jup.py",  # new
        "htop": "pp-commands\\htop.py",  # new
        "bashtop": "pp-commands\\bashtop.py",  # new
        "taskmanager": "pp-commands\\bashtop.py",  # new
        "btop": "pp-commands\\btop.py",  # new
        "atop": "pp-commands\\atop.py",  # new
        "emacs-lx": "pp-commands\\emacs.py",  # new
        "pemacs-lx": "pp-commands\\emacs.py",  # new
        "emacs": "pp-commands\\emacs-win.py",  # new
        "pemacs": "pp-commands\\emacs-win.py",  # new
        "vim-lx": "pp-commands\\vim.py",  # new
        "pvim-lx": "pp-commands\\vim.py",  # new
        "vim": "pp-commands\\vim-win.py",  # new
        "pvim": "pp-commands\\vim-win.py",  # new
        "vim": "pp-commands\\vim.py",  # new
        "nano": "pp-commands\\nano.py",  # new
        "dstat": "pp-commands\\dstat.py",  # new
        "nmon": "pp-commands\\nmon.py",  # new
        "glances": "pp-commands\\glances.py",  # new
        "iftop": "pp-commands\\iftop.py",  # new
        "nethogs": "pp-commands\\nethogs.py",  # new
        "bmon": "pp-commands\\bmon.py",  # new
        "tcpdump": "pp-commands\\tcpdump.py",  # new
        "speedtest-cli": "pp-commands\\speedtest-cli.py",  # new
        "ncdu": "pp-commands\\ncdu.py",  # new
        "duf": "pp-commands\\duf.py",  # new
        "lsblk": "pp-commands\\lsblk.py",  # new
        "iotop": "pp-commands\\iotop.py",  # new
        "fzf": "pp-commands\\fzf.py",  # new
        "fd": "pp-commands\\fd.py",  # new
        "ripgrep": "pp-commands\\ripgrep.py",  # new
        "tmux": "pp-commands\\tmux.py",  # new
        "bat": "pp-commands\\bat.py",  # new
        "exa": "pp-commands\\exa.py",  # new
        "tldr": "pp-commands\\tldr.py",  # new
        "gitui": "pp-commands\\gitui.py",  # new
        "lazygit": "pp-commands\\lazygit.py",  # new
        "zoxide": "pp-commands\\zoxide.py",  # new
        "starship": "pp-commands\\starship.py",  # new
        "nala": "pp-commands\\nala.py",  # new
        "bpytop": "pp-commands\\bpytop.py",  # new
        "belnder": "pp-commands\\belnder.py",  # new
        "clion": "pp-commands\\clion.py",  # new
        "community": "pp-commands\\community.py",  # new
        "intellij": "pp-commands\\intellij.py",  # new
        "pycharm": "pp-commands\\pycharm.py",  # new
        "rider": "pp-commands\\rider.py",  # new
        "vs-code": "pp-commands\\vs-code.py",  # new
        "webstorm": "pp-commands\\webstorm.py",  # new
        "golab": "pp-commands\\golab.py",  # new
        "phpstorm": "pp-commands\\phpstorm.py",  # new
        "githubdesktop": "pp-commands\\githubdesktop.py",  # new
        "ghd": "pp-commands\\githubdesktop.py",  # new
        "nvim-lx": "pp-commands\\nvim.py",  # new
        "nvim": "pp-commands\\nvim-win.py",  # new
        "pnvim-lx": "pp-commands\\nvim.py",  # new
        "pnvim": "pp-commands\\nvim-win.py",  # new
        "code-lx": "pp-commands\\code.py",  # new
        "pcode-lx": "pp-commands\\code.py",  # new
        "code": "pp-commands\\code-win.py",  # new
        "pcode": "pp-commands\\code-win.py",  # new
        "thonny-lx": "pp-commands\\thonny.py",  # new
        "pthonny-lx": "pp-commands\\thonny.py",  # new
        "thonny": "pp-commands\\thonny-win.py",  # new
        "pthonny": "pp-commands\\thonny-win.py",  # new
        "micro": "pp-commands\\micro.py",  # new
        "gedit": "pp-commands\\gedit.py",  # new
        "update": "pp-commands\\update.py",  # new
        "selfupdate": "pp-commands\\update.py",  # new
        "update pp-term": "pp-commands\\updade.py",  # new
        "kakoune": "pp-commands\\kakoune.py",  # new
        "helix": "pp-commands\\helix.py",  # new
        "jed": "pp-commands\\jed.py",  # new
        "joe": "pp-commands\\joe.py",  # new
        "mg": "pp-commands\\mg.py",  # new
        "acme": "pp-commands\\acme.py",  # new
        "geany": "pp-commands\\geany.py",  # new
        "kate": "pp-commands\\kate.py",  # new
        "mousepad": "pp-commands\\mousepad.py",  # new
        "xed": "pp-commands\\xed.py",  # new
        "entr": "pp-commands\\entr.py",  # new
        "asdf": "pp-commands\\asdf.py",  # new
        "direnv": "pp-commands\\direnv.py",  # new
        "nmap": "pp-commands\\nmap.py",  # new
        "iperf3": "pp-commands\\iperf3.py",  # new
        "glow": "pp-commands\\glow.py",  # new
        "ranger": "pp-commands\\ranger.py",  # new
        "espanso": "pp-commands\\espanso.py",  # new
        "plasma-workspace": "pp-commands\\plasma-workspace.py",  # new
        "syncthing": "pp-commands\\syncthing.py",  # new
        "flatpak": "pp-commands\\flatpak.py",  # new
        "atom": "pp-commands\\atom.py",  # new
        "lite-xl": "pp-commands\\lite-xl.py",  # new
        "weather": "pp-commands\\weather.py",  # new
        "g++": "pp-commands\\gpp.py",  # new
        "gcc": "pp-commands\\gcc.py",  # new
        "install alpine-wsl": "run\\wsl\\install-alpine-wsl.py",  # new
        "install arch-wsl": "run\\wsl\\install-arch-wsl.py",  # new
        "install clear-wsl": "run\\wsl\\install-clear-wsl.py",  # new
        "install debian-wsl": "run\\wsl\\install-debian-wsl.py",  # new
        "install fedora-wsl": "run\\wsl\\install-fedora-wsl.py",  # new
        "install kali-wsl": "run\\wsl\\install-kali-wsl.py",  # new
        "install mint-wsl": "run\\wsl\\install-mint-wsl.py",  # new
        "install opensuse-wsl": "run\\wsl\\install-opensuse-wsl.py",  # new
        "install oracle-wsl": "run\\wsl\\install-oracle-wsl.py",  # new
        "install pengwin-wsl": "run\\wsl\\install-pengwin-wsl.py",  # new
        "install redhat-wsl": "run\\wsl\\install-redhat-wsl.py",  # new
        "install suse-wsl": "run\\wsl\\install-suse-wsl.py",  # new
        "install ubuntu-wsl": "run\\wsl\\install-ubuntu-wsl.py",  # new
        "install wsl": "run\\wsl\\install-wsl.py",  # new
        "install vs-code": "run\vs\\install-vs-code.py",  # new
        "install rustup": "run\\rust\\rustup\\install-rustup.py",  # new
        "install ruby": "run\\ruby\\install-ruby.py",  # new
        "install rscript": "run\\ruby\\install-rscript.py",
        "install pycharm": "run\\pycharm\\install-pycharm.py",  # new
        "install nodejs": "run\\java\\javac\\install-nodejs.py",  # new
        "install githubdesktop": "run\\github\\install-githubdesktop.py",  # new
        "ghd githubdesktop": "run\\github\\install-githubdesktop.py",  # new
        "install docker": "run\\docker\\install-dockerdesktop.py",  # new
        "install vs-cpp": "run\\cpp\\install-vs-cpp.py",  # new
        "install vs-c": "run\\c\\install-vs-c.py",  # new
        "install vs-cs": "run\\cs\\install-vs.py",  # new
        "install go": "run\\go\\install-go.py",  # new
        "install julia": "run\\julia\\install-julia.py",  # new
        "install ffmpeg": "run\\ffmpeg\\install-ffmpeg.py",  # new
        "install clojure": "run\\clojure\\install-clojure.py",  # new
        "install dart": "run\\dart\\install-dart.py",  # new
        "install elixir": "run\\elixir\\install-elixir.py",  # new
        "install elm": "run\\elm\\install-elm.py",  # new
        "install fs": "run\\fs\\install-fs.py",  # new
        "install haskell": "run\\haskell\\install-haskell.py",  # new
        "install kotlin": "run\\haskell\\install-kotlin.py",  # new
        "install lua": "run\\lua\\install-lua.py",  # new
        "install php": "run\\php\\install-php.py",  # new
        "install scala": "run\\scala\\install-scala.py",  # new
        "install swift": "run\\swift\\install-swift.py",  # new
        "install typescript": "run\\typescript\\install-typescript.py",  # new
        "install zig": "run\\zig\\install-zig.py",  # new
        "install v": "run\\v\\install-v.py",  # new
        "install solidity": "run\\solidity\\install-solidity.py",  # new
        "install nim": "run\\nim\\install-nim.py",  # new
        "install haxe": "run\\haxe\\install-haxe.py",  # new
        "install hack": "run\\hack\\install-hack.py",  # new
        "install fortran": "run\\fortran\\install-fortran.py",  # new
        "install lisp": "run\\lisp\\install-lisp.py",  # new
        "install racket": "run\\racket\\install-racket.py",  # new
        "install g++": "pp-commands\\gpp.py",  # new
        "install gcc": "pp-commands\\gcc.py",  # new
        "install algol": "pp-commands\\gcc.py",  # new
        "install htop": "pp-commands\\htop.py",  # new
        "install bashtop": "pp-commands\\bashtop.py",  # new
        "install taskmanager": "pp-commands\\bashtop.py",  # new
        "install btop": "pp-commands\\btop.py",  # new
        "install atop": "pp-commands\\atop.py",  # new
        "install emacs-lx": "pp-commands\\emacs.py",  # new
        "install pemacs-lx": "pp-commands\\emacs.py",  # new
        "install emacs": "pp-commands\\emacs-win.py",  # new
        "install pemacs": "pp-commands\\emacs-win.py",  # new
        "install vim-lx": "pp-commands\\vim.py",  # new
        "install pvim-lx": "pp-commands\\vim.py",  # new
        "install vim": "pp-commands\\vim-win.py",  # new
        "install pvim": "pp-commands\\vim-win.py",  # new
        "install vim": "pp-commands\\vim.py",  # new
        "install nano": "pp-commands\\nano.py",  # new
        "install dstat": "pp-commands\\dstat.py",  # new
        "install nmon": "pp-commands\\nmon.py",  # new
        "install glances": "pp-commands\\glances.py",  # new
        "install iftop": "pp-commands\\iftop.py",  # new
        "install nethogs": "pp-commands\\nethogs.py",  # new
        "install bmon": "pp-commands\\bmon.py",  # new
        "install tcpdump": "pp-commands\\tcpdump.py",  # new
        "install speedtest-cli": "pp-commands\\speedtest-cli.py",  # new
        "install ncdu": "pp-commands\\ncdu.py",  # new
        "install duf": "pp-commands\\duf.py",  # new
        "install lsblk": "pp-commands\\lsblk.py",  # new
        "install iotop": "pp-commands\\iotop.py",  # new
        "install fzf": "pp-commands\\fzf.py",  # new
        "install fd": "pp-commands\\fd.py",  # new
        "install ripgrep": "pp-commands\\ripgrep.py",  # new
        "install tmux": "pp-commands\\tmux.py",  # new
        "install bat": "pp-commands\\bat.py",  # new
        "install exa": "pp-commands\\exa.py",  # new
        "install tldr": "pp-commands\\tldr.py",  # new
        "install gitui": "pp-commands\\gitui.py",  # new
        "install lazygit": "pp-commands\\lazygit.py",  # new
        "install zoxide": "pp-commands\\zoxide.py",  # new
        "install starship": "pp-commands\\starship.py",  # new
        "install nala": "pp-commands\\nala.py",  # new
        "install bpytop": "pp-commands\\bpytop.py",  # new
        "install belnder": "pp-commands\\belnder.py",  # new
        "install clion": "pp-commands\\clion.py",  # new
        "install community": "pp-commands\\community.py",  # new
        "install intellij": "pp-commands\\intellij.py",  # new
        "install rider": "pp-commands\\rider.py",  # new
        "install webstorm": "pp-commands\\webstorm.py",  # new
        "install golab": "pp-commands\\golab.py",  # new
        "install phpstorm": "pp-commands\\phpstorm.py",  # new
        "install nvim-lx": "pp-commands\\nvim.py",  # new
        "install nvim": "pp-commands\\nvim-win.py",  # new
        "install pnvim-lx": "pp-commands\\nvim.py",  # new
        "install pnvim": "pp-commands\\nvim-win.py",  # new
        "install code-lx": "pp-commands\\code.py",  # new
        "install pcode-lx": "pp-commands\\code.py",  # new
        "install code": "pp-commands\\code-win.py",  # new
        "install pcode": "pp-commands\\code-win.py",  # new
        "install thonny-lx": "pp-commands\\thonny.py",  # new
        "install pthonny-lx": "pp-commands\\thonny.py",  # new
        "install thonny": "pp-commands\\thonny-win.py",  # new
        "install pthonny": "pp-commands\\thonny-win.py",  # new
        "install micro": "pp-commands\\micro.py",  # new
        "install gedit": "pp-commands\\gedit.py",  # new
        "install update": "pp-commands\\update.py",  # new
        "install selfupdate": "pp-commands\\update.py",  # new
        "install update pp-term": "pp-commands\\updade.py",  # new
        "install kakoune": "pp-commands\\kakoune.py",  # new
        "install helix": "pp-commands\\helix.py",  # new
        "install jed": "pp-commands\\jed.py",  # new
        "install joe": "pp-commands\\joe.py",  # new
        "install mg": "pp-commands\\mg.py",  # new
        "install acme": "pp-commands\\acme.py",  # new
        "install geany": "pp-commands\\geany.py",  # new
        "install kate": "pp-commands\\kate.py",  # new
        "install mousepad": "pp-commands\\mousepad.py",  # new
        "install xed": "pp-commands\\xed.py",  # new
        "install entr": "pp-commands\\entr.py",  # new
        "install asdf": "pp-commands\\asdf.py",  # new
        "install direnv": "pp-commands\\direnv.py",  # new
        "install nmap": "pp-commands\\nmap.py",  # new
        "install iperf3": "pp-commands\\iperf3.py",  # new
        "install glow": "pp-commands\\glow.py",  # new
        "install ranger": "pp-commands\\ranger.py",  # new
        "install espanso": "pp-commands\\espanso.py",  # new
        "install plasma-workspace": "pp-commands\\plasma-workspace.py",  # new
        "install syncthing": "pp-commands\\syncthing.py",  # new
        "install flatpak": "pp-commands\\flatpak.py",  # new
        "install atom": "pp-commands\\atom.py",  # new
        "install lite-xl": "pp-commands\\lite-xl.py",  # new
        "install weather": "pp-commands\\weather.py",  # new
        "install grafana": "mavis-run-grafana\\run-grafana.py",
        "update ollama": "pp-commands\\update-ollama.py",  # new
        "update git": "pp-commands\\update-git.py",  # new
        "update visual studio build tools": "pp-commands\\update-vsb.py",  # new
        "update vsb": "pp-commands\\update-vsb.py",  # new
        "update rustup": "pp-commands\\update-rustup.py",  # new
        "update docker": "pp-commands\\update-docker.py",  # new
        "update wsl": "pp-commands\\update-wsl.py",  # new
        "update powershell": "pp-commands\\update-powershell.py",  # new
        "grafana": "mavis-run-grafana\\run-grafana.py",
        "run grafana": "mavis-run-grafana\\run-grafana.py",
        "pr grafana": "mavis-run-grafana\\run-grafana.py",
        "pi mavis env": "mavis-install\\install-info-mavis-4.py",
        "pi mavis-3": "mavis-install\\install-info-mavis-4.py",  # new
        "pi mavis-3.3": "mavis-install\\install-info-mavis-4.py",  # new
        "pi mavis-3-3": "mavis-install\\install-info-mavis-4.py",  # new
        "pi mavis-4": "mavis-install\\install-info-mavis-4.py",  # new
        "pi mavis-4.3": "mavis-install\\install-info-mavis-4.py",  # new
        "pi mavis-4-3": "mavis-install\\install-info-mavis-4.py",  # new
        "pi ollama mavis-4": "mavis-install\\install-ollama-mavis-4.py",  # new
        "pi grafana": "mavis-run-grafana\\run-grafana.py",  # new
        "pi deepseek-r1:1.5b": "pp-commands\\deepseek-r1-1-5b.py",  # new
        "pi deepseek-r1:7b": "pp-commands\\deepseek-r1-7b.py",  # new
        "pi deepseek-r1:8b": "pp-commands\\deepseek-r1-8b.py",  # new
        "pi deepseek-r1:14b": "pp-commands\\deepseek-r1-14b.py",  # new
        "pi deepseek-r1:32b": "pp-commands\\deepseek-r1-32b.py",  # new
        "pi deepseek-r1:70b": "pp-commands\\deepseek-r1-70b.py",  # new
        "pi deepseek-r1:671b": "pp-commands\\deepseek-r1-671b.py",  # new
        "pi deepscaler": "pp-commands\\deepscaler.py",  # new
        "pi llama3.1:8b": "pp-commands\\llama-3-1-8b.py",  # new
        "pi llama3.1:70b": "pp-commands\\llama-3-1-70b.py",  # new
        "pi llama3.1:405": "pp-commands\\llama-3-1-405b.py",  # new
        "pi llama3.2:1b": "pp-commands\\llama-3-2-1b.py",  # new
        "pi llama3.2:3b": "pp-commands\\llama-3-2-3b.py",  # new
        "pi llama3.3": "pp-commands\\llama-3-3.py",  # new
        "pi llama3:8b": "pp-commands\\llama-3-8b.py",  # new
        "pi llama3:70b": "pp-commands\\llama-3-70b.py",  # new
        "pi mistral": "pp-commands\\mistral.py",  # new
        "pi mistral-large": "pp-commands\\mistral-large.py",  # new
        "pi mistral-nemo": "pp-commands\\mistral-nemo.py",  # new
        "pi mistral-openorca": "pp-commands\\mistral-openorca.py",  # new
        "pi mistral-small:22b": "pp-commands\\mistral-small-22b.py",  # new
        "pi mistral-small:24b": "pp-commands\\mistral-small-24b.py",  # new
        "pi phi4": "pp-commands\\phi-4.py",  # new
        "pi qwen2.5:0.5b": "pp-commands\\qwen-2-5-0.5b.py",  # new
        "pi qwen2.5:1.5b": "pp-commands\\qwen-2-5-1.5b.py",  # new
        "pi qwen2.5:3b": "pp-commands\\qwen-2-5-3b.py",  # new
        "pi qwen2.5:7b": "pp-commands\\qwen-2-5-7b.py",  # new
        "pi qwen2.5:14b": "pp-commands\\qwen-2-5-14b.py",  # new
        "pi qwen2.5:32b": "pp-commands\\qwen-2-5-32b.py",  # new
        "pi qwen2.5:72b": "pp-commands\\qwen-2-5-72b.py",  # new
        "pi qwen2.5-coder:0.5b": "pp-commands\\qwen-2-5-coder-0.5b.py",  # new
        "pi qwen2.5-coder:1.5b": "pp-commands\\qwen-2-5-coder-0.5b.py",  # new
        "pi qwen2.5-coder:3b": "pp-commands\\qwen-2-5-coder-0.5b.py",  # new
        "pi qwen2.5-coder:7b": "pp-commands\\qwen-2-5-coder-0.5b.py",  # new
        "pi qwen2.5-coder:14b": "pp-commands\\qwen-2-5-coder-0.5b.py",  # new
        "pi qwen2.5-coder:32b": "pp-commands\\qwen-2-5-coder-0.5b.py",  # new
        "pi gemma3:1b": "pp-commands\\gemma-3-1b.py",  # new
        "pi gemma3:4b": "pp-commands\\gemma-3-4b.py",  # new
        "pi gemma3:12b": "pp-commands\\gemma-3-12b.py",  # new
        "pi gemma3:27b": "pp-commands\\gemma-3-27b.py",  # new
        "pi qwq": "pp-commands\\qwq.py",  # new
        "pi command-a": "pp-commands\\command-a.py",  # new
        "pi phi4-mini": "pp-commands\\phi-4-mini.py",  # new
        "pi granite3.2:8b": "pp-commands\\granite-3-2-8b.py",  # new
        "pi granite3.2:2b": "pp-commands\\granite-3-2-2b.py",  # new
        "pi granite3.2-vision:2b": "pp-commands\\granite-3-2-2b-vision.py",  # new
        "pi qwen-2-5-omni:7b": "pp-commands\\qwen-2-5-omni-7b.py",  # new
        "pi qvq:72b": "pp-commands\\qvq-72b.py",  # new
        "pi qwen-2-5-vl:32b": "pp-commands\\qwen-2-5-vl-32b.py",  # new
        "pi qwen-2-5-vl:72b": "pp-commands\\qwen-2-5-vl-72b.py",  # new
        "pi llama-4-maverick:17b": "pp-commands\\llama-4-maverick-17b.py",  # new
        "pi llama-4-scout:17b": "pp-commands\\llama-4-scout-17b.py",  # new
        "pi deepcoder:1.5b": "pp-commands\\deepcoder-1-5b.py",  # new
        "pi deepcoder:14b": "pp-commands\\deepcoder-14b.py",  # new
        "pi mistral-small3.1": "pp-commands\\mistral-small-3-1.py",  # new
        "pi 3d-slicer": "run\\simon\\3d-slicer\\install-3d-slicer.py",  # new
        "pi simon": "run\\simon\\install-simon-3.py",  # new
        "pi simon1": "run\\simon\\install-simon-1.py",  # new
        "pi simon3": "run\\simon\\install-simon-3.py",  # new
        "pi fun main": "pp-commands\\fun-install.py",  # new
        "pi fun games main": "pp-commands\\fun-install.py",  # new
        "pi fun calc main": "pp-commands\\fun-install.py",  # new
        "pi fun": "pp-commands\\fun-matrix.py",  # new
        "pi fun sl": "pp-commands\\fun-sl.py",  # new
        "pi fun aafire": "pp-commands\\fun-aafire.py",  # new
        "pi fun cmatrix": "pp-commands\\fun-cmatrix.py",  # new
        "pi fun cow": "pp-commands\\fun-cow.py",  # new
        "pi fun dragon": "pp-commands\\fun-dragon.py",  # new
        "pi fun figlet": "pp-commands\\fun-figlet.py",  # new
        "pi fun fortune": "pp-commands\\fun-fortune.py",  # new
        "pi fun ponysay": "pp-commands\\fun-ponysay.py",  # new
        "pi fun telnet": "pp-commands\\fun-telnet.py",  # new
        "pi fun train": "pp-commands\\fun-train.py",  # new
        "pi fun install games": "pp-commands\\fun-install-games.py",  # new
        "pi fun bastet": "pp-commands\\fun-bashtet.py",  # new
        "pi fun chess": "pp-commands\\fun-gnuchess.py",  # new
        "pi fun moon-buggy": "pp-commands\\fun-moon-buggy.py",  # new
        "pi fun nethack": "pp-commands\\fun-nethack-console.py",  # new
        "pi fun nsnake": "pp-commands\\fun-nsnake.py",  # new
        "pi fun pacman": "pp-commands\\fun-pacman4console.py",  # new
        "pi fun tictactoe": "pp-commands\\fun-tictactoe-ng.py",  # new
        "pi fun tint": "pp-commands\\fun-tint.py",  # new
        "pi fun tetris": "pp-commands\\fun-vitetris.py",  # new
        "pi fun calculator": "pp-commands\\fun-calc.py",  # new
        "pi fun calc": "pp-commands\\fun-calc.py",  # new
        "pi fun install calculator": "pp-commands\\fun-install-calc.py",  # new
        "pi fun matrix": "pp-commands\\fun-matrix.py",  # new
        "pi fun matrix green": "pp-commands\\fun-matrix-green.py",  # new
        "pi fun aquarium": "pp-commands\\fun-asciiquarium.py",  # new
        "pi fun aqua": "pp-commands\\fun-asciiquarium.py",  # new
        "pi fun bb": "pp-commands\\fun-bb.py",  # new
        "pi cool pin": "pp-commands\\theme-pcc.py",  # new
        "pi cool pin-2": "pp-commands\\theme-pcc-2.py",  # new
        "pi cool pin-3": "pp-commands\\theme-pcc-3.py",  # new
        "pi cool pin-4": "pp-commands\\theme-pcc-4.py",  # new
        "pi cool pin-5": "pp-commands\\theme-pcc-5.py",  # new
        "pi cool pin-6": "pp-commands\\theme-pcc-6.py",  # new
        "pi cool pin-7": "pp-commands\\theme-pcc-7.py",  # new
        "pi cool pin-8": "pp-commands\\theme-pcc-8.py",  # new
        "pi pi pin-9": "pp-commands\\theme-pcc-9.py",  # new
        "pi cool pin-10": "pp-commands\\theme-pcc-10.py",  # new
        "pi cool pin-11": "pp-commands\\theme-pcc-11.py",  # new
        "pi cool pin-13": "pp-commands\\theme-pcc-13.py",  # new
        "pi cool pin-14": "pp-commands\\theme-pcc-14.py",  # new
        "pi cool pin-15": "pp-commands\\theme-pcc-15.py",  # new
        "pi cool pin-16": "pp-commands\\theme-pcc-16.py",  # new
        "pi cool pin-17": "pp-commands\\theme-pcc-17.py",  # new
        "pi cool pin-18": "pp-commands\\theme-pcc-18.py",  # new
        "pi cool pin-19": "pp-commands\\theme-pcc-19.py",  # new
        "pi cool pin-20": "pp-commands\\theme-pcc-20.py",  # new
        "pi cool pin-21": "pp-commands\\theme-pcc-21.py",  # new
        "pi cool pin-22": "pp-commands\\theme-pcc-22.py",  # new
        "pi cool pin-23": "pp-commands\\theme-pcc-23.py",  # new
        "pi alpine-wsl": "run\\wsl\\install-alpine-wsl.py",  # new
        "pi arch-wsl": "run\\wsl\\install-arch-wsl.py",  # new
        "pi clear-wsl": "run\\wsl\\install-clear-wsl.py",  # new
        "pi debian-wsl": "run\\wsl\\install-debian-wsl.py",  # new
        "pi fedora-wsl": "run\\wsl\\install-fedora-wsl.py",  # new
        "pi kali-wsl": "run\\wsl\\install-kali-wsl.py",  # new
        "pi mint-wsl": "run\\wsl\\install-mint-wsl.py",  # new
        "pi opensuse-wsl": "run\\wsl\\install-opensuse-wsl.py",  # new
        "pi oracle-wsl": "run\\wsl\\install-oracle-wsl.py",  # new
        "pi pengwin-wsl": "run\\wsl\\install-pengwin-wsl.py",  # new
        "pi redhat-wsl": "run\\wsl\\install-redhat-wsl.py",  # new
        "pi suse-wsl": "run\\wsl\\install-suse-wsl.py",  # new
        "pi ubuntu-wsl": "run\\wsl\\install-ubuntu-wsl.py",  # new
        "pi wsl": "run\\wsl\\install-wsl.py",  # new
        "pi vs-code": "run\vs\\install-vs-code.py",  # new
        "pi rustup": "run\\rust\\rustup\\install-rustup.py",  # new
        "pi ruby": "run\\ruby\\install-ruby.py",  # new
        "pi rscript": "run\\ruby\\install-rscript.py",
        "pi pycharm": "run\\pycharm\\install-pycharm.py",  # new
        "pi nodejs": "run\\java\\javac\\install-nodejs.py",  # new
        "pi githubdesktop": "run\\github\\install-githubdesktop.py",  # new
        "pi ghd": "run\\github\\install-githubdesktop.py",  # new
        "pi docker": "run\\docker\\install-dockerdesktop.py",  # new
        "pi vs-cpp": "run\\cpp\\install-vs-cpp.py",  # new
        "pi vs-c": "run\\c\\install-vs-c.py",  # new
        "pi vs-cs": "run\\cs\\install-vs.py",  # new
        "pi go": "run\\go\\install-go.py",  # new
        "pi julia": "run\\julia\\install-julia.py",  # new
        "pi ffmpeg": "run\\ffmpeg\\install-ffmpeg.py",  # new
        "pi clojure": "run\\clojure\\install-clojure.py",  # new
        "pi dart": "run\\dart\\install-dart.py",  # new
        "pi elixir": "run\\elixir\\install-elixir.py",  # new
        "pi elm": "run\\elm\\install-elm.py",  # new
        "pi fs": "run\\fs\\install-fs.py",  # new
        "pi haskell": "run\\haskell\\install-haskell.py",  # new
        "pi kotlin": "run\\haskell\\install-kotlin.py",  # new
        "pi lua": "run\\lua\\install-lua.py",  # new
        "pi php": "run\\php\\install-php.py",  # new
        "pi scala": "run\\scala\\install-scala.py",  # new
        "pi swift": "run\\swift\\install-swift.py",  # new
        "pi typescript": "run\\typescript\\install-typescript.py",  # new
        "pi zig": "run\\zig\\install-zig.py",  # new
        "pi v": "run\\v\\install-v.py",  # new
        "pi solidity": "run\\solidity\\install-solidity.py",  # new
        "pi nim": "run\\nim\\install-nim.py",  # new
        "pi haxe": "run\\haxe\\install-haxe.py",  # new
        "pi hack": "run\\hack\\install-hack.py",  # new
        "pi fortran": "run\\fortran\\install-fortran.py",  # new
        "pi lisp": "run\\lisp\\install-lisp.py",  # new
        "pi racket": "run\\racket\\install-racket.py",  # new
        "pi g++": "pp-commands\\gpp.py",  # new
        "pi gcc": "pp-commands\\gcc.py",  # new
        "pi algol": "pp-commands\\gcc.py",  # new
        "pi htop": "pp-commands\\htop.py",  # new
        "pi bashtop": "pp-commands\\bashtop.py",  # new
        "pi taskmanager": "pp-commands\\bashtop.py",  # new
        "pi btop": "pp-commands\\btop.py",  # new
        "pi atop": "pp-commands\\atop.py",  # new
        "pi emacs-lx": "pp-commands\\emacs.py",  # new
        "pi pemacs-lx": "pp-commands\\emacs.py",  # new
        "pi emacs": "pp-commands\\emacs-win.py",  # new
        "pi pemacs": "pp-commands\\emacs-win.py",  # new
        "pi vim-lx": "pp-commands\\vim.py",  # new
        "pi pvim-lx": "pp-commands\\vim.py",  # new
        "pi vim": "pp-commands\\vim-win.py",  # new
        "pi pvim": "pp-commands\\vim-win.py",  # new
        "pi nano": "pp-commands\\nano.py",  # new
        "pi dstat": "pp-commands\\dstat.py",  # new
        "pi nmon": "pp-commands\\nmon.py",  # new
        "pi glances": "pp-commands\\glances.py",  # new
        "pi iftop": "pp-commands\\iftop.py",  # new
        "pi nethogs": "pp-commands\\nethogs.py",  # new
        "pi bmon": "pp-commands\\bmon.py",  # new
        "pi tcpdump": "pp-commands\\tcpdump.py",  # new
        "pi speedtest-cli": "pp-commands\\speedtest-cli.py",  # new
        "pi ncdu": "pp-commands\\ncdu.py",  # new
        "pi duf": "pp-commands\\duf.py",  # new
        "pi lsblk": "pp-commands\\lsblk.py",  # new
        "pi iotop": "pp-commands\\iotop.py",  # new
        "pi fzf": "pp-commands\\fzf.py",  # new
        "pi fd": "pp-commands\\fd.py",  # new
        "pi ripgrep": "pp-commands\\ripgrep.py",  # new
        "pi tmux": "pp-commands\\tmux.py",  # new
        "pi bat": "pp-commands\\bat.py",  # new
        "pi exa": "pp-commands\\exa.py",  # new
        "pi tldr": "pp-commands\\tldr.py",  # new
        "pi gitui": "pp-commands\\gitui.py",  # new
        "pi lazygit": "pp-commands\\lazygit.py",  # new
        "pi zoxide": "pp-commands\\zoxide.py",  # new
        "pi starship": "pp-commands\\starship.py",  # new
        "pi nala": "pp-commands\\nala.py",  # new
        "pi bpytop": "pp-commands\\bpytop.py",  # new
        "pi belnder": "pp-commands\\belnder.py",  # new
        "pi clion": "pp-commands\\clion.py",  # new
        "pi community": "pp-commands\\community.py",  # new
        "pi intellij": "pp-commands\\intellij.py",  # new
        "pi rider": "pp-commands\\rider.py",  # new
        "pi webstorm": "pp-commands\\webstorm.py",  # new
        "pi golab": "pp-commands\\golab.py",  # new
        "pi phpstorm": "pp-commands\\phpstorm.py",  # new
        "pi nvim-lx": "pp-commands\\nvim.py",  # new
        "pi nvim": "pp-commands\\nvim-win.py",  # new
        "pi pnvim-lx": "pp-commands\\nvim.py",  # new
        "pi pnvim": "pp-commands\\nvim-win.py",  # new
        "pi code-lx": "pp-commands\\code.py",  # new
        "pi pcode-lx": "pp-commands\\code.py",  # new
        "pi code": "pp-commands\\code-win.py",  # new
        "pi pcode": "pp-commands\\code-win.py",  # new
        "pi thonny-lx": "pp-commands\\thonny.py",  # new
        "pi pthonny-lx": "pp-commands\\thonny.py",  # new
        "pi thonny": "pp-commands\\thonny-win.py",  # new
        "pi pthonny": "pp-commands\\thonny-win.py",  # new
        "pi micro": "pp-commands\\micro.py",  # new
        "pi gedit": "pp-commands\\gedit.py",  # new
        "pi update": "pp-commands\\update.py",  # new
        "pi selfupdate": "pp-commands\\update.py",  # new
        "pi update pp-term": "pp-commands\\updade.py",  # new
        "pi kakoune": "pp-commands\\kakoune.py",  # new
        "pi helix": "pp-commands\\helix.py",  # new
        "pi jed": "pp-commands\\jed.py",  # new
        "pi joe": "pp-commands\\joe.py",  # new
        "pi mg": "pp-commands\\mg.py",  # new
        "pi acme": "pp-commands\\acme.py",  # new
        "pi geany": "pp-commands\\geany.py",  # new
        "pi kate": "pp-commands\\kate.py",  # new
        "pi mousepad": "pp-commands\\mousepad.py",  # new
        "pi xed": "pp-commands\\xed.py",  # new
        "pi entr": "pp-commands\\entr.py",  # new
        "pi asdf": "pp-commands\\asdf.py",  # new
        "pi direnv": "pp-commands\\direnv.py",  # new
        "pi nmap": "pp-commands\\nmap.py",  # new
        "pi iperf3": "pp-commands\\iperf3.py",  # new
        "pi glow": "pp-commands\\glow.py",  # new
        "pi ranger": "pp-commands\\ranger.py",  # new
        "pi espanso": "pp-commands\\espanso.py",  # new
        "pi plasma-workspace": "pp-commands\\plasma-workspace.py",  # new
        "pi syncthing": "pp-commands\\syncthing.py",  # new
        "pi flatpak": "pp-commands\\flatpak.py",  # new
        "pi atom": "pp-commands\\atom.py",  # new
        "pi lite-xl": "pp-commands\\lite-xl.py",  # new
        "pi weather": "pp-commands\\weather.py"  # new
    }

    # Hier alles in der if-Schleife:
    if user_input in commands:
        # 1) Skript-Pfad ermitteln
        base = Path.home() / "p-terminal" / "pp-term"
        script_rel_path = Path(commands[user_input])

        # Sicherheit: Verhindere absolute oder manipulierte Pfade
        if script_rel_path.is_absolute() or ".." in script_rel_path.parts:
            logging.error("[SECURITY] Invalid script path (absolute or parent traversal)")
            return True

        script_path = base / script_rel_path
        try:
            # Verhindere Ausbruch aus dem Basisverzeichnis
            script_path.resolve().relative_to(base.resolve())
        except ValueError:
            logging.error("[SECURITY] Script path outside of allowed base directory")
            return True

        if not script_path.exists():
            logging.error(f"[ERROR] Script not found: {script_path}")
            sys.exit(1)

        # 2) Maximale Priorität und CPU-Affinität vorbereiten
        if platform.system() == "Windows":
            creationflags = psutil.REALTIME_PRIORITY_CLASS
            logging.info("[INFO] Windows REALTIME_PRIORITY_CLASS selected")
        else:
            nice_value = -20
            creationflags = 0
            logging.info(f"[INFO] Unix nice value {nice_value} selected")

        all_cores = list(range(psutil.cpu_count(logical=True)))
        logging.info(f"[INFO] CPU affinity to cores {all_cores}")

        # 3) Kommandozeile zusammenbauen
        if script_path.suffix.lower() == ".bat":
            command = [str(script_path)]
            logging.info("[INFO] Start batch file")
        else:
            command = [python_path, str(script_path)]
            logging.info(f"[INFO] Start Python script with {python_path}")

        # 4) Prozess starten
        try:
            proc = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                creationflags=creationflags
            )
            p = psutil.Process(proc.pid)

            if platform.system() != "Windows":
                try:
                    p.nice(nice_value)
                    logging.info(f"[INFO] Unix nice set: {nice_value}")
                except Exception as e:
                    logging.warning(f"[WARNING] Could not set nice value: {e}")

            try:
                p.cpu_affinity(all_cores)
                logging.info("[INFO] CPU affinity set to all cores")
            except Exception as e:
                logging.warning(f"[WARNING] Could not set CPU affinity: {e}")

            # 5) Auf Beendigung warten (mit Timeout)
            try:
                stdout, stderr = proc.communicate(timeout=60)
            except subprocess.TimeoutExpired:
                proc.kill()
                logging.error("[ERROR] Script timed out and was terminated")
                return True

            if proc.returncode != 0:
                logging.error(f"[ERROR] Script error {proc.returncode}:\n{stderr.decode().strip()}")
                return True
            else:
                logging.info(f"[PASS] Script completed successfully:\n{stdout.decode().strip()}")
                return True

        except Exception as e:
            logging.exception(f"[ERROR] Error starting the script: {e}")
            return True

    if user_input in commands3:
        # Pfad zum Skript zusammenbauen
        base = Path.home() / "p-terminal" / "pp-term"
        script_path = base / commands3[user_input]

        # Prüfen, ob das Skript eine .bat-Datei ist
        if not user_input.endswith(".bat"):
            run([python_path, script_path])
        else:
            print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
            run([script_path], shell=True)
        return True

    # Built-in Commands Erweiterung
    if user_input.lower() in ["cls", "clear", "pcl"]:
        os.system("cls" if os.name == "nt" else "clear")
        return True

    if user_input.startswith("cd "):
        path = user_input[3:].strip()
        try:
            change_directory(path)
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error changing directory: {e}")
            return False

        found = find_env_in_current_dir()
        saved = load_saved_env()

        if found:
            if found != saved:
                save_current_env(found)
            return found
        else:
            return saved if saved else str(Path(DEFAULT_ENV_DIR).resolve())

    if user_input.startswith("pcd "):
        path = user_input[4:].strip()
        try:
            change_directory(path)
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error changing directory: {e}")
            return False

        found = find_env_in_current_dir()
        saved = load_saved_env()

        if found:
            if found != saved:
                save_current_env(found)
            return found
        else:
            return saved if saved else str(Path(DEFAULT_ENV_DIR).resolve())

    if user_input.lower() == "cd":
        path = os.path.expanduser("~")
        change_directory(path)

        found = find_env_in_current_dir()
        saved = load_saved_env()

        if found:
            if found != saved:
                save_current_env(found)
            return found
        else:
            return saved if saved else str(Path(DEFAULT_ENV_DIR).resolve())

        # env_path = handle_cd_command()
        # print(f"[{timestamp()}] [INFO] Environment used: {env_path}")

    if user_input.lower() == "pcd":
        path = os.path.expanduser("~")
        change_directory(path)

        found = find_env_in_current_dir()
        saved = load_saved_env()

        if found:
            if found != saved:
                save_current_env(found)
            return found
        else:
            return saved if saved else str(Path(DEFAULT_ENV_DIR).resolve())

        # env_path = handle_cd_command()
        # print(f"[{timestamp()}] [INFO] Environment used: {env_path}")

    if user_input.lower().startswith("ptd "):
        # Beispielbefehl:
        # ptd from="E:\Ordner\Quelle" to="C:\Ziel\Ordner"

        try:
            parts = user_input[4:].split('"')  # 'ptd ' sind 4 Zeichen
            source = parts[1]
            destination = parts[3]

            print(f"{main_color}[*]{reset} Source: {source}")
            print(f"{main_color}[*]{reset} Target: {destination}")

            if not os.path.exists(source):
                print(f"[{timestamp()}] [ERROR] Source folder not found: {source}")
            else:
                if not os.path.exists(destination):
                    os.makedirs(destination)
                    print(f"[{timestamp()}] [INFO] Target folder created: {destination}")

                files_copied = 0
                for filename in os.listdir(source):
                    src_file = os.path.join(source, filename)
                    dst_file = os.path.join(destination, filename)
                    if os.path.isfile(src_file):
                        try:
                            shutil.copy2(src_file, dst_file)
                            print(f"{main_color}[+]{reset} Copied: {filename}")
                            files_copied += 1
                        except Exception as copy_err:
                            print(f"[{timestamp()}] [ERROR] Failed to copy {filename}: {copy_err}")

                print(f"[{timestamp()}] [PASS] Done. {files_copied} file(s) copied.")

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error parsing or copying: {e}")


    if user_input.lower().startswith("ptdios "):
        # Beispielbefehl:
        # ptdios from="Internal Storage\DCIM\100APPLE" to="C:\Ziel"

        try:
            # Extrahiere die Pfade, basierend auf der Anordnung von Anführungszeichen
            parts = user_input[7:].split('"')  # 6 statt 8, weil 'ptdios ' nur 6 Zeichen sind
            source = parts[1]
            destination = parts[3]

            print(f"{main_color}[*]{reset} Source: {source}")
            print(f"{main_color}[*]{reset} Target: {destination}")

            copy_files_from_iphone(source, destination)

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error parsing command: {e}")

    if user_input.lower().startswith("ptdandroid "):
        try:
            # Entferne den Befehlsteil "ptdandroid " und analysiere den Rest
            command_args = user_input[10:].strip()

            # Beispiel: ptdandroid from="Internal Storage/DCIM/Camera" to="/storage/emulated/0/Download"
            if 'from="' in command_args and 'to="' in command_args:
                parts = command_args.split('"')
                source = parts[1]
                destination = parts[3]

                if source and destination:
                    print(f"{main_color}[*]{reset} Source: {source}")
                    print(f"{main_color}[*]{reset} Target: {destination}")

                    # Funktion zum Kopieren definieren – komplett innerhalb der if-Schleife!
                    def copy_files_from_android(src, dst):
                        try:
                            if not os.path.exists(src):
                                print(f"[{timestamp()}] [ERROR] Source path does not exist: {src}")
                                return
                            if not os.path.exists(dst):
                                os.makedirs(dst)

                            file_count = 0
                            for root, dirs, files in os.walk(src):
                                for file in files:
                                    source_file = os.path.join(root, file)
                                    relative_path = os.path.relpath(root, src)
                                    destination_folder = os.path.join(dst, relative_path)

                                    if not os.path.exists(destination_folder):
                                        os.makedirs(destination_folder)

                                    shutil.copy2(source_file, os.path.join(destination_folder, file))
                                    file_count += 1

                            print(f"[{timestamp()}] [INFO] {file_count} Files copied successfully.")
                        except Exception as e:
                            print(f"[{timestamp()}] [ERROR] Error while copying: {e}")

                    # Funktionsaufruf
                    copy_files_from_android(source, destination)

                else:
                    print(f"[{timestamp()}] [ERROR] Paths cannot be empty.")
            else:
                print(f'[{timestamp()}] [ERROR]Incorrect format. Use: ptdandroid from=\"<source>\" to=\"<destination>\"')

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error processing command: {e}")

    if user_input.lower() in ["dir", "ls"]:
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        run_command("dir" if os.name == "nt" else "ls -la", shell=True)
        return True

    if user_input.lower() in ["pdir", "pls"]:
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        run_command("dir" if os.name == "nt" else "ls -la", shell=True)
        return True

    if user_input.lower() in ["dir-2", "ls-2"]:
        command = "powershell ls"

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        try:
            run_command(command, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing ls command: {e}")
        return True

    if user_input.lower() in ["pdir-2", "pls-2"]:
        command = "powershell ls"

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        try:
            run_command(command, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing ls command: {e}")
        return True

    if user_input.lower() in ["dir-3", "ls-3"]:
        command = "wsl ls"

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        try:
            run_command(command, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing ls command: {e}")
        return True

    if user_input.lower() in ["pdir-3", "pls-3"]:
        command = "wsl ls"

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        try:
            run_command(command, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing ls command: {e}")
        return True

    if user_input.lower() in ["dir-4", "ls-4"]:
        command = ["pwsh", "-Command", "ls"]

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        try:
            run_command(command, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing ls command: {e}")
        return True

    if user_input.lower() in ["pdir-4", "pls-4"]:
        command = ["pwsh", "-Command", "ls"]

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        try:
            run_command(command, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing ls command: {e}")
        return True

    if user_input.startswith("mkdir "):
        os.makedirs(user_input[6:].strip(), exist_ok=True)
        return True

    if user_input.startswith("pmkdir "):
            os.makedirs(user_input[7:].strip(), exist_ok=True)
            return True

    if user_input.startswith("rmdir "):
        try:
            os.rmdir(user_input[6:].strip())
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {str(e)}", file=sys.stderr)
        return True

    if user_input.startswith("prmdir "):
        try:
            os.rmdir(user_input[7:].strip())
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {str(e)}", file=sys.stderr)
        return True

    if user_input.startswith("del "):
        target = user_input[4:].strip()
        delete_target(target)
        return True

    if user_input.startswith("pdel "):
        target = user_input[5:].strip()
        delete_target(target)
        return True

    if user_input.startswith("rm "):
        target = user_input[3:].strip()
        delete_target(target)
        return True

    if user_input.startswith("rm-r "):
        target = user_input[5:].strip()
        try:
            os.remove(target)
            print(f"File '{target}' was deleted.")
        except FileNotFoundError:
            print(f"[{timestamp()}] [ERROR] File '{target}' does not exist.")
        except PermissionError:
            print(f"[{timestamp()}] [ERROR] Permission denied when deleting file '{target}'.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error deleting file: {e}")
        return True

    if user_input.startswith("prm "):
        target = user_input[4:].strip()
        delete_target(target)
        return True

    if user_input.startswith("echo "):
        print(user_input[5:].strip())
        return True

    if user_input.startswith("pecho "):
        print(user_input[6:].strip())
        return True

    """
    if "=" in user_input:
        var, value = map(str.strip, user_input.split("=", 1))
        os.environ[var] = value
        print(f"{main_color}Environment variable set{reset}: {var}={value}")
        return True
    """

    if user_input.startswith(("type ", "cat ")):
        try:
            with open(user_input.split(maxsplit=1)[1].strip(), "r", encoding="utf-8") as f:
                print(f.read())
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {str(e)}", file=sys.stderr)
        return True

    if user_input.startswith(("ptype ", "pcat ")):
        try:
            # Extrahiere den Dateinamen nach dem Befehl
            filename = user_input.split(maxsplit=1)[1].strip()
            with open(filename, "r", encoding="utf-8") as f:
                print(f.read())
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {str(e)}", file=sys.stderr)
        return True

    if user_input.lower() == "exit":
        print(f"[{timestamp()}] [INFO] {yellow}Exiting PP-Terminal... Goodbye {user_name}!{reset}")
        sys.exit(0)

    if user_input.lower() == "pp-exit":
        print(f"[{timestamp()}] [INFO] {yellow}Exiting PP-Terminal... Goodbye {user_name}!{reset}")
        sys.stdout.flush()  # WICHTIG: Alle Ausgaben sicher beenden
        sys.exit(0)

    if user_input.lower() == "shutdown":
        print(f"[{timestamp()}] [INFO] {yellow}Exiting PP-Terminal... Goodbye {user_name}!{reset}")
        sys.exit(0)

    if user_input.lower() == "pp-shutdown":
        print(f"[{timestamp()}] [INFO] {yellow}Exiting PP-Terminal... Goodbye {user_name}!{reset}")
        sys.stdout.flush()  # WICHTIG: Alle Ausgaben sicher beenden
        sys.exit(0)

    if user_input.lower() == "restart":
        print(f"[{timestamp()}] [INFO] {yellow}Restarting PP-Terminal... Buckle up, {user_name}!{reset}")
        os.execl(sys.executable, sys.executable, *sys.argv)

    if user_input.lower() == "pp-restart":
        print(f"[{timestamp()}] [INFO] {yellow}Restarting PP-Terminal... Buckle up, {user_name}!{reset}")
        sys.stdout.flush()  # Wichtig: Ausgabe sicherstellen
        time.sleep(0.5)  # Kurze Pause, damit Text sichtbar bleibt

        try:
            os.execl(sys.executable, sys.executable, *sys.argv)

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {yellow}Failed to restart: {e}{reset}")
            sys.exit(1)

    if user_input.lower() == "restart-os":
        print(f"[{timestamp()}] [INFO] {yellow}System reboot initiated... Hold tight, {user_name}!{reset}")
        system = platform.system()
        if system == "Windows":
            os.system("shutdown /r /t 0")
        elif system in ["Linux", "Darwin"]:  # Darwin = macOS
            os.system("sudo reboot")
        else:
            print(f"[{timestamp()}] [INFO] {yellow}Unsupported OS for restart: {system}{reset}")

    if user_input.lower() == "pp-restart-os":
        print(f"[{timestamp()}] [INFO] {yellow}System reboot initiated... Hold tight, {user_name}!{reset}")
        sys.stdout.flush()
        time.sleep(1)

        system = platform.system()

        try:
            if system == "Windows":
                os.system("shutdown /r /t 0")
            elif system == "Linux":
                print(
                    f"[{timestamp()}] [INFO] {yellow}Rebooting Linux system... You may need to enter your sudo password.{reset}")
                os.system("sudo reboot")
            elif system == "Darwin":  # macOS
                print(
                    f"[{timestamp()}] [INFO] {yellow}Rebooting macOS... You may need to enter your sudo password.{reset}")
                os.system("sudo shutdown -r now")
            else:
                print(f"[{timestamp()}] [INFO] {yellow}Unsupported OS for restart: {system}{reset}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {yellow}Error attempting OS restart: {e}{reset}")
            sys.exit(1)

    if user_input.lower() == "shutdown-os":
        print(
            f"[{timestamp()}] [INFO] {yellow}Shutting down the operating system... Goodbye forever, {user_name} 🕊️{reset}")
        system = platform.system()
        if system == "Windows":
            os.system("shutdown /s /t 0")
        elif system in ["Linux", "Darwin"]:
            os.system("sudo shutdown now")
        else:
            print(f"[{timestamp()}] [INFO] {yellow}Unsupported OS for shutdown: {system}{reset}")

    if user_input.lower() == "pp-shutdown-os":
        print(f"[{timestamp()}] [INFO] {yellow}FORTH-style TERMINATION... No turning back now, {user_name}!{reset}")

        # ACHTUNG: Dieser Befehl fährt das Betriebssystem wirklich herunter!
        if os.name == 'nt':  # Windows
            os.system("shutdown /s /t 0")
        elif os.name == 'posix':  # Linux / macOS
            os.system("sudo shutdown -h now")
        else:
            print(f"[{timestamp()}] [ERROR] Unknown operating system – shutdown not possible.")

        sys.exit(42)

    if user_input.startswith("pg "):
        user_input = user_input[3:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"git {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.startswith("pgc "):
        user_input = user_input[4:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"git clone {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "git ls":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"git log --oneline --graph --color --all --decorate"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "pg ls":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"git log --oneline --graph --color --all --decorate"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "git ls all":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"git log --graph --all --color --decorate --pretty=format:'%C(yellow)%h%Creset - %Cgreen%ad%Creset - %s %C(red)[%an]%Creset' --date=short"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "pg ls all":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"git log --graph --all --color --decorate --pretty=format:'%C(yellow)%h%Creset - %Cgreen%ad%Creset - %s %C(red)[%an]%Creset' --date=short"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "git pretty":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"git log --pretty=format:'%Cred%h%Creset - %Cgreen%cd%Creset - %s %C(bold blue)<%an>%Creset' --date=short"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "pg pretty":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"git log --pretty=format:'%Cred%h%Creset - %Cgreen%cd%Creset - %s %C(bold blue)<%an>%Creset' --date=short"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "git tig":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"tig"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "pg tig":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"tig"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "git lazy":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"lazygit"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "pg lazy":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"lazygit"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "git ls hole":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = "gitk --all"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "pg ls hole":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = "gitk --all"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "git status":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = "git status -sb"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "pg status":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = "git status -sb"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "git diff":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = "git diff --color-word"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "pg diff":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = "git diff --color-word"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "git branches":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = "git branch -vv -a"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "pg branches":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = "git branch -vv -a"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "git stash":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = "git stash list --pretty=format:'%C(yellow)%gd%Creset %Cgreen%cr%Creset %s %C(red)[%an]'"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.lower() == "pg stash":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = "git stash list --pretty=format:'%C(yellow)%gd%Creset %Cgreen%cr%Creset %s %C(red)[%an]'"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Git command: {e}")
        return True

    if user_input.startswith("pco "):
        user_input = user_input[4:].strip()

        # Load JSON
        json_path = Path(f"C:/Users/{getpass.getuser()}/p-terminal/pp-term/current_env.json")

        try:
            with open(json_path, 'r') as file:
                data = json.load(file)
                active = data.get("active_env")

            if not active:
                print(f"[{timestamp()}] [ERROR] Key 'active_env' not found in JSON.")
                return True

            active_env_path = Path(active)
            python_exe = active_env_path / "Scripts" / "python.exe"
            conda_bat = active_env_path / "condabin" / "conda.bat"
            conda_meta = active_env_path / "conda-meta"

            if not python_exe.exists():
                print(f"[{timestamp()}] [ERROR] Python executable not found in active environment.")
                return True

            # Check if it's a Conda environment (two checks)
            is_conda = conda_bat.exists() or conda_meta.exists()

            if not is_conda:
                print(f"[{timestamp()}] [ERROR] Active environment is not a Conda environment.")
                return True

            # Build and run the Conda command
            command = f'"{conda_bat}" {user_input}'
            # print(f"[{timestamp()}] [INFO] Running: conda {user_input}")

            subprocess.run(command, shell=True)

        except FileNotFoundError:
            print(f"[{timestamp()}] [ERROR] File not found: {json_path}")
        except json.JSONDecodeError:
            print(f"[{timestamp()}] [ERROR] Error decoding JSON file: {json_path}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Unexpected error: {str(e)}")

        return True

    if user_input.startswith("pcoi "):  # pcoi = install
        user_input = "install " + user_input[5:].strip()

        # Load JSON
        json_path = Path(f"C:/Users/{getpass.getuser()}/p-terminal/pp-term/current_env.json")

        try:
            with open(json_path, 'r') as file:
                data = json.load(file)
                active = data.get("active_env")

            if not active:
                print(f"[{timestamp()}] [ERROR] Key 'active_env' not found in JSON.")
                # hier ggf. return oder weiter
                # return True

            active_env_path = Path(active)
            python_exe = active_env_path / "Scripts" / "python.exe"
            conda_bat = active_env_path / "condabin" / "conda.bat"
            conda_meta = active_env_path / "conda-meta"

            if not python_exe.exists():
                print(f"[{timestamp()}] [ERROR] Python executable not found in active environment.")
                # return True

            is_conda = conda_bat.exists() or conda_meta.exists()

            if not is_conda:
                print(f"[{timestamp()}] [ERROR] Active environment is not a Conda environment.")
                # return True

            command = f'"{conda_bat}" {user_input}'
            # print(f"[{timestamp()}] [INFO] Running: conda {user_input}")

            subprocess.run(command, shell=True)

        except FileNotFoundError:
            print(f"[{timestamp()}] [ERROR] File not found: {json_path}")
        except json.JSONDecodeError:
            print(f"[{timestamp()}] [ERROR] Error decoding JSON file: {json_path}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Unexpected error: {str(e)}")

        return True

    if user_input.startswith("pcou "):  # pcou = update
        user_input = "update " + user_input[5:].strip()

        # Load JSON
        json_path = Path(f"C:/Users/{getpass.getuser()}/p-terminal/pp-term/current_env.json")

        try:
            with open(json_path, 'r') as file:
                data = json.load(file)
                active = data.get("active_env")

            if not active:
                print(f"[{timestamp()}] [ERROR] Key 'active_env' not found in JSON.")
                # return True

            active_env_path = Path(active)
            python_exe = active_env_path / "Scripts" / "python.exe"
            conda_bat = active_env_path / "condabin" / "conda.bat"
            conda_meta = active_env_path / "conda-meta"

            if not python_exe.exists():
                print(f"[{timestamp()}] [ERROR] Python executable not found in active environment.")
                # return True

            is_conda = conda_bat.exists() or conda_meta.exists()

            if not is_conda:
                print(f"[{timestamp()}] [ERROR] Active environment is not a Conda environment.")
                # return True

            command = f'"{conda_bat}" {user_input}'
            # print(f"[{timestamp()}] [INFO] Running: conda {user_input}")

            subprocess.run(command, shell=True)

        except FileNotFoundError:
            print(f"[{timestamp()}] [ERROR] File not found: {json_path}")
        except json.JSONDecodeError:
            print(f"[{timestamp()}] [ERROR] Error decoding JSON file: {json_path}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Unexpected error: {str(e)}")

        return True

    if user_input.startswith("pcor "):  # pcor = remove
        user_input = "remove " + user_input[5:].strip()

        json_path = Path(f"C:/Users/{getpass.getuser()}/p-terminal/pp-term/current_env.json")

        try:
            with open(json_path, 'r') as file:
                data = json.load(file)
                active = data.get("active_env")

            if not active:
                print(f"[{timestamp()}] [ERROR] Key 'active_env' not found in JSON.")
                return True

            active_env_path = Path(active)
            python_exe = active_env_path / "Scripts" / "python.exe"
            conda_bat = active_env_path / "condabin" / "conda.bat"
            conda_meta = active_env_path / "conda-meta"

            if not python_exe.exists():
                print(f"[{timestamp()}] [ERROR] Python executable not found in active environment.")
                return True

            is_conda = conda_bat.exists() or conda_meta.exists()

            if not is_conda:
                print(f"[{timestamp()}] [ERROR] Active environment is not a Conda environment.")
                return True

            command = f'"{conda_bat}" {user_input}'
            subprocess.run(command, shell=True)

        except FileNotFoundError:
            print(f"[{timestamp()}] [ERROR] File not found: {json_path}")
        except json.JSONDecodeError:
            print(f"[{timestamp()}] [ERROR] Error decoding JSON file: {json_path}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Unexpected error: {str(e)}")

        return True

    if user_input.startswith("pcol "):  # pcol = list
        user_input = "list " + user_input[5:].strip()

        json_path = Path(f"C:/Users/{getpass.getuser()}/p-terminal/pp-term/current_env.json")

        try:
            with open(json_path, 'r') as file:
                data = json.load(file)
                active = data.get("active_env")

            if not active:
                print(f"[{timestamp()}] [ERROR] Key 'active_env' not found in JSON.")
                return True

            active_env_path = Path(active)
            python_exe = active_env_path / "Scripts" / "python.exe"
            conda_bat = active_env_path / "condabin" / "conda.bat"
            conda_meta = active_env_path / "conda-meta"

            if not python_exe.exists():
                print(f"[{timestamp()}] [ERROR] Python executable not found in active environment.")
                return True

            is_conda = conda_bat.exists() or conda_meta.exists()

            if not is_conda:
                print(f"[{timestamp()}] [ERROR] Active environment is not a Conda environment.")
                return True

            command = f'"{conda_bat}" {user_input}'
            subprocess.run(command, shell=True)

        except FileNotFoundError:
            print(f"[{timestamp()}] [ERROR] File not found: {json_path}")
        except json.JSONDecodeError:
            print(f"[{timestamp()}] [ERROR] Error decoding JSON file: {json_path}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Unexpected error: {str(e)}")

        return True

    if user_input.startswith("pcoh "):  # pcoh = help/info
        # Hier als Beispiel führen wir 'conda info' aus, oder du kannst eigene Hilfe anzeigen
        user_input = "info " + user_input[5:].strip()

        json_path = Path(f"C:/Users/{getpass.getuser()}/p-terminal/pp-term/current_env.json")

        try:
            with open(json_path, 'r') as file:
                data = json.load(file)
                active = data.get("active_env")

            if not active:
                print(f"[{timestamp()}] [ERROR] Key 'active_env' not found in JSON.")
                return True

            active_env_path = Path(active)
            python_exe = active_env_path / "Scripts" / "python.exe"
            conda_bat = active_env_path / "condabin" / "conda.bat"
            conda_meta = active_env_path / "conda-meta"

            if not python_exe.exists():
                print(f"[{timestamp()}] [ERROR] Python executable not found in active environment.")
                return True

            is_conda = conda_bat.exists() or conda_meta.exists()

            if not is_conda:
                print(f"[{timestamp()}] [ERROR] Active environment is not a Conda environment.")
                return True

            command = f'"{conda_bat}" {user_input}'
            subprocess.run(command, shell=True)

        except FileNotFoundError:
            print(f"[{timestamp()}] [ERROR] File not found: {json_path}")
        except json.JSONDecodeError:
            print(f"[{timestamp()}] [ERROR] Error decoding JSON file: {json_path}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Unexpected error: {str(e)}")

        return True

    if user_input.startswith("pcoav "):  # pcoav = activate
        env_name = user_input[6:].strip()
        current_dir = Path.cwd()  # Oder ein spezieller Pfad, falls nötig
        env_path = (current_dir / env_name).resolve()

        def set_active_conda_env_in_json(env_path_str: str):
            json_path = Path(f"C:/Users/{getpass.getuser()}/p-terminal/pp-term/current_env.json")
            data = {}
            if json_path.exists():
                try:
                    with open(json_path, "r") as f:
                        data = json.load(f)
                except json.JSONDecodeError:
                    print(f"[{timestamp()}] [ERROR] JSON could not be loaded. Overwrite...")

            data["active_env"] = env_path_str
            try:
                with open(json_path, "w") as f:
                    json.dump(data, f, indent=4)
                print(f"[{timestamp()}] [INFO] Active Environment saved in JSON: {env_path_str}")
            except Exception as e:
                print(f"[{timestamp()}] [ERROR] Failed to save JSON: {e}")

        if not env_path.exists():
            print(f"[{timestamp()}] [INFO] Environment '{env_name}' does not exist under '{env_path}'.")
            user_confirm = input("Do you want to create this virtual environment? [y/n]: ").strip().lower()
            if user_confirm == 'y':
                command = ["python", "-m", "venv", str(env_path)]
                try:
                    subprocess.run(command, check=True, text=True,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=False)
                    print(f"[{timestamp()}] [INFO] The venv '{env_name}' was created under {env_path}.")
                except subprocess.CalledProcessError as e:
                    print(f"[{timestamp()}] [ERROR] Error creating the venv: {e}")
            else:
                print(f"[{timestamp()}] [INFO] Activation canceled.")
                # return True

        if os.name == "nt":
            python_exe = env_path / "Scripts" / "python.exe"
        else:
            python_exe = env_path / "bin" / "python"

        if not python_exe.exists():
            print(f"[{timestamp()}] [INFO] No Python interpreter found in '{python_exe}'.")
            user_confirm = input("Activate anyway? [y/n]: ").strip().lower()
            if user_confirm != 'y':
                print(f"[{timestamp()}] [INFO] Activation canceled.")
                # return True

        active = find_active_env(env_path)
        set_active_conda_env_in_json(active)

        print(f"[{timestamp()}] [INFO] Active environment set on '{active}'.")
        return True

    if user_input.startswith("pp-pcoav "):  # pcoav = activate
            env_name = user_input[9:].strip()
            current_dir = Path.cwd()  # Oder ein spezieller Pfad, falls nötig
            env_path = (current_dir / env_name).resolve()

            def set_active_conda_env_in_json(env_path_str: str):
                json_path = Path(f"C:/Users/{getpass.getuser()}/p-terminal/pp-term/current_env.json")
                data = {}
                if json_path.exists():
                    try:
                        with open(json_path, "r") as f:
                            data = json.load(f)
                    except json.JSONDecodeError:
                        print(f"[{timestamp()}] [ERROR] JSON could not be loaded. Overwrite...")

                data["active_env"] = env_path_str
                try:
                    with open(json_path, "w") as f:
                        json.dump(data, f, indent=4)
                    print(f"[{timestamp()}] [INFO] Active Environment saved in JSON: {env_path_str}")
                except Exception as e:
                    print(f"[{timestamp()}] [ERROR] Failed to save JSON: {e}")

            if not env_path.exists():
                print(f"[{timestamp()}] [INFO] Environment '{env_name}' does not exist under '{env_path}'.")
                user_confirm = input("Do you want to create this virtual environment? [y/n]: ").strip().lower()
                if user_confirm == 'y':
                    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                    command = f'python -m venv "{env_path}"'
                    try:
                        subprocess.run(command, shell=True, check=True, text=True,
                                       stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)
                        print(f"[{timestamp()}] [INFO] The venv '{env_name}' was created under {env_path}.")
                    except subprocess.CalledProcessError as e:
                        print(f"[{timestamp()}] [ERROR] Error creating the venv: {e}")
                else:
                    print(f"[{timestamp()}] [INFO] Activation canceled.")
                    # return True

            if os.name == "nt":
                python_exe = env_path / "Scripts" / "python.exe"
            else:
                python_exe = env_path / "bin" / "python"

            if not python_exe.exists():
                print(f"[{timestamp()}] [INFO] No Python interpreter found in '{python_exe}'.")
                user_confirm = input("Activate anyway? [y/n]: ").strip().lower()
                if user_confirm != 'y':
                    print(f"[{timestamp()}] [INFO] Activation canceled.")
                    # return True

            active = find_active_env(env_path)
            set_active_conda_env_in_json(active)

            print(f"[{timestamp()}] [INFO] Active environment set on '{active}'.")
            return True

    if user_input.startswith("pcodv "):  # pcodv = deactivate
        # Normalerweise braucht deactivate keinen Env-Namen, aber falls übergeben:
        env_name = user_input[6:].strip()

        def set_active_conda_env_in_json(env_path_str):
            json_path = Path(f"C:/Users/{getpass.getuser()}/p-terminal/pp-term/current_env.json")
            data = {}
            if json_path.exists():
                try:
                    with open(json_path, "r") as f:
                        data = json.load(f)
                except json.JSONDecodeError:
                    print(f"[{timestamp()}] [ERROR] JSON konnte nicht geladen werden. Überschreibe...")

            # Für deactivate setzen wir active_env auf None oder leeren String
            data["active_env"] = None
            try:
                with open(json_path, "w") as f:
                    json.dump(data, f, indent=4)
                print(f"[{timestamp()}] [INFO] Environment deaktiviert, active_env auf None gesetzt.")
            except Exception as e:
                print(f"[{timestamp()}] [ERROR] JSON konnte nicht gespeichert werden: {e}")

        # Deaktivieren heißt hier nur den aktiven Env-Eintrag löschen/setzen
        set_active_conda_env_in_json(None)

        print(f"[{timestamp()}] [INFO] Environment wurde deaktiviert.")
        return True

    if user_input.startswith("pcos "):  # pcos = search packages
        user_input = "search " + user_input[5:].strip()

        json_path = Path(f"C:/Users/{getpass.getuser()}/p-terminal/pp-term/current_env.json")

        try:
            with open(json_path, 'r') as file:
                data = json.load(file)
                active = data.get("active_env")

            if not active:
                print(f"[{timestamp()}] [ERROR] Key 'active_env' not found in JSON.")
                # return True

            active_env_path = Path(active)
            python_exe = active_env_path / "Scripts" / "python.exe"
            conda_bat = active_env_path / "condabin" / "conda.bat"
            conda_meta = active_env_path / "conda-meta"

            if not python_exe.exists():
                print(f"[{timestamp()}] [ERROR] Python executable not found in active environment.")
                # return True

            is_conda = conda_bat.exists() or conda_meta.exists()

            if not is_conda:
                print(f"[{timestamp()}] [ERROR] Active environment is not a Conda environment.")
                # return True

            command = f'"{conda_bat}" {user_input}'
            # print(f"[{timestamp()}] [INFO] Running: conda {user_input}")

            subprocess.run(command, shell=True)

        except FileNotFoundError:
            print(f"[{timestamp()}] [ERROR] File not found: {json_path}")
        except json.JSONDecodeError:
            print(f"[{timestamp()}] [ERROR] Error decoding JSON file: {json_path}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Unexpected error: {str(e)}")

        return True


    if user_input.startswith("pcoc "):  # pcoc = clean cache
        user_input = "clean " + user_input[5:].strip()

        json_path = Path(f"C:/Users/{getpass.getuser()}/p-terminal/pp-term/current_env.json")

        try:
            with open(json_path, 'r') as file:
                data = json.load(file)
                active = data.get("active_env")

            if not active:
                print(f"[{timestamp()}] [ERROR] Key 'active_env' not found in JSON.")
                # return True

            active_env_path = Path(active)
            python_exe = active_env_path / "Scripts" / "python.exe"
            conda_bat = active_env_path / "condabin" / "conda.bat"
            conda_meta = active_env_path / "conda-meta"

            if not python_exe.exists():
                print(f"[{timestamp()}] [ERROR] Python executable not found in active environment.")
                # return True

            is_conda = conda_bat.exists() or conda_meta.exists()

            if not is_conda:
                print(f"[{timestamp()}] [ERROR] Active environment is not a Conda environment.")
                # return True

            command = f'"{conda_bat}" {user_input}'
            # print(f"[{timestamp()}] [INFO] Running: conda {user_input}")

            subprocess.run(command, shell=True)

        except FileNotFoundError:
            print(f"[{timestamp()}] [ERROR] File not found: {json_path}")
        except json.JSONDecodeError:
            print(f"[{timestamp()}] [ERROR] Error decoding JSON file: {json_path}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Unexpected error: {str(e)}")

        return True

    if user_input.startswith("pol "):
        user_input = user_input[4:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ollama {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Ollama command: {e}")
        return True

    if user_input.startswith("pol-run "):
        model_name = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ollama run {model_name}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Ollama command: {e}")
        return True

    if user_input.startswith("pol-pull "):
        model_name = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ollama pull {model_name}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Ollama command: {e}")
        return True

    if user_input.startswith("pol-show "):
        model_name = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ollama show {model_name}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Ollama command: {e}")
        return True

    if user_input.startswith("pol-list"):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = "ollama list"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Ollama command: {e}")
        return True

    if user_input.startswith("pol-ps"):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = "ollama ps"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Ollama command: {e}")
        return True

    if user_input.startswith("pol-stop "):
        model_name = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ollama stop {model_name}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Ollama command: {e}")
        return True

    if user_input.startswith("pol-rm "):
        model_name = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ollama rm {model_name}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing Ollama command: {e}")
        return True

    if user_input.lower() == "cloc .":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc ."

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "ls count":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc ."

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "pls count":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc ."

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "ls count1":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc ."

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "pls count1":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc ."

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "cloc *":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc *"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "ls count-2":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc *"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "pls count-2":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc *"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("cloc --exclude-dir="):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("ls count-dir="):
        user_input = user_input[13:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc --exclude-dir={user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("cloc --include-lang="):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("ls count-lang="):
        user_input = user_input[14:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc --include-lang={user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "cloc --by-file":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc --by-file"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "ls count-3":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc --by-file"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "cloc --csv":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc --csv"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "ls count-4":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc --csv"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "cloc --json":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc --json"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "ls count-5":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc --json"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "cloc --quiet":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc --quiet"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "ls count --quiet":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc --quiet"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "cloc --help":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc --help"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "ls count --help":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc --help"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "cloc --versions":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc --versions"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "ls count --versions":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl cloc --versions"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "disk usage":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl du -sh ."

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "tree-2":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl tree -L 2"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "find py":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl find . -name '*.py'"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("grep "):
        user_input = user_input[5:]
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl grep -rnw . -e '{user_input}'"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "lint":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl pylint ."

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "make":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl make"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "format":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl black ."

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "top":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl top"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower() == "disk":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl df -h"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("sudo "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("nano "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("emacs-lx "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl emacs {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("pemacs-lx "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl emacs {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("pemacs "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"emacs {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("vim-lx "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl vim {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("pvim-lx "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl vim {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("pvim "):
        user_input = user_input[5:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"vim {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("nvim-lx "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl nvim {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("pnvim-lx "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl nvim {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("nvim "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        try:
            run_command(user_input, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("pnvim "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"nvim {user_input}"

        try:
            run_command(command, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("micro "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("githubdesktop "):
        repo_path = user_input[14:].strip()

        if not os.path.isdir(repo_path):
            print(f"[{timestamp()}] [ERROR] The path '{repo_path}' is not a valid folder.")
            return False

        if not os.path.isdir(os.path.join(repo_path, ".git")):
            print(f"[{timestamp()}] [ERROR] The folder '{repo_path}' is not a Git repository (no .git folder found).")
            return False

        print(f"[{timestamp()}] [INFO] Opening Git repository '{repo_path}' with GitHub Desktop...")

        command = f'github desktop "{repo_path}"'

        try:
            process = subprocess.Popen(command, shell=True, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, text=True)
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error running GitHub Desktop: {e}")

        return True

    if user_input.startswith("ghd "):
        repo_path = user_input[4:].strip()

        if not os.path.isdir(repo_path):
            print(f"[{timestamp()}] [ERROR] The path '{repo_path}' is not a valid folder.")
            return False

        if not os.path.isdir(os.path.join(repo_path, ".git")):
            print(f"[{timestamp()}] [ERROR] The folder '{repo_path}' is not a Git repository (no .git folder found).")
            return False

        print(f"[{timestamp()}] [INFO] Opening Git repository '{repo_path}' with GitHub Desktop...")

        command = f'github desktop "{repo_path}"'

        try:
            process = subprocess.Popen(command, shell=True, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, text=True)
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error running GitHub Desktop: {e}")

        return True

    if user_input.startswith("code-lx "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl code {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("pcode-lx "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl code {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("pcode "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"code {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("thonny-lx "):
        user_input = user_input[10:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl thonny {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("pthonny-lx "):
        user_input = user_input[11:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl thonny {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("thonny "):
        user_input = user_input[7:].strip()
        # Script is not executed, so we ignore user_input

        json_path = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/current_env.json")
        if not json_path.exists():
            print(f"[{timestamp()}] [ERROR] current_env.json not found: {json_path}")
            return True

        try:
            with open(json_path, "r", encoding="utf-8") as f:
                data = json.load(f)
                venv_path = data.get("active_env")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error reading current_env.json: {e}")
            return True

        if not venv_path:
            print(f"[{timestamp()}] [ERROR] No virtual environment path found in current_env.json.")
            return True

        python_executable = Path(venv_path) / "Scripts" / "python.exe"
        if not python_executable.exists():
            print(f"[{timestamp()}] [ERROR] Python interpreter not found: {python_executable}")
            return True

        thonny_exe = Path(f"C:/Users/{os.getlogin()}/AppData/Local/Programs/Thonny/thonny.exe")
        if not thonny_exe.exists():
            print(f"[{timestamp()}] [ERROR] thonny.exe not found: {thonny_exe}")
            return True

        try:
            config_dir = Path(os.getenv("APPDATA")) / "Thonny"
            config_path = config_dir / "configuration.ini"
            config = configparser.ConfigParser()

            if config_path.exists():
                config.read(config_path, encoding='utf-8')
            else:
                if not config_dir.exists():
                    config_dir.mkdir(parents=True)
                config['Interpreter'] = {}

            if 'Interpreter' not in config:
                config['Interpreter'] = {}

            config['Interpreter']['executable'] = str(python_executable)

            with open(config_path, 'w', encoding='utf-8') as f:
                config.write(f)

            print(f"[{timestamp()}] [INFO] Thonny configuration updated: Interpreter={python_executable}")

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error updating Thonny configuration: {e}")
            return True

        try:
            subprocess.Popen([str(thonny_exe)])
            print(f"[{timestamp()}] [INFO] Thonny started.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Thonny could not be started: {e}")
            return True

        return True

    if user_input.startswith("pthonny "):
        user_input = user_input[8:].strip()
        # Script is not executed, so we ignore user_input

        json_path = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/current_env.json")
        if not json_path.exists():
            print(f"[{timestamp()}] [ERROR] current_env.json not found: {json_path}")
            return True

        try:
            with open(json_path, "r", encoding="utf-8") as f:
                data = json.load(f)
                venv_path = data.get("active_env")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error reading current_env.json: {e}")
            return True

        if not venv_path:
            print(f"[{timestamp()}] [ERROR] No virtual environment path found in current_env.json.")
            return True

        python_executable = Path(venv_path) / "Scripts" / "python.exe"
        if not python_executable.exists():
            print(f"[{timestamp()}] [ERROR] Python interpreter not found: {python_executable}")
            return True

        thonny_exe = Path(f"C:/Users/{os.getlogin()}/AppData/Local/Programs/Thonny/thonny.exe")
        if not thonny_exe.exists():
            print(f"[{timestamp()}] [ERROR] thonny.exe not found: {thonny_exe}")
            return True

        try:
            config_dir = Path(os.getenv("APPDATA")) / "Thonny"
            config_path = config_dir / "configuration.ini"
            config = configparser.ConfigParser()

            if config_path.exists():
                config.read(config_path, encoding='utf-8')
            else:
                if not config_dir.exists():
                    config_dir.mkdir(parents=True)
                config['Interpreter'] = {}

            if 'Interpreter' not in config:
                config['Interpreter'] = {}

            config['Interpreter']['executable'] = str(python_executable)

            with open(config_path, 'w', encoding='utf-8') as f:
                config.write(f)

            print(f"[{timestamp()}] [INFO] Thonny configuration updated: Interpreter={python_executable}")

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error updating Thonny configuration: {e}")
            return True

        try:
            subprocess.Popen([str(thonny_exe)])
            print(f"[{timestamp()}] [INFO] Thonny started.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Thonny could not be started: {e}")
            return True

        return True

    if user_input.startswith("thonny-pip "):

        if user_input.lower() == "thonny-pip q" or user_input == "thonny-pip \x11":  # 'q' oder Ctrl+Q zum Beenden
            print(f"[{timestamp()}] [INFO] Terminated by exit command")
            shutdown_thonny()
        else:
            try:
                file_input = user_input[11:].strip()

                # Dateiendung korrigieren
                if file_input.endswith(".jup") or file_input.endswith(".pj"):
                    file_input = file_input.rsplit(".", 1)[0] + ".py"
                elif not file_input.endswith(".py"):
                    file_input += ".py"

                file_path = Path(file_input).resolve()
                file_path.parent.mkdir(parents=True, exist_ok=True)

                # Neue Datei anlegen, wenn nicht vorhanden
                if not file_path.exists():
                    with open(file_path, "w", encoding="utf-8") as f:
                        f.write(f"# You have created a new Python file using the PP-Terminal. The PP-Terminal has given you the Python interpreter of your current .env to Thonny, you just have to activate it at the bottom right.\n")

                # active_env aus JSON laden
                json_path = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/current_env.json")
                if not json_path.exists():
                    print(f"[{timestamp()}] [ERROR] current_env.json not found at {json_path}")
                    shutdown_thonny()
                else:
                    with open(json_path, "r", encoding="utf-8") as f:
                        data = json.load(f)
                    active_env_path = data.get("active_env")

                    if not active_env_path:
                        print(f"[{timestamp()}] [ERROR] 'active_env' key missing in JSON.")
                        shutdown_thonny()
                    else:
                        active_env = Path(active_env_path)
                        python_exe = active_env / "Scripts" / "python.exe"

                        if not python_exe.exists():
                            print(f"[{timestamp()}] [ERROR] Python interpreter not found at {python_exe}")
                            shutdown_thonny()
                        else:
                            # Thonny settings.json im Benutzerprofil updaten
                            thonny_settings_dir = Path.home() / ".thonny"
                            thonny_settings_dir.mkdir(exist_ok=True)
                            settings_path = thonny_settings_dir / "settings.json"

                            if settings_path.exists():
                                with open(settings_path, "r", encoding="utf-8") as f:
                                    settings = json.load(f)
                            else:
                                settings = {}

                            settings["backend.executable"] = str(python_exe)

                            with open(settings_path, "w", encoding="utf-8") as f:
                                json.dump(settings, f, indent=4)

                            print(f"[{timestamp()}] [INFO] Updated Thonny settings.json backend.executable to {python_exe}")

                            # .env\.thonny\configuration.ini updaten
                            ini_path = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/.env/.thonny/configuration.ini")

                            if ini_path.exists():
                                config = configparser.ConfigParser()
                                config.optionxform = str  # Groß-/Kleinschreibung erhalten
                                config.read(ini_path, encoding="utf-8")

                                if 'LocalCPython' not in config.sections():
                                    config.add_section('LocalCPython')

                                # last_configurations als JSON-String speichern
                                last_configs_obj = [{
                                    "run.backend_name": "LocalCPython",
                                    "LocalCPython.executable": str(python_exe)
                                }]
                                val = json.dumps(last_configs_obj)

                                config['LocalCPython']['last_configurations'] = val

                                with open(ini_path, 'w', encoding='utf-8') as f:
                                    config.write(f)

                                print(f"[{timestamp()}] [INFO] Updated {ini_path} with last_configurations pointing to {python_exe}")
                            else:
                                print(f"[{timestamp()}] [WARNING] configuration.ini not found at {ini_path}, skipping update.")

                            # Thonny.exe im .env Ordner starten
                            fixed_thonny = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/.env/Scripts/thonny.exe")

                            if not fixed_thonny.exists():
                                print(f"[{timestamp()}] [ERROR] Thonny executable not found at {fixed_thonny}")
                                shutdown_thonny()
                            else:
                                print(f"[{timestamp()}] [INFO] Starting Thonny with file: {file_path}")
                                subprocess.Popen([str(fixed_thonny), str(file_path)], shell=True)

            except Exception as e:
                print(f"[{timestamp()}] [ERROR] An error occurred: {e}")
                shutdown_thonny()

        return True

    if user_input.startswith("prt "):

        if user_input.lower() == "prt q" or user_input == "prt \x11":  # 'q' oder Ctrl+Q zum Beenden
            print(f"[{timestamp()}] [INFO] Terminated by exit command")
            shutdown_thonny()
        else:
            try:
                file_input = user_input[4:].strip()

                # Dateiendung korrigieren
                if file_input.endswith(".jup") or file_input.endswith(".pj"):
                    file_input = file_input.rsplit(".", 1)[0] + ".py"
                elif not file_input.endswith(".py"):
                    file_input += ".py"

                file_path = Path(file_input).resolve()
                file_path.parent.mkdir(parents=True, exist_ok=True)

                # Neue Datei anlegen, wenn nicht vorhanden
                if not file_path.exists():
                    with open(file_path, "w", encoding="utf-8") as f:
                        f.write(f"# You have created a new Python file using the PP-Terminal. The PP-Terminal has given you the Python interpreter of your current .env to Thonny, you just have to activate it at the bottom right.\n")

                # active_env aus JSON laden
                json_path = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/current_env.json")
                if not json_path.exists():
                    print(f"[{timestamp()}] [ERROR] current_env.json not found at {json_path}")
                    shutdown_thonny()
                else:
                    with open(json_path, "r", encoding="utf-8") as f:
                        data = json.load(f)
                    active_env_path = data.get("active_env")

                    if not active_env_path:
                        print(f"[{timestamp()}] [ERROR] 'active_env' key missing in JSON.")
                        shutdown_thonny()
                    else:
                        active_env = Path(active_env_path)
                        python_exe = active_env / "Scripts" / "python.exe"

                        if not python_exe.exists():
                            print(f"[{timestamp()}] [ERROR] Python interpreter not found at {python_exe}")
                            shutdown_thonny()
                        else:
                            # Thonny settings.json im Benutzerprofil updaten
                            thonny_settings_dir = Path.home() / ".thonny"
                            thonny_settings_dir.mkdir(exist_ok=True)
                            settings_path = thonny_settings_dir / "settings.json"

                            if settings_path.exists():
                                with open(settings_path, "r", encoding="utf-8") as f:
                                    settings = json.load(f)
                            else:
                                settings = {}

                            settings["backend.executable"] = str(python_exe)

                            with open(settings_path, "w", encoding="utf-8") as f:
                                json.dump(settings, f, indent=4)

                            print(f"[{timestamp()}] [INFO] Updated Thonny settings.json backend.executable to {python_exe}")

                            # .env\.thonny\configuration.ini updaten
                            ini_path = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/.env/.thonny/configuration.ini")

                            if ini_path.exists():
                                config = configparser.ConfigParser()
                                config.optionxform = str  # Groß-/Kleinschreibung erhalten
                                config.read(ini_path, encoding="utf-8")

                                if 'LocalCPython' not in config.sections():
                                    config.add_section('LocalCPython')

                                # last_configurations als JSON-String speichern
                                last_configs_obj = [{
                                    "run.backend_name": "LocalCPython",
                                    "LocalCPython.executable": str(python_exe)
                                }]
                                val = json.dumps(last_configs_obj)

                                config['LocalCPython']['last_configurations'] = val

                                with open(ini_path, 'w', encoding='utf-8') as f:
                                    config.write(f)

                                print(f"[{timestamp()}] [INFO] Updated {ini_path} with last_configurations pointing to {python_exe}")
                            else:
                                print(f"[{timestamp()}] [WARNING] configuration.ini not found at {ini_path}, skipping update.")

                            # Thonny.exe im .env Ordner starten
                            fixed_thonny = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/.env/Scripts/thonny.exe")

                            if not fixed_thonny.exists():
                                print(f"[{timestamp()}] [ERROR] Thonny executable not found at {fixed_thonny}")
                                shutdown_thonny()
                            else:
                                print(f"[{timestamp()}] [INFO] Starting Thonny with file: {file_path}")
                                subprocess.Popen([str(fixed_thonny), str(file_path)], shell=True)

            except Exception as e:
                print(f"[{timestamp()}] [ERROR] An error occurred: {e}")
                shutdown_thonny()

        return True

    if user_input.startswith("gedit "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("kakoune "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("helix "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("jed "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("joe "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("mg "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("acme "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("geany "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("kate "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("ncdu "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("tldr "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("bat "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("exa "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("fzf "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("fd "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("tmux "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("entr "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("asdf "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("direnv "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("nmap "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("iperf3 "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("speedtest-cli "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("glow "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("ranger "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("zoxide "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("nala "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("espanso "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("plasma-workspace "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("syncthing "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("flatpak "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("mousepad "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("xed "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("atom-lx "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl atom {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.startswith("lite-xl "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"wsl {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error executing WSL command: {e}")
        return True

    if user_input.lower().startswith("g++ ") and " -o " in user_input:
        print(f"[{timestamp()}] [INFO] Compiling with g++...")
        command = f"wsl {user_input}"
        process = subprocess.Popen(command, shell=True)

        try:
            process.wait()
            print(f"[{timestamp()}] [INFO] Compilation finished.")

            # Name der Ausgabedatei extrahieren
            parts = shlex.split(user_input)
            if "-o" in parts:
                output_file = parts[parts.index("-o") + 1]
                print(f"[{timestamp()}] [INFO] Executing ./{output_file}...\n")
                subprocess.Popen(f"wsl ./{output_file}", shell=True).wait()
                print("")

        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    if user_input.lower().startswith("g++ -c "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl {user_input}"
        process = subprocess.Popen(
            command,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )
        try:
            print(f"[{timestamp()}] [INFO] Generating object file with g++ (-c)...\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during object file generation: {e}")
        return True

    if user_input.lower().startswith("g++ -e ") or user_input.startswith("g++ -E "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        # Interpret "-e" as shorthand for "-E" (preprocess)
        rest = user_input[6:].strip()
        command = f"wsl g++ -E {rest}"
        process = subprocess.Popen(
            command,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )
        try:
            print(f"[{timestamp()}] [INFO] Preprocessing {rest} (g++ -E)...\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during preprocessing: {e}")
        return True

    if user_input.lower().startswith("g++ -s ") or user_input.startswith("g++ -S "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        # Interpret "-s" (lowercase) as "-S" (uppercase) for assembly generation
        rest = user_input[6:].strip()
        command = f"wsl g++ -S {rest}"
        process = subprocess.Popen(
            command,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )
        try:
            print(f"[{timestamp()}] [INFO] Generating assembly with g++ (-S)...\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during assembly generation: {e}")
        return True

    if user_input.lower().startswith("g++ -std="):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl {user_input}"
        process = subprocess.Popen(
            command,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )
        try:
            print(f"[{timestamp()}] [INFO] Compiling with specified C++ standard...\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during C++ standard compilation: {e}")
        return True

    if user_input.lower().startswith("g++ -o") and " -o " not in user_input:
        print(f"[{timestamp()}] [WARNING] Incorrect format for g++ compilation.")
        print(f"[{timestamp()}] [INFO] Expected usage: g++ <flags> <source_file.cpp> -o <output_file>")
        print(f"[{timestamp()}] [HELP] Example: g++ -O2 main.cpp -o myprogram")
        print(f"[{timestamp()}] [EXPLANATION] The '-o' flag must be separated by spaces and placed correctly.")
        print(f"[{timestamp()}] [NOTE] You used: '{user_input}', which may be misformatted.")
        return True

    if user_input.lower().startswith("g++ -o2 ") or user_input.lower().startswith("g++ -o3 "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        # User might write "-o2" instead of "-O2". We'll normalize to uppercase O.
        rest = user_input[6:].strip()
        command = f"wsl g++ -O{rest}"
        process = subprocess.Popen(
            command,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )
        try:
            print(f"[{timestamp()}] [INFO] Compiling with optimization flag...\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during optimization compile: {e}")
        return True

    if user_input.lower().startswith("g++ -i ") or user_input.startswith("g++ -I "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        # Interpret "-i" as shorthand for "-I"
        rest = user_input[6:].strip()
        command = f"wsl g++ -I {rest}"
        process = subprocess.Popen(
            command,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )
        try:
            print(f"[{timestamp()}] [INFO] Compiling with include directory (-I)...\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during include-dir compile: {e}")
        return True

    if user_input.lower().startswith("g++ ") and "-l" in user_input:
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl {user_input}"
        process = subprocess.Popen(
            command,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )
        try:
            print(f"[{timestamp()}] [INFO] Compiling and linking with libraries...\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during library linking: {e}")
        return True

    if user_input.lower().startswith("g++ -wall ") or user_input.lower().startswith("g++ -wextra "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl {user_input}"
        process = subprocess.Popen(
            command,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )
        try:
            print(f"[{timestamp()}] [INFO] Compiling with warnings enabled...\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during warning-enabled compile: {e}")
        return True

    if user_input.lower().startswith("g++ -g "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl {user_input}"
        process = subprocess.Popen(
            command,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )
        try:
            print(f"[{timestamp()}] [INFO] Compiling with debug symbols (-g)...\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during debug compile: {e}")
        return True

    if user_input.lower().startswith("g++ -fpic ") or user_input.lower().startswith("g++ -shared "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl {user_input}"
        process = subprocess.Popen(
            command,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )
        try:
            print(f"[{timestamp()}] [INFO] Generating shared object / PIC code...\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during shared library compile: {e}")
        return True

    if user_input.lower().startswith("g++ run "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        exec_name = user_input[8:].strip()
        command = f"wsl ./{exec_name}"
        process = subprocess.Popen(
            command,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )
        try:
            print(f"[{timestamp()}] [INFO] Running {exec_name}...\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Execution cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during execution: {e}")
        return True

    if user_input.lower() in ("g++--version", "g++ --version"):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = "wsl g++ --version"
        process = subprocess.Popen(
            command,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )
        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error fetching version: {e}")
        return True

    if user_input.lower().startswith("g++ clean "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        target = user_input[12:].strip()
        command = f"wsl rm -f {target}"
        process = subprocess.Popen(
            command,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )
        try:
            print(f"[{timestamp()}] [INFO] Removing {target}...\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during cleanup: {e}")
        return True

        # 15. Display help for g++
        #     e.g., "g++ help"
    if user_input.startswith(("g++ help", "g++ -help", "g++ --help")):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = "wsl g++ --help"
        process = subprocess.Popen(
            command,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )
        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error displaying help: {e}")
        return True

    if user_input.lower().startswith("gcc ") and " -o " in user_input:
            print(f"[{timestamp()}] [INFO] Compiling with gcc...")
            command = f"wsl {user_input}"
            process = subprocess.Popen(command, shell=True)

            try:
                process.wait()
                print(f"[{timestamp()}] [INFO] Compilation finished.")

                # Name der Ausgabedatei extrahieren
                parts = shlex.split(user_input)
                if "-o" in parts:
                    output_file = parts[parts.index("-o") + 1]
                    print(f"[{timestamp()}] [INFO] Executing ./{output_file}...\n")
                    subprocess.Popen(f"wsl ./{output_file}", shell=True).wait()
                    print("")

            except KeyboardInterrupt:
                print(f"[{timestamp()}] [INFO] Compilation cancelled by user.")
            except subprocess.CalledProcessError as e:
                print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
            return True

    if user_input.startswith("gcc -o "):
        args = user_input[7:].strip()  # everything after "gcc -o "
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc -o {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Compiling with gcc and writing to output: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] gcc execution failed: {e}")
        return True

    if user_input.startswith("gcc -fsyntax-only "):
        args = user_input[len("gcc -fsyntax-only "):].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc -fsyntax-only {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Performing syntax-only check for: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Syntax check interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Syntax-only check failed: {e}")
        return True

    if user_input.startswith("gcc -g -o "):
        args = user_input[len("gcc -g -o "):].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc -g -o {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Compiling with debug symbols (-g) into: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Debug compilation interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Debug compilation failed: {e}")
        return True

    if user_input.startswith("gcc -c "):
        args = user_input[len("gcc -c "):].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc -c {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Compiling only (-c) for: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation-only step interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Compilation-only failed: {e}")
        return True

    if user_input.startswith("gcc -s ") or user_input.startswith("gcc -S "):
        args = user_input[len("gcc -S "):].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc -S {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Generating assembly (-S) for: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Assembly generation interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Assembly generation failed: {e}")
        return True

    if user_input.startswith("gcc -e ") or user_input.startswith("gcc -E "):
        args = user_input[len("gcc -E "):].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc -E {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Preprocessing only (-E) for: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Preprocessing interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Preprocessing failed: {e}")
        return True

    if user_input.startswith("gcc -std="):
        args = user_input[len("gcc "):].strip()  # keep everything after "gcc "
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Compiling with standard flag: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Standard-specific compilation interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Compilation with standard flag failed: {e}")
        return True

    if user_input.startswith("gcc -o ") or user_input.startswith("gcc -O "):
        args = user_input[len("gcc "):].strip()  # e.g. "-O2 main.c -o main"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Compiling with optimization: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Optimization compilation interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Optimization compilation failed: {e}")
        return True

    if user_input.startswith("gcc -l ") or user_input.startswith("gcc -L "):
        args = user_input[len("gcc "):].strip()  # e.g. "-lm -L/usr/local/lib main.o -o main"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Linking libraries: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Linking interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Linking failed: {e}")
        return True

    if user_input.startswith("gcc -shared "):
        args = user_input[len("gcc -shared "):].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc -shared {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Building shared object (-shared) for: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Shared-object build interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Shared-object build failed: {e}")
        return True

    if user_input.startswith("gcc -static "):
        args = user_input[len("gcc -static "):].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc -static {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Building static executable (-static) for: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Static build interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Static build failed: {e}")
        return True

    if user_input.startswith("gcc -fPIC "):
        args = user_input[len("gcc -fPIC "):].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc -fPIC {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Generating position-independent code (-fPIC) for: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] -fPIC generation interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] -fPIC generation failed: {e}")
        return True

    if user_input.startswith("gcc -Wall") or user_input.startswith("gcc -Wextra") or user_input.startswith(
            "gcc -pedantic"):
        args = user_input[len("gcc "):].strip()  # e.g. "-Wall -Wextra -pedantic main.c -o main"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Compiling with extra warning flags: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Warning-enabled compilation interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Warning-enabled compilation failed: {e}")
        return True

    if user_input.startswith("gcc -fsanitize="):
        args = user_input[len("gcc "):].strip()  # e.g. "-fsanitize=address main.c -o main"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Compiling with sanitizer: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Sanitizer compilation interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Sanitizer compilation failed: {e}")
        return True

    if user_input.lower().startswith("gcc --version") or user_input.lower().startswith("gcc -v "):
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = "wsl gcc --version"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Version check interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Version check failed: {e}")
        return True

    if user_input.startswith("gcc -v "):
        args = user_input[len("gcc -v "):].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc -v {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Compiling verbosely (-v) for: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Verbose compilation interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Verbose compilation failed: {e}")
        return True

    if user_input.startswith("gcc -print-search-dirs"):
        command = "wsl gcc -print-search-dirs"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Printing search directories for gcc\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Print-search-dirs interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Print-search-dirs failed: {e}")
        return True

    if user_input.startswith("gcc -dM"):
        args = user_input[len("gcc "):].strip()  # e.g. "-dM -E /dev/null"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Showing predefined macros for: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Macro dump interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Macro dump failed: {e}")
        return True

    if user_input.startswith("gcc -static-libgcc"):
        args = user_input[len("gcc "):].strip()  # e.g. "-static-libgcc main.c -o main"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Linking C runtime statically (-static-libgcc): {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Static runtime linking interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Static runtime linking failed: {e}")
        return True

    if user_input.startswith("gcc -fprof-gen") or user_input.startswith("gcc -fprofile-generate"):
        args = user_input[len("gcc "):].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc -fprofile-generate {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Compiling for PGO instrumentation: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] PGO instrumentation interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] PGO instrumentation failed: {e}")
        return True

    if user_input.startswith("gcc -fprof-use") or user_input.startswith("gcc -fprofile-use"):
        args = user_input[len("gcc "):].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc -fprofile-use {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Compiling with PGO data: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] PGO compilation interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] PGO compilation failed: {e}")
        return True

    if user_input.startswith("gcc -flto"):
        args = user_input[len("gcc "):].strip()  # e.g. "-flto main.c -o main"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc -flto {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Compiling with Link-Time Optimization (LTO): {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] LTO compilation interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] LTO compilation failed: {e}")
        return True

    if user_input.startswith("gcc -m32") or user_input.startswith("gcc -m64"):
        args = user_input[len("gcc "):].strip()  # e.g. "-m64 main.c -o main"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Compiling for architecture flag: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Architecture-specific compilation interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Architecture-specific compilation failed: {e}")
        return True

    if user_input.startswith("gcc -M") or user_input.startswith("gcc -MM"):
        args = user_input[len("gcc "):].strip()  # e.g. "-M main.c"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f"wsl gcc {args}"
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            print(f"[{timestamp()}] [INFO] Generating dependency info: {args}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Dependency generation interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Dependency generation failed: {e}")
        return True

    if user_input.startswith(("gcc help", "gcc -help", "gcc --help")):
        command = "wsl gcc --help"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        process = subprocess.Popen(command,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                   shell=True, text=True)
        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Help command interrupted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Help command failed: {e}")
        return True

    if user_input.startswith("gcc clean"):
        parts = user_input.split()
        if len(parts) >= 3:
            target_dir = parts[2]
            print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
            command = f"wsl rm -rf {target_dir}/*.o {target_dir}/*.d {target_dir}/*.gcda {target_dir}/*.gcno"
            process = subprocess.Popen(command,
                                       stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                       shell=True, text=True)
            try:
                print(f"[{timestamp()}] [INFO] Cleaning intermediate files in: {target_dir}\n")
                process.wait()
            except KeyboardInterrupt:
                print(f"[{timestamp()}] [INFO] Clean interrupted by user.")
            except subprocess.CalledProcessError as e:
                print(f"[{timestamp()}] [ERROR] Clean command failed: {e}")
        else:
            print(f"[{timestamp()}] [INFO] Usage: gcc clean <directory_path>")
        return True

    if user_input.startswith("gfortran ") and " -o " in user_input:
        command = f"wsl {user_input}"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        try:
            print(f"[{timestamp()}] [INFO] Compiling with gfortran...\n")
            process = subprocess.Popen(
                command,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                shell=True,
                text=True
            )
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    if user_input.startswith("gccgo ") and " -o " in user_input:
        command = f"wsl {user_input}"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        try:
            print(f"[{timestamp()}] [INFO] Compiling with gccgo...\n")
            process = subprocess.Popen(
                command,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                shell=True,
                text=True
            )
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    if user_input.startswith("gcj ") and " -o " in user_input:
        command = f"wsl {user_input}"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        try:
            print(f"[{timestamp()}] [INFO] Compiling with gcj...\n")
            process = subprocess.Popen(
                command,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                shell=True,
                text=True
            )
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    if user_input.startswith("gnat ") and " -o " in user_input:
        command = f"wsl {user_input}"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        try:
            print(f"[{timestamp()}] [INFO] Compiling with gnat...\n")
            process = subprocess.Popen(
                command,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                shell=True,
                text=True
            )
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    if user_input.startswith("gfortran ") and " -o " in user_input:
        command = f"wsl {user_input}"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        try:
            print(f"[{timestamp()}] [INFO] Compiling with gfortran...\n")
            process = subprocess.Popen(
                command,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                shell=True,
                text=True
            )
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    if user_input.startswith("gccgo ") and " -o " in user_input:
        command = f"wsl {user_input}"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        try:
            print(f"[{timestamp()}] [INFO] Compiling with gccgo...\n")
            process = subprocess.Popen(
                command,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                shell=True,
                text=True
            )
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    if user_input.startswith("gcj ") and " -o " in user_input:
        command = f"wsl {user_input}"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        try:
            print(f"[{timestamp()}] [INFO] Compiling with gcj...\n")
            process = subprocess.Popen(
                command,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                shell=True,
                text=True
            )
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    if user_input.startswith("gnat ") and " -o " in user_input:
        command = f"wsl {user_input}"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        try:
            print(f"[{timestamp()}] [INFO] Compiling with gnat...\n")
            process = subprocess.Popen(
                command,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                shell=True,
                text=True
            )
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    # Weitere bekannte GCC-Frontends (jeweils eigenes if)
    if user_input.startswith("objc ") and " -o " in user_input:
        command = f"wsl {user_input}"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        try:
            print(f"[{timestamp()}] [INFO] Compiling with objc...\n")
            process = subprocess.Popen(
                command,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                shell=True,
                text=True
            )
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    if user_input.startswith("objc++ ") and " -o " in user_input:
        command = f"wsl {user_input}"
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        try:
            print(f"[{timestamp()}] [INFO] Compiling with objc++...\n")
            process = subprocess.Popen(
                command,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                shell=True,
                text=True
            )
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    if user_input.startswith("gnatmake ") and " -o " in user_input:
        command = f"wsl {user_input}"
        try:
            print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
            print(f"[{timestamp()}] [INFO] Compiling with gnatmake...\n")
            process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    if user_input.startswith("gdc ") and " -o " in user_input:
        command = f"wsl {user_input}"
        try:
            print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
            print(f"[{timestamp()}] [INFO] Compiling with gdc (D compiler)...\n")
            process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    if user_input.startswith("gm2 ") and " -o " in user_input:
        command = f"wsl {user_input}"
        try:
            print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
            print(f"[{timestamp()}] [INFO] Compiling with gm2 (Modula-2)...\n")
            process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    if user_input.startswith("gpas ") and " -o " in user_input:
        command = f"wsl {user_input}"
        try:
            print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
            print(f"[{timestamp()}] [INFO] Compiling with gpas (GNU Pascal)...\n")
            process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    if user_input.startswith("gpc ") and " -o " in user_input:
        command = f"wsl {user_input}"
        try:
            print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
            print(f"[{timestamp()}] [INFO] Compiling with gpc (GNU Pascal Compiler)...\n")
            process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error during compilation: {e}")
        return True

    elif user_input.startswith("vs-cpp "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Compile {user_input} with Visual Studio Building Tools 2022\n")
        handle_vs_cpp_command(user_input)
        return True

    elif user_input.startswith("cppc "):
        user_input = user_input[5:].strip()
        print(f"[{timestamp()}] [INFO] Compile {user_input} with Visual Studio Building Tools 2022\n")
        handle_vs_cpp_command(user_input)
        return True

    elif user_input.startswith("pc-cpp "):
         user_input = user_input[7:].strip()
         print(f"[{timestamp()}] [INFO] Compile {user_input} with Visual Studio Building Tools 2022\n")
         handle_vs_cpp_command(user_input)
         return True

    elif user_input.startswith("prcpp "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Compile {user_input} with Visual Studio Building Tools 2022")
        handle_vs_cpp_command(user_input)
        # // EXE-Dateiname aus dem .cpp-Dateinamen ableiten
        exe_name = os.path.splitext(os.path.basename(user_input))[0] + ".exe"

        # // Prüfen, ob die EXE-Datei nach der Kompilierung existiert
        if os.path.exists(exe_name):
            print(f"[{timestamp()}] [INFO] Running compiled program: {exe_name}")
            print(f"[{timestamp()}] [INFO] Output {exe_name}:\n")
            subprocess.run(exe_name, shell=True)
            print("")
        else:
            print(f"[{timestamp()}] [ERROR] Executable {exe_name} not found after compilation.")
        return True

    if user_input.startswith("pd-cpp "):
        args = shlex.split(user_input[7:].strip())
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: source file and output file.")
            return False

        source_file, output_file = args

        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        vcvarsall_path = r'C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvarsall.bat'
        if not os.path.isfile(vcvarsall_path):
            print(f"[{timestamp()}] [ERROR] vcvarsall.bat not found at path: {vcvarsall_path}")
            return False

        compile_command = f'"{vcvarsall_path}" x64 && cl /Zi /Od /EHsc "{source_file}" /Fe:"{output_file}"'
        full_command = f'cmd /c "{compile_command}"'

        print(f"[{timestamp()}] [INFO] Starting compilation...")
        print(f"[{timestamp()}] [DEBUG] Running command: {full_command}")

        try:
            returncode = run_command(full_command, shell=True)

            if returncode == 0:
                print(f"[{timestamp()}] [SUCCESS] Compilation completed successfully.")
            else:
                print(f"[{timestamp()}] [ERROR] Compilation failed with return code {returncode}.")

        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [EXCEPTION] Subprocess error: {e}")
        except Exception as e:
            print(f"[{timestamp()}] [EXCEPTION] Unexpected error: {e}")

        return True

    if user_input.startswith("pd-cpp-gdb "):
        user_input = user_input[11:].strip()
        args = shlex.split(user_input)
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: source file and output file.")
            return False

        source_file, output_file = args
        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        # 1. Compile with -g for debug symbols
        compile_cmd = f"wsl g++ -g \"{source_file}\" -o \"{output_file}\""
        # 2. Start GDB
        debug_cmd = f"wsl gdb \"{output_file}\""

        print(f"[{timestamp()}] [INFO] Compiling with g++ -g ...")
        print(f"[{timestamp()}] [DEBUG] Running: {compile_cmd}")
        try:
            code_compile = run_command(compile_cmd, shell=True)
            if code_compile != 0:
                print(f"[{timestamp()}] [ERROR] Compilation failed with return code {code_compile}.")
                return True
            print(f"[{timestamp()}] [INFO] Starting GDB for '{output_file}' ...")
            run_command(debug_cmd, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Aborted by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error running pd-cpp-gdb: {e}")
        return True

    if user_input.startswith("pd-cpp-clang "):
        user_input = user_input[13:].strip()
        args = shlex.split(user_input)
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: source file and output file.")
            return False

        source_file, output_file = args
        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        # Clang with all warnings and debug symbols
        compile_cmd = f'wsl clang++ -Wall -Wextra -Wpedantic -g "{source_file}" -o "{output_file}"'
        print(f"[{timestamp()}] [INFO] Compiling with clang++ -Wall -Wextra -Wpedantic -g ...")
        print(f"[{timestamp()}] [DEBUG] Running: {compile_cmd}")
        try:
            code = run_command(compile_cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Clang compilation successful.")
            else:
                print(f"[{timestamp()}] [ERROR] Clang compilation failed with return code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Aborted by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error running pd-cpp-clang: {e}")
        return True

    if user_input.startswith("pd-cpp-asm "):
        user_input = user_input[11:].strip()
        args = shlex.split(user_input)
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: source file and output file (without .asm).")
            return False

        source_file, asm_file = args
        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        # MSVC: /Fa generates assembler code
        compile_cmd = msvc_env_cmd() + f'cl /nologo /c /Fa"{asm_file}.asm" "{source_file}"'
        print(f"[{timestamp()}] [INFO] Generating assembler output with cl /Fa ...")
        print(f"[{timestamp()}] [DEBUG] Running: {compile_cmd}")
        try:
            code = run_command(compile_cmd)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Assembler file '{asm_file}.asm' created.")
            else:
                print(f"[{timestamp()}] [ERROR] Assembler generation failed with return code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Aborted by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error in pd-cpp-asm: {e}")
        return True

    if user_input.startswith("pd-cpp-opt "):
        user_input = user_input[11:].strip()
        args = shlex.split(user_input)
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: source file and output file.")
            return False

        source_file, output_file = args
        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        # MSVC: /O2 for optimization, /Fe for output file
        compile_cmd = msvc_env_cmd() + f'cl /nologo /O2 "{source_file}" /Fe"{output_file}"'
        print(f"[{timestamp()}] [INFO] Compiling with cl /O2 (optimization for release) ...")
        print(f"[{timestamp()}] [DEBUG] Running: {compile_cmd}")
        try:
            code_compile = run_command(compile_cmd)
            if code_compile != 0:
                print(f"[{timestamp()}] [ERROR] Optimized compilation failed with return code {code_compile}.")
                return True
            print(f"[{timestamp()}] [INFO] Release binary created, showing file size ...")
            if is_windows():
                size_cmd = f'dir "{output_file}"'
            else:
                size_cmd = f'ls -lh "{output_file}"'
            run_command(size_cmd)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Aborted by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error in pd-cpp-opt: {e}")
        return True

    if user_input.startswith("pd-cpp-run "):
        user_input = user_input[11:].strip()
        binary = user_input
        if is_windows() and not binary.lower().endswith(".exe"):
            binary += ".exe"
        if not os.path.isfile(binary):
            print(f"[{timestamp()}] [ERROR] Executable '{binary}' not found.")
            return False
        run_cmd = f'"{binary}"'
        print(f"[{timestamp()}] [INFO] Starting executable '{binary}' ...")
        try:
            run_command(run_cmd)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Execution aborted by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error in pd-cpp-run: {e}")
        return True

    if user_input.startswith("pd-cpp-warnings "):
        user_input = user_input[15:].strip()
        args = shlex.split(user_input)
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: source file and output file.")
            return False

        source_file, output_file = args
        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        # MSVC warning flags: /W4 (all warnings), /WX (treat warnings as errors)
        compile_cmd = msvc_env_cmd() + f'cl /nologo /W4 /WX "{source_file}" /Fe"{output_file}"'
        print(f"[{timestamp()}] [INFO] Compiling with cl /W4 /WX (all warnings, errors on warning) ...")
        print(f"[{timestamp()}] [DEBUG] Running: {compile_cmd}")
        try:
            code = run_command(compile_cmd)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Compilation with all warnings successful.")
            else:
                print(f"[{timestamp()}] [ERROR] Compilation with warnings failed, return code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Aborted by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error in pd-cpp-warnings: {e}")
        return True

    if user_input.startswith("pd-cpp-std "):
        user_input = user_input[11:].strip()
        args = shlex.split(user_input)
        if len(args) != 3:
            print(f"[{timestamp()}] [ERROR] Please provide three arguments: source file, output file, and C++ standard (e.g., c++17).")
            return False

        source_file, output_file, std_flag = args
        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        # MSVC: /std:c++17 etc. (c++14/c++17/c++20/c++latest)
        compile_cmd = msvc_env_cmd() + f'cl /nologo /std:{std_flag} /W4 "{source_file}" /Fe"{output_file}"'
        print(f"[{timestamp()}] [INFO] Compiling with cl /std:{std_flag} /W4 ...")
        print(f"[{timestamp()}] [DEBUG] Running: {compile_cmd}")
        try:
            code = run_command(compile_cmd)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Compilation with C++ standard {std_flag} successful.")
            else:
                print(f"[{timestamp()}] [ERROR] Compilation with C++ standard {std_flag} failed, return code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Aborted by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error in pd-cpp-std: {e}")
        return True

    if user_input.lower() == "pd-cpp-clean":
        # Delete all .obj, .exe, .ilk, .pdb files
        clean_cmd_win = 'del /Q *.obj *.exe *.ilk *.pdb 2>nul'
        print(f"[{timestamp()}] [INFO] Removing compilation artifacts ...")
        try:
            run_command(clean_cmd_win)
            print(f"[{timestamp()}] [SUCCESS] Artifacts deleted.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error in pd-cpp-clean: {e}")
        return True

    if user_input.lower() == "pd-cpp-all":
        # Assumption: main.cpp exists, a.exe will be created
        cmd1 = 'del /Q *.obj a.exe 2>nul'
        cmd2 = msvc_env_cmd() + 'cl /nologo /Zi main.cpp /Fea.exe'
        cmd3 = 'a.exe'
        print(f"[{timestamp()}] [INFO] Running pd-cpp-all ...")
        try:
            run_command(cmd1)
            run_command(cmd2)
            print(f"[{timestamp()}] [INFO] Starting a.exe ...")
            run_command(cmd3)
            print(f"[{timestamp()}] [SUCCESS] pd-cpp-all completed.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Aborted by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error in pd-cpp-all: {e}")
        return True

    elif user_input.startswith("vs-c "):
        user_input = user_input[5:].strip()
        print(f"[{timestamp()}] [INFO] Compile {user_input} with Visual Studio Building Tools 2022\n")
        handle_vs_c_command(user_input)
        return True

    elif user_input.startswith("cc "):
        user_input = user_input[3:].strip()
        print(f"[{timestamp()}] [INFO] Compile {user_input} with Visual Studio Building Tools 2022\n")
        handle_vs_c_command(user_input)
        return True

    elif user_input.startswith("pc-c "):
        user_input = user_input[5:].strip()
        print(f"[{timestamp()}] [INFO] Compile {user_input} with Visual Studio Building Tools 2022\n")
        handle_vs_c_command(user_input)
        return True

    elif user_input.startswith("prc "):
        user_input = user_input[4:].strip()
        print(f"[{timestamp()}] [INFO] Compile {user_input} with Visual Studio Building Tools 2022")
        handle_vs_c_command(user_input)
        # // EXE-Dateiname aus dem .cpp-Dateinamen ableiten
        exe_name = os.path.splitext(os.path.basename(user_input))[0] + ".exe"

        # // Prüfen, ob die EXE-Datei nach der Kompilierung existiert
        if os.path.exists(exe_name):
            print(f"[{timestamp()}] [INFO] Running compiled program: {exe_name}")
            print(f"[{timestamp()}] [INFO] Output {exe_name}:\n")
            subprocess.run(exe_name, shell=True)
            print("")
        else:
            print(f"[{timestamp()}] [ERROR] Executable {exe_name} not found after compilation.")
        return True

    if user_input.startswith("pd-c "):
        args = shlex.split(user_input[5:].strip())
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: source file and output file.")
            return False

        source_file, output_file = args

        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        vcvarsall_path = r'C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvarsall.bat'
        if not os.path.isfile(vcvarsall_path):
            print(f"[{timestamp()}] [ERROR] vcvarsall.bat not found at path: {vcvarsall_path}")
            return False

        compile_command = f'"{vcvarsall_path}" x64 && cl /Zi /Od /EHsc "{source_file}" /Fe:"{output_file}"'
        full_command = f'cmd /c "{compile_command}"'

        print(f"[{timestamp()}] [INFO] Starting compilation...")
        print(f"[{timestamp()}] [DEBUG] Running command: {full_command}")

        try:
            returncode = run_command(full_command, shell=True)

            if returncode == 0:
                print(f"[{timestamp()}] [SUCCESS] Compilation completed successfully.")
            else:
                print(f"[{timestamp()}] [ERROR] Compilation failed with return code {returncode}.")

        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [EXCEPTION] Subprocess error: {e}")
        except Exception as e:
            print(f"[{timestamp()}] [EXCEPTION] Unexpected error: {e}")

        return True

    if user_input.startswith("pd-c-debug "):
        user_input = user_input[11:].strip()
        args = shlex.split(user_input)
        VCVARSALL = r"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvarsall.bat"
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: source file and output file.")
            return False

        source_file, output_file = args
        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        if not os.path.isfile(VCVARSALL):
            print(f"[{timestamp()}] [ERROR] vcvarsall.bat not found: {VCVARSALL}")
            return False

        # /Zi: debug info in PDB, /Z7: legacy format, /Od: no optimization
        compile_command = (
            f'"{VCVARSALL}" x64 && cl /Zi /Z7 /Od /TC "{source_file}" /Fe:"{output_file}"'
        )
        full_command = f'cmd /c "{compile_command}"'

        print(f"[{timestamp()}] [INFO] Starting extended debug compilation (pd-c-debug) ...")
        print(f"[{timestamp()}] [DEBUG] Running: {full_command}")
        try:
            code = run_command(full_command, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Debug build successful: '{output_file}' + PDB file.")
            else:
                print(f"[{timestamp()}] [ERROR] Debug build failed (return code {code}).")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation aborted by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [EXCEPTION] Subprocess error: {e}")
        return True

    if user_input.startswith("pd-c-release "):
        user_input = user_input[13:].strip()
        args = shlex.split(user_input)
        VCVARSALL = r"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvarsall.bat"

        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: source file and output file.")
            return False

        source_file, output_file = args
        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        if not os.path.isfile(VCVARSALL):
            print(f"[{timestamp()}] [ERROR] vcvarsall.bat not found: {VCVARSALL}")
            return False

        # /O2: maximum optimization, /DNDEBUG: disables assert, /TC: C mode
        compile_command = (
            f'"{VCVARSALL}" x64 && cl /O2 /DNDEBUG /TC "{source_file}" /Fe:"{output_file}"'
        )
        full_command = f'cmd /c "{compile_command}"'

        print(f"[{timestamp()}] [INFO] Starting release build (pd-c-release) ...")
        print(f"[{timestamp()}] [DEBUG] Running: {full_command}")
        try:
            code = run_command(full_command, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Release build successful: '{output_file}'.")
            else:
                print(f"[{timestamp()}] [ERROR] Release build failed (return code {code}).")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation aborted by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [EXCEPTION] Subprocess error: {e}")
        return True

    if user_input.startswith("pd-c-warnings "):
        user_input = user_input[14:].strip()
        args = shlex.split(user_input)
        VCVARSALL = r"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvarsall.bat"

        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: source file and output file.")
            return False

        source_file, output_file = args
        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        if not os.path.isfile(VCVARSALL):
            print(f"[{timestamp()}] [ERROR] vcvarsall.bat not found: {VCVARSALL}")
            return False

        # /W4: highest warning level, /WX: treat warnings as errors, /Zi: debug info
        compile_command = (
            f'"{VCVARSALL}" x64 && cl /W4 /WX /Zi /TC "{source_file}" /Fe:"{output_file}"'
        )
        full_command = f'cmd /c "{compile_command}"'

        print(f"[{timestamp()}] [INFO] Starting compilation with warnings as errors (pd-c-warnings) ...")
        print(f"[{timestamp()}] [DEBUG] Running: {full_command}")
        try:
            code = run_command(full_command, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Build with warnings successful: '{output_file}'.")
            else:
                print(f"[{timestamp()}] [ERROR] Build with warnings failed (return code {code}).")
            # Note: /WX aborts on any warning
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation aborted by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [EXCEPTION] Subprocess error: {e}")
        return True

    if user_input.startswith("pd-c-std "):
        user_input = user_input[9:].strip()
        args = shlex.split(user_input)
        VCVARSALL = r"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvarsall.bat"

        if len(args) != 3:
            print(f"[{timestamp()}] [ERROR] Please provide three arguments: source file, output file, and C standard (c11 or c17).")
            return False

        source_file, output_file, std_flag = args
        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        if std_flag.lower() not in ("c11", "c17"):
            print(f"[{timestamp()}] [ERROR] Invalid C standard: '{std_flag}'. Allowed: c11 or c17.")
            return False

        if not os.path.isfile(VCVARSALL):
            print(f"[{timestamp()}] [ERROR] vcvarsall.bat not found: {VCVARSALL}")
            return False

        # /std:c11 or /std:c17
        compile_command = (
            f'"{VCVARSALL}" x64 && cl /std:{std_flag} /W3 /TC "{source_file}" /Fe:"{output_file}"'
        )
        full_command = f'cmd /c "{compile_command}"'

        print(f"[{timestamp()}] [INFO] Compiling with C standard {std_flag} (pd-c-std) ...")
        print(f"[{timestamp()}] [DEBUG] Running: {full_command}")
        try:
            code = run_command(full_command, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Compilation with C standard {std_flag} successful: '{output_file}'.")
            else:
                print(f"[{timestamp()}] [ERROR] Compilation with C standard {std_flag} failed (return code {code}).")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation aborted by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error running pd-c-std: {e}")
        return True

    if user_input.startswith("pd-c-run "):
        user_input = user_input[9:].strip()
        executable = user_input
        if not os.path.isfile(executable):
            print(f"[{timestamp()}] [ERROR] Executable '{executable}' not found.")
            return False

        run_cmd = f'"{executable}"'
        print(f"[{timestamp()}] [INFO] Starting executable '{executable}' ...")
        try:
            run_command(run_cmd, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Execution aborted by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error running pd-c-run: {e}")
        return True

    if user_input.lower() == "pd-c-clean":
        user_input = user_input[9:].strip()  # not used
        # Delete all .obj, .exe, .pdb in current directory
        clean_cmd = 'del /Q *.obj *.exe *.pdb 2>nul'
        print(f"[{timestamp()}] [INFO] Removing MSVC build artifacts (pd-c-clean) ...")
        try:
            run_command(clean_cmd, shell=True)
            print(f"[{timestamp()}] [SUCCESS] Artifacts (.obj, .exe, .pdb) deleted.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error running pd-c-clean: {e}")
        return True

    if user_input.lower() == "pd-c-all":
        user_input = user_input[7:].strip()  # no further flags here
        # Assumption: main.c exists, output is main.exe
        source = "main.c"
        output = "main.exe"
        VCVARSALL = r"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvarsall.bat"

        if not os.path.isfile(source):
            print(f"[{timestamp()}] [ERROR] Source file '{source}' not found.")
            return True  # Abort, but True since command was recognized

        if not os.path.isfile(VCVARSALL):
            print(f"[{timestamp()}] [ERROR] vcvarsall.bat not found: {VCVARSALL}")
            return True

        cmd_clean = f'"{VCVARSALL}" x64 && del /Q *.obj *.exe *.pdb 2>nul'
        cmd_build = f'"{VCVARSALL}" x64 && cl /Zi /Od /TC "{source}" /Fe:"{output}"'
        cmd_run   = f'"{output}"'

        print(f"[{timestamp()}] [INFO] Running pd-c-all (MSVC): Clean, Build, Run ...")
        try:
            # 1. Clean
            print(f"[{timestamp()}] [INFO] Cleaning artifacts ...")
            run_command(cmd_clean, shell=True)

            # 2. Debug build
            print(f"[{timestamp()}] [INFO] Starting debug build '{source}' ...")
            ret = run_command(cmd_build, shell=True)
            if ret != 0:
                print(f"[{timestamp()}] [ERROR] Debug build failed (return code {ret}).")
                return True

            # 3. Run
            print(f"[{timestamp()}] [INFO] Starting '{output}' ...")
            run_command(cmd_run, shell=True)

            print(f"[{timestamp()}] [SUCCESS] pd-c-all completed successfully.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Aborted by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error running pd-c-all: {e}")
        return True

    elif user_input.startswith("vs-cs "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Compile {user_input} with Visual Studio Building Tools 2022\n")
        handle_vs_cs_command(user_input)
        return True

    elif user_input.startswith("csc "):
        user_input = user_input[4:].strip()
        print(f"[{timestamp()}] [INFO] Compile {user_input} with Visual Studio Building Tools 2022\n")
        handle_vs_cs_command(user_input)
        return True

    elif user_input.startswith("pc-cs "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Compile {user_input} with Visual Studio Building Tools 2022\n")
        handle_vs_cs_command(user_input)
        return True

    elif user_input.startswith("prcs "):
        user_input = user_input[5:].strip()
        print(f"[{timestamp()}] [INFO] Compile {user_input} with Visual Studio Building Tools 2022")
        handle_vs_cs_command(user_input)
        # // EXE-Dateiname aus dem .cpp-Dateinamen ableiten
        exe_name = os.path.splitext(os.path.basename(user_input))[0] + ".exe"

        # // Prüfen, ob die EXE-Datei nach der Kompilierung existiert
        if os.path.exists(exe_name):
            print(f"[{timestamp()}] [INFO] Running compiled program: {exe_name}")
            print(f"[{timestamp()}] [INFO] Output {exe_name}:\n")
            subprocess.run(exe_name, shell=True)
            print("")
        else:
            print(f"[{timestamp()}] [ERROR] Executable {exe_name} not found after compilation.")
        return True

    if user_input.startswith("pd-cs "):
        args = shlex.split(user_input[6:].strip())
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: source file and output file.")
            return False

        source_file, output_file = args

        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        # Finde den C#-Compiler (csc.exe)
        csc_paths = [
            r"C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe",  # 32-bit .NET Framework
            r"C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe",  # 64-bit
            r"C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin\Roslyn\csc.exe"
            # Roslyn (VS 2022)
        ]

        csc_path = next((p for p in csc_paths if os.path.isfile(p)), None)

        if not csc_path:
            print(f"[{timestamp()}] [ERROR] csc.exe not found. Please ensure .NET SDK or Visual Studio is installed.")
            return False

        compile_command = f'"{csc_path}" /debug /out:"{output_file}" "{source_file}"'
        print(f"[{timestamp()}] [INFO] Starting C# compilation...")
        print(f"[{timestamp()}] [DEBUG] Running command: {compile_command}")

        try:
            returncode = run_command(compile_command, shell=True)

            if returncode == 0:
                print(f"[{timestamp()}] [SUCCESS] Compilation completed successfully.")
            else:
                print(f"[{timestamp()}] [ERROR] Compilation failed with return code {returncode}.")

        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [EXCEPTION] Subprocess error: {e}")
        except Exception as e:
            print(f"[{timestamp()}] [EXCEPTION] Unexpected error: {e}")

        return True

    # Pfade zum C#-Compiler (csc.exe) prüfen
    CSC_PATHS = [
        r"C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe",               # 32-bit .NET Framework
        r"C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe",             # 64-bit .NET Framework
        r"C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin\Roslyn\csc.exe",  # Roslyn (VS 2022)
        r"C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin\csc.exe",         # VS 2022 allgemeiner Pfad
    ]

    def find_csc() -> str:
        """
        Durchsucht vordefinierte Pfade und gibt den ersten existierenden csc.exe-Pfad zurück.
        """
        for path in CSC_PATHS:
            if os.path.isfile(path):
                return path
        return None

    if user_input.startswith("pd-cs "):
        user_input = user_input[6:].strip()
        args = shlex.split(user_input)
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: source file and output file.")
            return False

        source_file, output_file = args
        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        csc_path = find_csc()
        if not csc_path:
            print(f"[{timestamp()}] [ERROR] csc.exe not found. Please ensure .NET SDK or Visual Studio is installed.")
            return False

        # /debug: PDB erzeugen; /optimize- deaktiviert Optimierung
        compile_command = f'"{csc_path}" /debug+ /optimize- /out:"{output_file}" "{source_file}"'
        print(f"[{timestamp()}] [INFO] Starting C# debug compilation (pd-cs)...")
        print(f"[{timestamp()}] [DEBUG] Running command: {compile_command}")

        try:
            returncode = run_command(compile_command, shell=True)
            if returncode == 0:
                print(f"[{timestamp()}] [SUCCESS] Compilation completed successfully: '{output_file}'.")
            else:
                print(f"[{timestamp()}] [ERROR] Compilation failed with return code {returncode}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [EXCEPTION] Subprocess error: {e}")
        except Exception as e:
            print(f"[{timestamp()}] [EXCEPTION] Unexpected error: {e}")
        return True

    if user_input.startswith("pd-cs-debug "):
        user_input = user_input[11:].strip()
        args = shlex.split(user_input)
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: source file and output file.")
            return False

        source_file, output_file = args
        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        csc_path = find_csc()
        if not csc_path:
            print(f"[{timestamp()}] [ERROR] csc.exe not found. Please ensure .NET SDK or Visual Studio is installed.")
            return False

        # /debug+: Debug-Symbole in PDB, /optimize-: keine Optimierung
        compile_command = f'"{csc_path}" /debug+ /optimize- /langversion:latest /out:"{output_file}" "{source_file}"'
        print(f"[{timestamp()}] [INFO] Starting C# enhanced debug compilation (pd-cs-debug)...")
        print(f"[{timestamp()}] [DEBUG] Running command: {compile_command}")

        try:
            returncode = run_command(compile_command, shell=True)
            if returncode == 0:
                print(f"[{timestamp()}] [SUCCESS] Debug build completed: '{output_file}' + PDB file.")
            else:
                print(f"[{timestamp()}] [ERROR] Debug build failed with return code {returncode}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [EXCEPTION] Subprocess error: {e}")
        return True

    if user_input.startswith("pd-cs-release "):
        user_input = user_input[15:].strip()
        args = shlex.split(user_input)
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: source file and output file.")
            return False

        source_file, output_file = args
        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        csc_path = find_csc()
        if not csc_path:
            print(f"[{timestamp()}] [ERROR] csc.exe not found. Please ensure .NET SDK or Visual Studio is installed.")
            return False

        # /optimize+: Aktiviert Optimierung, /define:RELEASE: Symbol für bedingte Kompilierung
        compile_command = f'"{csc_path}" /optimize+ /define:RELEASE /out:"{output_file}" "{source_file}"'
        print(f"[{timestamp()}] [INFO] Starting C# release build (pd-cs-release)...")
        print(f"[{timestamp()}] [DEBUG] Running command: {compile_command}")

        try:
            returncode = run_command(compile_command, shell=True)
            if returncode == 0:
                print(f"[{timestamp()}] [SUCCESS] Release build completed: '{output_file}'.")
            else:
                print(f"[{timestamp()}] [ERROR] Release build failed with return code {returncode}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [EXCEPTION] Subprocess error: {e}")
        return True

    if user_input.startswith("pd-cs-warnings "):
        user_input = user_input[15:].strip()
        args = shlex.split(user_input)
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: source file and output file.")
            return False

        source_file, output_file = args
        if not os.path.isfile(source_file):
            print(f"[{timestamp()}] [ERROR] Source file '{source_file}' not found.")
            return False

        csc_path = find_csc()
        if not csc_path:
            print(f"[{timestamp()}] [ERROR] csc.exe not found. Please ensure .NET SDK or Visual Studio is installed.")
            return False

        # /warn:4: höchste Warnungsstufe, /warnaserror+: behandelt alle Warnungen als Fehler
        compile_command = f'"{csc_path}" /warn:4 /warnaserror+ /out:"{output_file}" "{source_file}"'
        print(f"[{timestamp()}] [INFO] Starting C# compilation with warnings as errors (pd-cs-warnings)...")
        print(f"[{timestamp()}] [DEBUG] Running command: {compile_command}")

        try:
            returncode = run_command(compile_command, shell=True)
            if returncode == 0:
                print(f"[{timestamp()}] [SUCCESS] Build with warnings-as-errors succeeded: '{output_file}'.")
            else:
                print(f"[{timestamp()}] [ERROR] Build failed with return code {returncode}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [EXCEPTION] Subprocess error: {e}")
        return True

    if user_input.startswith("pd-cs-run "):
        user_input = user_input[11:].strip()
        executable = user_input
        if not os.path.isfile(executable):
            print(f"[{timestamp()}] [ERROR] Executable '{executable}' not found.")
            return False

        run_cmd = f'"{executable}"'
        print(f"[{timestamp()}] [INFO] Running executable '{executable}' (pd-cs-run)...")
        try:
            run_command(run_cmd, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Execution cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error running pd-cs-run: {e}")
        return True

    if user_input.lower() == "pd-cs-clean":
        user_input = user_input[11:].strip()  # nicht verwendet
        # Lösche alle Standard-Artefakte im aktuellen Verzeichnis
        clean_cmd = 'del /Q *.exe *.dll *.pdb *.xml 2>nul'
        print(f"[{timestamp()}] [INFO] Cleaning C# build artifacts (pd-cs-clean)...")
        try:
            run_command(clean_cmd, shell=True)
            print(f"[{timestamp()}] [SUCCESS] Artifacts deleted.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error running pd-cs-clean: {e}")
        return True

    if user_input.startswith("pd-cs-build-project "):
        user_input = user_input[21:].strip()
        args = shlex.split(user_input)
        if len(args) != 1:
            print(f"[{timestamp()}] [ERROR] Please provide exactly one argument: path to .csproj or .sln.")
            return False

        project_path = args[0]
        if not os.path.isfile(project_path):
            print(f"[{timestamp()}] [ERROR] Project file '{project_path}' not found.")
            return False

        # MSBuild via Developer Command Prompt aufrufen
        msbuild_path = r'C:\Program Files\Microsoft Visual Studio\2022\Community\Msbuild\Current\Bin\MSBuild.exe'
        if not os.path.isfile(msbuild_path):
            print(f"[{timestamp()}] [ERROR] MSBuild.exe not found: {msbuild_path}")
            return False

        # /p:Configuration=Release Bauen im Release-Modus; /m: paralleles Bauen
        build_cmd = f'"{msbuild_path}" "{project_path}" /t:Build /p:Configuration=Release /m'
        print(f"[{timestamp()}] [INFO] Building C# project with MSBuild (pd-cs-build-project)...")
        print(f"[{timestamp()}] [DEBUG] Running command: {build_cmd}")

        try:
            code = run_command(build_cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Project built successfully: '{project_path}'.")
            else:
                print(f"[{timestamp()}] [ERROR] MSBuild failed with return code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Build cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error running pd-cs-build-project: {e}")
        return True

    if user_input.startswith("pd-cs-run-project "):
        user_input = user_input[20:].strip()
        args = shlex.split(user_input)
        if len(args) != 1:
            print(f"[{timestamp()}] [ERROR] Please provide exactly one argument: path to project folder containing .csproj.")
            return False

        project_dir = args[0]
        csproj_files = [f for f in os.listdir(project_dir) if f.endswith(".csproj")]
        if not csproj_files:
            print(f"[{timestamp()}] [ERROR] No .csproj file found in directory '{project_dir}'.")
            return False

        # dotnet CLI verwenden
        run_cmd = f'dotnet run --project "{os.path.join(project_dir, csproj_files[0])}"'
        print(f"[{timestamp()}] [INFO] Running 'dotnet run' for project (pd-cs-run-project)...")
        print(f"[{timestamp()}] [DEBUG] Running command: {run_cmd}")

        try:
            run_command(run_cmd, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Execution cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error running pd-cs-run-project: {e}")
        return True

    if user_input.startswith("pd-cs-publish-project "):
        user_input = user_input[24:].strip()
        args = shlex.split(user_input)
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide two arguments: path to project folder and output folder for publish.")
            return False

        project_dir, publish_dir = args
        csproj_files = [f for f in os.listdir(project_dir) if f.endswith(".csproj")]
        if not csproj_files:
            print(f"[{timestamp()}] [ERROR] No .csproj file found in directory '{project_dir}'.")
            return False

        publish_cmd = f'dotnet publish "{os.path.join(project_dir, csproj_files[0])}" -c Release -o "{publish_dir}"'
        print(f"[{timestamp()}] [INFO] Publishing project (pd-cs-publish-project) to '{publish_dir}'...")
        print(f"[{timestamp()}] [DEBUG] Running command: {publish_cmd}")

        try:
            code = run_command(publish_cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Publish completed. Artifacts in: '{publish_dir}'.")
            else:
                print(f"[{timestamp()}] [ERROR] dotnet publish failed with return code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Publish cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error running pd-cs-publish-project: {e}")
        return True

    if user_input.startswith("pd-cs-test "):
        user_input = user_input[11:].strip()
        args = shlex.split(user_input)
        if len(args) != 1:
            print(f"[{timestamp()}] [ERROR] Please provide exactly one argument: path to solution or project to test.")
            return False

        test_path = args[0]
        if not os.path.exists(test_path):
            print(f"[{timestamp()}] [ERROR] Path '{test_path}' not found.")
            return False

        test_cmd = f'dotnet test "{test_path}" --configuration Release'
        print(f"[{timestamp()}] [INFO] Running 'dotnet test' (pd-cs-test) on '{test_path}'...")
        print(f"[{timestamp()}] [DEBUG] Running command: {test_cmd}")

        try:
            run_command(test_cmd, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Tests cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Error running pd-cs-test: {e}")
        return True

    if user_input.startswith("rustc "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"rustc {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with rustup\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-rust "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"rustc {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with rustup")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-rust "):
        user_input = user_input[8:].strip()

        command = f"rustc -Z unstable-options --error-format=long-span {user_input}"

        process = run_command(command, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Debug {user_input} with rustup\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-rust-check "):
        user_input = user_input[13:].strip()

        command = f"rustc --emit=metadata {user_input}"
        process = run_command(command, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Running pd-rust-check on {user_input}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pd-rust-check: {e}")
        return True

    if user_input.startswith("pd-rust-expand "):
        user_input = user_input[15:].strip()

        command = f"rustc +nightly -Z unstable-options -Z unpretty=expanded {user_input}"
        process = run_command(command, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Running pd-rust-expand (macro-expanded) on {user_input}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pd-rust-expand: {e}")
        return True

    if user_input.startswith("pd-rust-llvm-ir "):
        user_input = user_input[16:].strip()

        command = f"rustc +nightly --emit=llvm-ir {user_input}"
        process = run_command(command, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Running pd-rust-llvm-ir (emit LLVM IR) on {user_input}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pd-rust-llvm-ir: {e}")
        return True

    if user_input.startswith("pd-rust-asm "):
        user_input = user_input[13:].strip()

        command = f"rustc +nightly --emit=asm {user_input}"
        process = run_command(command, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Running pd-rust-asm (emit assembly) on {user_input}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pd-rust-asm: {e}")
        return True

    if user_input.startswith("pd-rust-gdb "):
        user_input = user_input[12:].strip()
        # Annahme: <source.rs> wird kompiliert und das Binary heißt a.out, oder man spezifiziert -o <binary>
        source = user_input.split()[0]
        output = "a.out"

        command_1 = f"rustc -g {source} -o {output}"
        command_2 = f"gdb {output}"

        process_1 = run_command(command_1, shell=True)
        process_2 = run_command(command_2, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Compiling {source} with debug symbols and launching GDB\n")
            process_1.wait()
            process_2.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pd-rust-gdb: {e}")
        return True

    if user_input.startswith("pd-rust-lldb "):
        user_input = user_input[13:].strip()
        source = user_input.split()[0]
        output = "a.out"

        command_1 = f"rustc -g {source} -o {output}"
        command_2 = f"lldb {output}"

        process_1 = run_command(command_1, shell=True)
        process_2 = run_command(command_2, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Compiling {source} with debug symbols and launching LLDB\n")
            process_1.wait()
            process_2.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pd-rust-lldb: {e}")
        return True

    if user_input.startswith("pd-rust-format-errors "):
        user_input = user_input[21:].strip()

        command = f"rustc --error-format=json {user_input}"
        process = run_command(command, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Running pd-rust-format-errors (JSON output) on {user_input}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pd-rust-format-errors: {e}")
        return True

    if user_input.startswith("pd-rust-unpretty-hir "):
        user_input = user_input[21:].strip()

        command = f"rustc +nightly -Z unstable-options -Z unpretty=hir {user_input}"
        process = run_command(command, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Running pd-rust-unpretty-hir (HIR dump) on {user_input}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pd-rust-unpretty-hir: {e}")
        return True

    if user_input.startswith("pd-rust-unpretty-trees "):
        user_input = user_input[23:].strip()

        command = f"rustc +nightly -Z unstable-options -Z unpretty=print-tree {user_input}"
        process = run_command(command, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Running pd-rust-unpretty-trees (AST tree) on {user_input}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pd-rust-unpretty-trees: {e}")
        return True

    if user_input.startswith("pd-rust-emit-deps "):
        user_input = user_input[18:].strip()

        command = f"rustc --emit=dep-info {user_input}"
        process = run_command(command, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Running pd-rust-emit-deps (dep-info) on {user_input}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pd-rust-emit-deps: {e}")
        return True

    if user_input.startswith("pd-rust-ast-json "):
        user_input = user_input[16:].strip()

        command = f"rustc +nightly -Z ast-json-output {user_input}"
        process = run_command(command, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Running pd-rust-ast-json (AST JSON) on {user_input}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pd-rust-ast-json: {e}")
        return True

    if user_input.startswith("pd-rust-emit-link "):
        user_input = user_input[18:].strip()

        command = f"rustc --emit=link {user_input}"
        process = run_command(command, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Running pd-rust-emit-link (link only) on {user_input}\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pd-rust-emit-link: {e}")
        return True

    if user_input.startswith("pd-rust-size "):
        user_input = user_input[14:].strip()
        source = user_input.split()[0]
        output = "a.out"

        command_1 = f"rustc -C opt-level=3 {source} -o {output}"
        command_2 = f"ls -lh {output}"

        process_1 = run_command(command_1, shell=True)
        process_2 = run_command(command_2, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Compiling {source} with -C opt-level=3 and showing size\n")
            process_1.wait()
            process_2.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pd-rust-size: {e}")
        return True

    if user_input.startswith("prr "):
        user_input = user_input[4:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # // Kompilierbefehl für rustc zusammenbauen
        command = f"rustc {user_input}"

        # // rustc-Prozess starten
        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with rustc")
            process.wait()

            # // Wenn Kompilierung erfolgreich, führe das erstellte Programm aus
            if process.returncode == 0:
                exe_file = os.path.splitext(user_input)[0]  # Dateiname ohne .rs
                if os.name == 'nt':
                    exe_file += ".exe"  # Windows-spezifisch
                print(f"[{timestamp()}] [INFO] Running compiled executable: {exe_file}")
                print(f"[{timestamp()}] [INFO] Output {exe_file}:\n")
                subprocess.run(exe_file, shell=True)
            else:
                print(f"[{timestamp()}] [ERROR] Compilation failed with exit code {process.returncode}")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Executing command failed: {e}")
        return True

    if user_input.startswith("p-cargo "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"cargo {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running cargo {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.lower() == "p-cargo-all":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. Code formatieren
        command_1 = f"cargo fmt"

        # 2. Linting mit Clippy
        command_2 = f"cargo clippy"

        # 3. Alte Build-Artefakte entfernen
        command_3 = f"cargo clean"

        # 4. Projekt kompilieren
        command_4 = f"cargo build"

        # 5. Tests ausführen
        command_5 = f"cargo test"

        # 6. Dokumentation erzeugen
        command_6 = f"cargo doc"

        # 7. Programm starten
        command_7 = f"cargo run"

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_2 = subprocess.Popen(command_2, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_3 = subprocess.Popen(command_3, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_4 = subprocess.Popen(command_4, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_5 = subprocess.Popen(command_5, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_6 = subprocess.Popen(command_6, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_7 = subprocess.Popen(command_7, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-all {user_input}")
            process_1.wait()
            process_2.wait()
            process_3.wait()
            process_4.wait()
            process_5.wait()
            process_6.wait()
            process_7.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.lower() == "p-cargo-debug":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. Projekt im Debug-Modus kompilieren
        command_1 = "cargo build"
        # 2. Unter GDB starten (Binary-Pfad: target/debug/<your_binary_name>)
        #    Hier <your_binary_name> anpassen oder per Umgebungsvariable übergeben.
        command_2 = "rust-gdb target/debug/<your_binary_name>"

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_2 = subprocess.Popen(command_2, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-debug {user_input}")
            process_1.wait()
            process_2.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.lower() == "p-cargo-release":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. Alte Release-Artefakte löschen
        command_1 = "cargo clean --release"
        # 2. Release-Build
        command_2 = "cargo build --release"
        # 3. Tests im Release-Modus (manchmal schneller, je nach Test-Setup)
        command_3 = "cargo test --release"
        # 4. Programm unter Release starten
        command_4 = "cargo run --release"

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_2 = subprocess.Popen(command_2, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_3 = subprocess.Popen(command_3, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_4 = subprocess.Popen(command_4, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-release {user_input}")
            process_1.wait()
            process_2.wait()
            process_3.wait()
            process_4.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.lower() == "p-cargo-update-all":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. Alle Abhängigkeiten in Cargo.lock aktualisieren
        command_1 = "cargo update"
        # 2. Projekt kompilieren, um zu prüfen, ob alles noch buildet
        command_2 = "cargo build"
        # 3. Optional: Tests ausführen, um sicherzustellen, dass die neuen Versionen keine Fehler erzeugen
        command_3 = "cargo test"

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_2 = subprocess.Popen(command_2, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_3 = subprocess.Popen(command_3, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-update-all {user_input}")
            process_1.wait()
            process_2.wait()
            process_3.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.lower() == "p-cargo-format-lint":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. Rust-Code formatieren
        command_1 = "cargo fmt"
        # 2. Linting mit Clippy
        command_2 = "cargo clippy -- -D warnings"  # Alle Warnungen als Fehler behandeln

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_2 = subprocess.Popen(command_2, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-format-lint {user_input}")
            process_1.wait()
            process_2.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.lower() == "p-cargo-publish-all":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. Release build
        command_1 = "cargo build --release"
        # 2. Tests im Release-Modus
        command_2 = "cargo test --release"
        # 3. Dokumentation erzeugen und öffnen
        command_3 = "cargo doc --open"
        # 4. Crate veröffentlichen (erfordert gültiges CARGO_TOKEN)
        command_4 = "cargo publish"

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_2 = subprocess.Popen(command_2, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_3 = subprocess.Popen(command_3, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_4 = subprocess.Popen(command_4, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-publish-all {user_input}")
            process_1.wait()
            process_2.wait()
            process_3.wait()
            process_4.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.lower() == "p-cargo-doc-clean":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. Alte Dokumentation löschen (manuell das Verzeichnis löschen)
        command_1 = "rm -rf target/doc"
        # 2. Neue Dokumentation erzeugen
        command_2 = "cargo doc"
        # 3. Dokumentation im Browser öffnen
        command_3 = "cargo doc --open"

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_2 = subprocess.Popen(command_2, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_3 = subprocess.Popen(command_3, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-doc-clean {user_input}")
            process_1.wait()
            process_2.wait()
            process_3.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.lower() == "p-cargo-deps-tree":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. cargo-tree ausführen (falls nicht installiert: cargo install cargo-tree)
        command_1 = "cargo tree"

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-deps-tree {user_input}")
            process_1.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.lower() == "p-cargo-clean-target":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. cargo clean ohne Release-Flag (löscht Debug- und Release-Artefakte)
        command_1 = "cargo clean"

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-clean-target {user_input}")
            process_1.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.lower() == "p-cargo-install-tools":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. cargo-edit installieren (für cargo add, remove, upgrade)
        command_1 = "cargo install cargo-edit"
        # 2. cargo-outdated installieren (zeigt veraltete Abhängigkeiten)
        command_2 = "cargo install cargo-outdated"
        # 3. cargo-audit installieren (Sicherheits-Scans)
        command_3 = "cargo install cargo-audit"

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_2 = subprocess.Popen(command_2, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)
        process_3 = subprocess.Popen(command_3, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                     text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-install-tools {user_input}")
            process_1.wait()
            process_2.wait()
            process_3.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.lower() == "p-cargo-bench":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. Benchmarks starten
        command_1 = "cargo bench"

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                     shell=True, text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-bench {user_input}")
            process_1.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing p-cargo-bench: {e}")
        return True

    if user_input.lower() == "p-cargo-bench-run":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. Benchmarks starten
        command_1 = "cargo bench"
        # 2. Wenn Benchmarks durchgelaufen sind, Programm starten
        command_2 = "cargo run"

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                     shell=True, text=True)
        process_2 = subprocess.Popen(command_2, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                     shell=True, text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-bench-run {user_input}")
            process_1.wait()
            process_2.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing p-cargo-bench-run: {e}")
        return True

    if user_input.lower() == "p-cargo-coverage":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. cargo-tarpaulin installieren (falls nicht vorhanden)
        command_1 = "cargo install cargo-tarpaulin"
        # 2. Coverage-Analyse starten und Ergebnis als HTML generieren
        command_2 = "cargo tarpaulin --out Html"
        # 3. Öffnet den generierten Report im Standard-Browser (Linux/Mac/Windows)
        command_3 = "xdg-open tarpaulin-report.html || open tarpaulin-report.html || start tarpaulin-report.html"

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                     shell=True, text=True)
        process_2 = subprocess.Popen(command_2, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                     shell=True, text=True)
        process_3 = subprocess.Popen(command_3, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                     shell=True, text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-coverage {user_input}")
            process_1.wait()
            process_2.wait()
            process_3.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing p-cargo-coverage: {e}")
        return True

    if user_input.lower() == "p-cargo-cross-build":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. WebAssembly-Target hinzufügen (falls nicht installiert)
        command_1 = "rustup target add wasm32-unknown-unknown"
        # 2. Build für WebAssembly
        command_2 = "cargo build --target wasm32-unknown-unknown"
        # 3. Build für Linux x86_64
        command_3 = "cargo build --target x86_64-unknown-linux-gnu"

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                     shell=True, text=True)
        process_2 = subprocess.Popen(command_2, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                     shell=True, text=True)
        process_3 = subprocess.Popen(command_3, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                     shell=True, text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-cross-build {user_input}")
            process_1.wait()
            process_2.wait()
            process_3.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing p-cargo-cross-build: {e}")
        return True

    if user_input.lower() == "p-cargo-clippy-fix":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. Clippy im Fix-Modus starten (erlaubt Änderungen am Code)
        command_1 = "cargo clippy --fix --allow-dirty --allow-staged"

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                     shell=True, text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-clippy-fix {user_input}")
            process_1.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing p-cargo-clippy-fix: {e}")
        return True

    if user_input.lower() == "p-cargo-watch-test":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. cargo-watch installieren (falls nicht vorhanden)
        command_1 = "cargo install cargo-watch"
        # 2. Tests bei jeder Änderung automatisch ausführen
        command_2 = "cargo watch -x \"test\""

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                     shell=True, text=True)
        process_2 = subprocess.Popen(command_2, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                     shell=True, text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-watch-test {user_input}")
            process_1.wait()
            process_2.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing p-cargo-watch-test: {e}")
        return True

    if user_input.lower() == "p-cargo-watch-run":
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # 1. cargo-watch installieren (falls nicht vorhanden)
        command_1 = "cargo install cargo-watch"
        # 2. Binary bei jeder Änderung automatisch starten
        command_2 = "cargo watch -x \"run\""

        process_1 = subprocess.Popen(command_1, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                     shell=True, text=True)
        process_2 = subprocess.Popen(command_2, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                     shell=True, text=True)

        try:
            print(f"[{timestamp()}] [INFO] Running p-cargo-watch-run {user_input}")
            process_1.wait()
            process_2.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing p-cargo-watch-run: {e}")
        return True

    if user_input.startswith("node "):
        user_input = user_input[5:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"node {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with nodejs\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("jsc "):
        user_input = user_input[4:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"node {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with NodeJs\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-js "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"node {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with NodeJs\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("prjs "):
        filepath = user_input[5:].strip()
        filepath = os.path.abspath(filepath)
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        if not os.path.isfile(filepath):
            print(f"[{timestamp()}] [ERROR] File '{filepath}' not found.")
            return True

        _, ext = os.path.splitext(filepath)
        ext = ext.lower()
        filename = os.path.basename(filepath)
        directory = os.path.dirname(filepath)

        if ext == ".js":
            # Execute Node.js script
            command = f'node "{filepath}"'
            print(f"[{timestamp()}] [INFO] Executing JS with Node.js: {filename}")
            process = subprocess.Popen(
                command,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                shell=True,
                text=True
            )
            try:
                process.wait()
            except KeyboardInterrupt:
                print(f"[{timestamp()}] [INFO] Execution canceled by user.")
            except subprocess.CalledProcessError as e:
                print(f"[{timestamp()}] [ERROR] Execution failed: {e}")
            return True

        elif ext in [".html", ".htm"]:
            # Serve HTML+JS in browser
            requested_port = 8000
            port_container = {}
            server_started_event = threading.Event()

            server_thread = threading.Thread(
                target=start_local_server,
                args=(directory, requested_port, port_container, server_started_event),
                daemon=True
            )
            server_thread.start()

            # Wait up to 5s for server to start
            if not server_started_event.wait(timeout=5):
                print(f"[{timestamp()}] [ERROR] Server did not start within 5 seconds.")
                return True

            actual_port = port_container.get('port')
            url = f"http://localhost:{actual_port}/{filename}"

            print(f"[{timestamp()}] [INFO] Opening in browser: {url}")
            webbrowser.open(url)

            print(f"[{timestamp()}] [INFO] Server is running on port {actual_port}. Press 'q' (or Ctrl+Q) to stop.")

            # Wait for 'q' or Ctrl+Q
            try:
                while True:
                    user_cmd = input().strip()
                    if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                        print(f"[{timestamp()}] [INFO] Shutting down server...")
                        break
                    else:
                        print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
            except (KeyboardInterrupt, EOFError):
                print(f"\n[{timestamp()}] [INFO] Input interrupted. Shutting down server...")

            # Trigger a request to unblock server if it's idle
            try:
                urllib.request.urlopen(url, timeout=1)
            except:
                pass

            # Wait up to 5s for thread to finish
            server_thread.join(timeout=5)
            if server_thread.is_alive():
                print(f"[{timestamp()}] [INFO] Server thread did not terminate in time.")

            # Verify URL is offline
            max_retries = 5
            delay_between_checks = 1
            for _ in range(max_retries):
                try:
                    urllib.request.urlopen(url, timeout=1)
                    print(f"[{timestamp()}] [INFO] URL still reachable, waiting {delay_between_checks}s...")
                    time.sleep(delay_between_checks)
                except (urllib.error.URLError, ConnectionRefusedError):
                    print(f"[{timestamp()}] [INFO] URL is now offline.")
                    return True

            print(f"[{timestamp()}] [INFO] URL still reachable after retries. Returning True anyway.")
            return True

        else:
            print(f"[{timestamp()}] [INFO] Unsupported file extension: '{ext}'")
            return True

    if user_input.startswith("pd-node "):
        user_input = user_input[8:].strip()

        command = f"node inspect {user_input}"

        process = run_command(command, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Debug {user_input} with rustup\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("javac "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"javac {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Java - JDK\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-java "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"javac {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Java - JDK\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("prjava "):
        user_input = user_input[4:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"javac {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with javac")
            process.wait()

            # Wenn Kompilierung erfolgreich, führe die Java-Klasse mit `java` aus
            if process.returncode == 0:
                class_name = os.path.splitext(user_input)[0]  # Dateiname ohne Erweiterung (Klassenname)
                print(f"[{timestamp()}] [INFO] Running compiled Java class: {class_name}")
                print(f"[{timestamp()}] [INFO] Output {class_name}:\n")
                subprocess.run(f"java {class_name}", shell=True)
                print("")
            else:
                print(f"[{timestamp()}] [ERROR] Compilation failed with exit code {process.returncode}")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Executing command failed: {e}")
        return True

    if user_input.startswith("pd-java "):
        user_input = user_input[8:].strip()

        if user_input.endswith(".java"):
            user_input = user_input[:-5]

        command = f"javac -g {user_input}.java"
        command3 = f"java -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005 {user_input}"

        process = run_command(command, shell=True)
        process3 = run_command(command3, shell=True)

        try:
            print(f"[{timestamp()}] [INFO] Debug {user_input} with javac\n")
            process.wait()
            process3.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-java-run "):
        user_input = user_input[12:].strip()
        parts = shlex.split(user_input)
        if len(parts) < 1:
            print(f"[{timestamp()}] [ERROR] Please provide at least a class name to run.")
            return False

        class_name = parts[0][:-5] if parts[0].endswith(".java") else parts[0]
        java_file = f"{class_name}.java"
        args = parts[1:]

        if not os.path.isfile(java_file):
            print(f"[{timestamp()}] [ERROR] Source file '{java_file}' not found.")
            return False

        # Compile
        compile_cmd = f"javac \"{java_file}\""
        print(f"[{timestamp()}] [INFO] Compiling '{java_file}'...")
        code_compile = run_command(compile_cmd, shell=True)
        if code_compile != 0:
            print(f"[{timestamp()}] [ERROR] javac failed with return code {code_compile}.")
            return True

        # Run
        run_args = " ".join(f"\"{arg}\"" for arg in args)
        run_cmd = f"java {class_name} {run_args}"
        print(f"[{timestamp()}] [INFO] Running '{class_name}' with args: {args}")
        try:
            run_command(run_cmd, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Execution cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] pd-java-run failed: {e}")
        return True

    if user_input.startswith("pd-java-package "):
        user_input = user_input[16:].strip()
        args = shlex.split(user_input)
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: class name and output JAR file.")
            return False

        class_name, output_jar = args
        java_file = f"{class_name}.java"
        class_file = f"{class_name}.class"

        if not os.path.isfile(java_file):
            print(f"[{timestamp()}] [ERROR] Source file '{java_file}' not found.")
            return False

        # Compile
        compile_cmd = f"javac \"{java_file}\""
        print(f"[{timestamp()}] [INFO] Compiling '{java_file}'...")
        code_compile = run_command(compile_cmd, shell=True)
        if code_compile != 0:
            print(f"[{timestamp()}] [ERROR] javac failed with return code {code_compile}.")
            return True

        # Package into JAR (including manifest)
        manifest = "Manifest-Version: 1.0\nMain-Class: " + class_name + "\n"
        manifest_file = "manifest.txt"
        with open(manifest_file, "w") as mf:
            mf.write(manifest)
        jar_cmd = f"jar cfm \"{output_jar}\" \"{manifest_file}\" \"{class_file}\""
        print(f"[{timestamp()}] [INFO] Creating JAR '{output_jar}' with main class '{class_name}'...")
        code_jar = run_command(jar_cmd, shell=True)
        os.remove(manifest_file)

        if code_jar == 0:
            print(f"[{timestamp()}] [SUCCESS] JAR '{output_jar}' created successfully.")
        else:
            print(f"[{timestamp()}] [ERROR] jar command failed with return code {code_jar}.")
        return True

    if user_input.startswith("pd-java-doc "):
        user_input = user_input[11:].strip()
        parts = shlex.split(user_input)
        if len(parts) < 1 or len(parts) > 2:
            print(f"[{timestamp()}] [ERROR] Provide a source file or package path, optionally an output directory.")
            return False

        target = parts[0]
        output_dir = parts[1] if len(parts) == 2 else "doc"
        if not os.path.exists(target):
            print(f"[{timestamp()}] [ERROR] Path '{target}' not found.")
            return False

        cmd = f"javadoc -d \"{output_dir}\" \"{target}\""
        print(f"[{timestamp()}] [INFO] Generating Javadoc for '{target}' into '{output_dir}'...")
        try:
            code = run_command(cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Javadoc generated in '{output_dir}'.")
            else:
                print(f"[{timestamp()}] [ERROR] javadoc failed with return code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Javadoc generation cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] pd-java-doc failed: {e}")
        return True

    if user_input.startswith("pd-java-clean"):
        parts = shlex.split(user_input[13:].strip())
        target_dir = parts[0] if parts else "."
        if not os.path.isdir(target_dir):
            print(f"[{timestamp()}] [ERROR] Directory '{target_dir}' not found.")
            return False

        # Delete all .class and .jar in target_dir
        print(f"[{timestamp()}] [INFO] Cleaning .class and .jar files in '{target_dir}'...")
        try:
            for root, _, files in os.walk(target_dir):
                for filename in files:
                    if filename.endswith(".class") or filename.endswith(".jar"):
                        filepath = os.path.join(root, filename)
                        os.remove(filepath)
            print(f"[{timestamp()}] [SUCCESS] Clean complete.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] pd-java-clean failed: {e}")
        return True

    if user_input.startswith("pd-java-compile-all "):
        user_input = user_input[19:].strip()
        source_dir = user_input
        if not os.path.isdir(source_dir):
            print(f"[{timestamp()}] [ERROR] Directory '{source_dir}' not found.")
            return False

        # Find all .java files
        java_files = []
        for root, _, files in os.walk(source_dir):
            for f in files:
                if f.endswith(".java"):
                    java_files.append(os.path.join(root, f))

        if not java_files:
            print(f"[{timestamp()}] [ERROR] No .java files found in '{source_dir}'.")
            return True

        files_str = " ".join(f"\"{jf}\"" for jf in java_files)
        compile_cmd = f"javac -d \"{source_dir}\" {files_str}"
        print(f"[{timestamp()}] [INFO] Compiling all Java files in '{source_dir}'...")
        try:
            code = run_command(compile_cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] All Java files compiled into '{source_dir}'.")
            else:
                print(f"[{timestamp()}] [ERROR] javac failed with return code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] pd-java-compile-all failed: {e}")
        return True

    if user_input.startswith("pd-java-run-all "):
        user_input = user_input[15:].strip()
        args = shlex.split(user_input)
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: package directory and class name pattern.")
            return False

        package_dir, pattern = args
        if not os.path.isdir(package_dir):
            print(f"[{timestamp()}] [ERROR] Directory '{package_dir}' not found.")
            return False

        # Convert directory to classpath root and find matching .class files
        class_files = []
        for root, _, files in os.walk(package_dir):
            for f in files:
                if f.endswith(".class") and pattern in f:
                    rel_path = os.path.relpath(root, package_dir).replace(os.sep, ".")
                    class_name = f[:-6]
                    fqcn = f"{rel_path}.{class_name}" if rel_path != "." else class_name
                    class_files.append(fqcn)

        if not class_files:
            print(f"[{timestamp()}] [ERROR] No classes matching '{pattern}' found in '{package_dir}'.")
            return True

        for fqcn in class_files:
            cmd = f"java -cp \"{package_dir}\" {fqcn}"
            print(f"[{timestamp()}] [INFO] Running class '{fqcn}'...")
            try:
                run_command(cmd, shell=True)
            except KeyboardInterrupt:
                print(f"[{timestamp()}] [INFO] Execution of '{fqcn}' cancelled by user.")
            except subprocess.SubprocessError as e:
                print(f"[{timestamp()}] [ERROR] Running '{fqcn}' failed: {e}")
        return True

    if user_input.startswith("pd-java-all "):
        user_input = user_input[12:].strip()
        args = shlex.split(user_input)
        if len(args) != 3:
            print(f"[{timestamp()}] [ERROR] Provide three arguments: project directory, main class, and output JAR.")
            return False

        project_dir, main_class, output_jar = args
        if not os.path.isdir(project_dir):
            print(f"[{timestamp()}] [ERROR] Directory '{project_dir}' not found.")
            return False

        # 1. Clean
        print(f"[{timestamp()}] [INFO] Cleaning project directory '{project_dir}'...")
        try:
            for root, _, files in os.walk(project_dir):
                for f in files:
                    if f.endswith(".class") or f.endswith(".jar"):
                        os.remove(os.path.join(root, f))
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Clean failed: {e}")
            return True

        # 2. Compile all .java files
        print(f"[{timestamp()}] [INFO] Compiling all .java files in '{project_dir}'...")
        java_files = []
        for root, _, files in os.walk(project_dir):
            for f in files:
                if f.endswith(".java"):
                    java_files.append(os.path.join(root, f))
        files_str = " ".join(f"\"{jf}\"" for jf in java_files)
        compile_cmd = f"javac -d \"{project_dir}\" {files_str}"
        code_compile = run_command(compile_cmd, shell=True)
        if code_compile != 0:
            print(f"[{timestamp()}] [ERROR] javac failed with return code {code_compile}.")
            return True

        # 3. Create JAR
        manifest = "Manifest-Version: 1.0\nMain-Class: " + main_class + "\n"
        manifest_file = os.path.join(project_dir, "manifest.txt")
        with open(manifest_file, "w") as mf:
            mf.write(manifest)
        class_files = []
        for root, _, files in os.walk(project_dir):
            for f in files:
                if f.endswith(".class"):
                    rel = os.path.relpath(os.path.join(root, f), project_dir)
                    class_files.append(rel)
        class_list_str = " ".join(f"\"{cf}\"" for cf in class_files)
        jar_cmd = f"jar cfm \"{os.path.join(project_dir, output_jar)}\" \"{manifest_file}\" {class_list_str}"
        print(f"[{timestamp()}] [INFO] Creating JAR '{output_jar}' with main class '{main_class}'...")
        code_jar = run_command(jar_cmd, shell=True)
        os.remove(manifest_file)
        if code_jar != 0:
            print(f"[{timestamp()}] [ERROR] jar failed with return code {code_jar}.")
            return True

        # 4. Run the JAR
        run_cmd = f"java -jar \"{os.path.join(project_dir, output_jar)}\""
        print(f"[{timestamp()}] [INFO] Running JAR '{output_jar}'...")
        try:
            run_command(run_cmd, shell=True)
            print(f"[{timestamp()}] [SUCCESS] pd-java-all pipeline completed successfully.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Execution cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] Running JAR failed: {e}")
        return True

    if user_input.startswith("pd-java-clean-logs "):
        user_input = user_input[18:].strip()
        project_dir = user_input
        if not os.path.isdir(project_dir):
            print(f"[{timestamp()}] [ERROR] Directory '{project_dir}' not found.")
            return False

        patterns = ["*.log", ".classpath", ".project", ".settings", "target", "bin"]
        print(f"[{timestamp()}] [INFO] Cleaning IDE artifacts and logs from '{project_dir}'...")
        try:
            for root, dirs, files in os.walk(project_dir):
                for f in files:
                    for pat in ["*.log", ".classpath", ".project"]:
                        if f.endswith(pat) or f == pat:
                            os.remove(os.path.join(root, f))
                for d in dirs:
                    if d in ["target", "bin", ".settings"]:
                        dirpath = os.path.join(root, d)
                        subprocess.call(f"rmdir /s /q \"{dirpath}\"", shell=True)
            print(f"[{timestamp()}] [SUCCESS] IDE artifacts cleaned.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] pd-java-clean-logs failed: {e}")
        return True

    if user_input.startswith("ruby "):
        user_input = user_input[5:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ruby {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Ruby\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("rubyc "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ruby {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Ruby\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-ruby "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ruby {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Ruby\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("prruby "):
        filepath = os.path.abspath(user_input[7:].strip())

        if not os.path.isfile(filepath):
            print(f"[{timestamp()}] [ERROR] File not found: {filepath}")
            return True

        if not filepath.lower().endswith(".rb"):
            print(f"[{timestamp()}] [INFO] Unsupported file extension for Ruby: {filepath}")
            return True

        print(f"[{timestamp()}] [INFO] Running Ruby script: {filepath}")
        directory = os.path.dirname(filepath)
        port = find_free_port()

        # Start local server
        server_thread = threading.Thread(target=start_local_server, args=(directory, port), daemon=True)
        server_thread.start()

        # Optional: Delay to allow the server to start
        time.sleep(1)

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # Run Ruby script (it might generate output into HTML in the same dir)
        command = f"ruby \"{filepath}\""
        process = subprocess.Popen(
            command,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Execution canceled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Ruby execution failed: {e}")
            return True

        # Try to open a file like index.html if it exists
        index_path = os.path.join(directory, "index.html")
        if os.path.exists(index_path):
            url = f"http://localhost:{port}/index.html"
            print(f"[{timestamp()}] [INFO] Opening in browser: {url}")
            webbrowser.open(url)
        else:
            print(f"[{timestamp()}] [INFO] No index.html found to open in browser.")

        return True

    if user_input.startswith("pd-ruby "):
        script = user_input[8:].strip()

        # Remove .rb suffix if present
        if script.endswith(".rb"):
            script = script[:-3]

        # 1) Check if pry is installed
        try:
            has_pry = subprocess.run(
                ["gem", "list", "pry", "-i"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            ).returncode == 0

            if not has_pry:
                print(f"[{timestamp()}] [INFO] `pry` not found, installing with `gem install pry`…")
                subprocess.run(
                    ["gem", "install", "pry"],
                    check=True
                )
                print(f"[{timestamp()}] [INFO] `pry` successfully installed.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error while installing pry: {e}", file=sys.stderr)
            return True

        # 2) Debug script with rdbg (Ruby 3.1+)
        cmd = ["rdbg", "--open", "--port", "5005", f"{script}.rb"]

        print(f"[{timestamp()}] [INFO] Starting Ruby debugger for {script}.rb on port 5005")
        try:
            proc = subprocess.Popen(cmd)
            proc.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error running rdbg: {e}", file=sys.stderr)

        return True

    if user_input.startswith("Rscript "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"Rscript {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Rscript\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("Rscriptc "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"Rscript {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Rscript")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-r "):
        user_input = user_input[5:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"Rscript {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Rscript\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-r "):
        script = user_input[5:].strip()

        # Remove .R suffix if present
        if script.endswith(".R"):
            script = script[:-2]

        # 1) Check if 'debug' package is installed (just as an example)
        try:
            has_debug = subprocess.run(
                ["Rscript", "-e", "if (!requireNamespace('debug', quietly=TRUE)) quit(status=1)"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            ).returncode == 0

            if not has_debug:
                print(f"[{timestamp()}] [INFO] 'debug' package not found, installing with install.packages('debug')…")
                subprocess.run(
                    ["Rscript", "-e", "install.packages('debug', repos='https://cloud.r-project.org')"],
                    check=True
                )
                print(f"[{timestamp()}] [INFO] 'debug' package successfully installed.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error while installing debug package: {e}", file=sys.stderr)
            return True

        # 2) Debug script with Rscript --debugger (R 4.0+)
        cmd = ["Rscript", "-d", "debug", f"{script}.R"]

        print(f"[{timestamp()}] [INFO] Starting R debugger for {script}.R")
        try:
            proc = subprocess.Popen(cmd)
            proc.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error running R debugger: {e}", file=sys.stderr)

        return True

    if user_input.startswith("pyinstaller --onefile "):
        user_input = user_input[22:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"pyinstaller --onefile {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with PyInstaller\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pythonc "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"pyinstaller --onefile {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with PyInstaller\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("prp "):
        user_input = user_input[4:].strip()

        command = f"python {user_input}"

        try:
            print(f"[{timestamp()}] [INFO] Run {user_input} with Python:\n")
            run_command(command, shell=True)
            print("")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pr-p "):
        user_input = user_input[5:].strip()

        command = f"python {user_input}"

        try:
            print(f"[{timestamp()}] [INFO] Run {user_input} with Python:\n")
            run_command(command, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-p "):
        user_input = user_input[5:].strip()

        command = f"python {user_input}"

        try:
            print(f"[{timestamp()}] [INFO] Run {user_input} with Python:\n")
            run_command(command, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-python "):
        user_input = user_input[10:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"pyinstaller --onefile {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with PyInstaller\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pdp "):
        user_input = user_input[4:].strip()

        command = f"python -m pdb {user_input}"

        try:
            print(f"[{timestamp()}] [INFO] Debugg {user_input} with Python:\n")
            run_command(command, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-p "):
        user_input = user_input[5:].strip()

        command = f"python -m pdb {user_input}"

        try:
            print(f"[{timestamp()}] [INFO] Debugg {user_input} with Python:\n")
            run_command(command, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-python "):
        user_input = user_input[10:].strip()

        command = f"python -m pdb {user_input}"

        try:
            print(f"[{timestamp()}] [INFO] Debugg {user_input} with Python:\n")
            run_command(command, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-python-all-s "):
        user_input = user_input[14:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"pyinstaller --onefile --noconsole --icon={user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile your code with PyInstaller")
            print(f"[{timestamp()}] [INFO] Note the systkas: pc-python-all mein_icon.ico meine_app.py\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-python-run "):
        user_input = user_input[14:].strip()
        parts = shlex.split(user_input)
        script = parts[0]
        args = parts[1:]
        if not os.path.isfile(script):
            print(f"[{timestamp()}] [ERROR] Script '{script}' not found.")
            return False

        cmd = f"python \"{script}\" " + " ".join(f"\"{arg}\"" for arg in args)
        try:
            print(f"[{timestamp()}] [INFO] Running '{script}'...")
            run_command(cmd, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Execution cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] pd-python-run failed: {e}")
        return True

    if user_input.startswith("pd-python-venv "):
        user_input = user_input[16:].strip()
        venv_name = user_input
        if os.path.isdir(venv_name):
            print(f"[{timestamp()}] [ERROR] Virtual environment folder '{venv_name}' already exists.")
            return False

        cmd_create = f"python -m venv \"{venv_name}\""
        cmd_activate = f"call \"{venv_name}\\Scripts\\activate.bat\""

        try:
            print(f"[{timestamp()}] [INFO] Creating virtual environment '{venv_name}'...")
            code = run_command(cmd_create, shell=True)
            if code != 0:
                print(f"[{timestamp()}] [ERROR] venv creation failed with return code {code}.")
                return True

            print(f"[{timestamp()}] [INFO] Activating virtual environment '{venv_name}'...")
            run_command(cmd_activate, shell=True)
            print(f"[{timestamp()}] [SUCCESS] Virtual environment '{venv_name}' created and activated.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Operation cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] pd-python-venv failed: {e}")
        return True

    if user_input.startswith("pd-python-install "):
        user_input = user_input[18:].strip()
        args = shlex.split(user_input)
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Please provide exactly two arguments: venv folder and requirements file.")
            return False

        venv_name, req_file = args
        if not os.path.isdir(venv_name):
            print(f"[{timestamp()}] [ERROR] Virtual environment '{venv_name}' not found.")
            return False
        if not os.path.isfile(req_file):
            print(f"[{timestamp()}] [ERROR] Requirements file '{req_file}' not found.")
            return False

        cmd_activate = f"call \"{venv_name}\\Scripts\\activate.bat\""
        cmd_install = f"pip install -r \"{req_file}\""

        try:
            print(f"[{timestamp()}] [INFO] Activating virtual environment '{venv_name}'...")
            run_command(cmd_activate, shell=True)
            print(f"[{timestamp()}] [INFO] Installing packages from '{req_file}'...")
            code = run_command(cmd_install, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Packages installed successfully.")
            else:
                print(f"[{timestamp()}] [ERROR] pip install failed with return code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Installation cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] pd-python-install failed: {e}")
        return True

    if user_input.startswith("pd-python-format "):
        user_input = user_input[17:].strip()
        target = user_input
        if not os.path.exists(target):
            print(f"[{timestamp()}] [ERROR] Path '{target}' not found.")
            return False

        cmd = f"black \"{target}\""
        try:
            print(f"[{timestamp()}] [INFO] Formatting '{target}' with black...")
            code = run_command(cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Format complete.")
            else:
                print(f"[{timestamp()}] [ERROR] black failed with return code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Formatting cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] pd-python-format failed: {e}")
        return True

    if user_input.startswith("pd-python-lint "):
        user_input = user_input[16:].strip()
        target = user_input
        if not os.path.exists(target):
            print(f"[{timestamp()}] [ERROR] Path '{target}' not found.")
            return False

        cmd = f"flake8 \"{target}\""
        try:
            print(f"[{timestamp()}] [INFO] Linting '{target}' with flake8...")
            code = run_command(cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] No linting issues found.")
            else:
                print(f"[{timestamp()}] [ERROR] flake8 found issues (return code {code}).")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Linting cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] pd-python-lint failed: {e}")
        return True

    if user_input.startswith("pd-python-typecheck "):
        user_input = user_input[19:].strip()
        target = user_input
        if not os.path.exists(target):
            print(f"[{timestamp()}] [ERROR] Path '{target}' not found.")
            return False

        cmd = f"mypy \"{target}\""
        try:
            print(f"[{timestamp()}] [INFO] Type-checking '{target}' with mypy...")
            code = run_command(cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] No type errors detected.")
            else:
                print(f"[{timestamp()}] [ERROR] mypy detected issues (return code {code}).")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Type-check cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] pd-python-typecheck failed: {e}")
        return True

    if user_input.startswith("pd-python-test "):
        user_input = user_input[15:].strip()
        target = user_input if user_input else "."
        if not os.path.exists(target):
            print(f"[{timestamp()}] [ERROR] Path '{target}' not found.")
            return False

        cmd = f"pytest \"{target}\""
        try:
            print(f"[{timestamp()}] [INFO] Running tests with pytest on '{target}'...")
            code = run_command(cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Tests passed successfully.")
            else:
                print(f"[{timestamp()}] [ERROR] pytest detected failures (return code {code}).")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Tests cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] pd-python-test failed: {e}")
        return True

    if user_input.startswith("pd-python-coverage "):
        user_input = user_input[19:].strip()
        parts = shlex.split(user_input)
        if len(parts) == 0:
            print(f"[{timestamp()}] [ERROR] Please provide a script or test path.")
            return False

        target = parts[0]
        html_flag = "--html" in parts

        if not os.path.exists(target):
            print(f"[{timestamp()}] [ERROR] Path '{target}' not found.")
            return False

        cmd_run = f"coverage run -m pytest \"{target}\"" if os.path.isdir(target) or target.endswith("_test.py") else f"coverage run \"{target}\""
        cmd_report = "coverage report"
        cmd_html = "coverage html"

        try:
            print(f"[{timestamp()}] [INFO] Running coverage on '{target}'...")
            code_run = run_command(cmd_run, shell=True)
            if code_run != 0:
                print(f"[{timestamp()}] [ERROR] coverage run failed with return code {code_run}.")
                return True

            print(f"[{timestamp()}] [INFO] Generating coverage report...")
            run_command(cmd_report, shell=True)

            if html_flag:
                print(f"[{timestamp()}] [INFO] Generating HTML coverage report...")
                run_command(cmd_html, shell=True)
                print(f"[{timestamp()}] [SUCCESS] HTML coverage report created in 'htmlcov'.")
            else:
                print(f"[{timestamp()}] [SUCCESS] Coverage summary displayed above.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Coverage generation cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] pd-python-coverage failed: {e}")
        return True

    if user_input.startswith("pd-python-pack "):
        user_input = user_input[16:].strip()
        target = user_input
        if not os.path.exists(target):
            print(f"[{timestamp()}] [ERROR] Path '{target}' not found.")
            return False

        # If it's a directory with pyproject.toml or setup.py
        if os.path.isdir(target):
            # Prefer pyproject.toml build via PEP517, otherwise fallback to setup.py
            if os.path.isfile(os.path.join(target, "pyproject.toml")):
                cmd = f"cd \"{target}\" && python -m build --wheel"
            elif os.path.isfile(os.path.join(target, "setup.py")):
                cmd = f"cd \"{target}\" && python setup.py bdist_wheel"
            else:
                print(f"[{timestamp()}] [ERROR] No setup.py or pyproject.toml found in '{target}'.")
                return False
        else:
            # If directly a setup.py file
            if target.endswith("setup.py"):
                dirpath = os.path.dirname(target)
                cmd = f"cd \"{dirpath}\" && python setup.py bdist_wheel"
            else:
                print(f"[{timestamp()}] [ERROR] '{target}' is not a recognized package entry point.")
                return False

        try:
            print(f"[{timestamp()}] [INFO] Building wheel for '{target}'...")
            code = run_command(cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Wheel built successfully. Check the 'dist' folder.")
            else:
                print(f"[{timestamp()}] [ERROR] Wheel build failed with return code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Packaging cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] pd-python-pack failed: {e}")
        return True

    if user_input.startswith("pd-python-docs "):
        user_input = user_input[16:].strip()
        docs_dir = user_input
        if not os.path.isdir(docs_dir):
            print(f"[{timestamp()}] [ERROR] Directory '{docs_dir}' not found.")
            return False

        # Build HTML docs
        cmd = f"cd \"{docs_dir}\" && sphinx-build -b html \"{docs_dir}\" \"{os.path.join(docs_dir, '_build')}\""

        try:
            print(f"[{timestamp()}] [INFO] Generating Sphinx documentation in '{docs_dir}'...")
            code = run_command(cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Documentation built in '{os.path.join(docs_dir, '_build')}'.")
            else:
                print(f"[{timestamp()}] [ERROR] Sphinx build failed with return code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Documentation build cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] pd-python-docs failed: {e}")
        return True

    if user_input.startswith("pd-python-clean"):
        # Accept optional directory argument, default to current directory
        args = shlex.split(user_input[15:].strip())
        target_dir = args[0] if args else "."
        if not os.path.isdir(target_dir):
            print(f"[{timestamp()}] [ERROR] Directory '{target_dir}' not found.")
            return False

        # Remove .pyc files, __pycache__ folders, build/ and dist/ if present
        cmd_clean_pyc = f"for /r \"{target_dir}\" %f in (*.pyc) do del \"%f\""
        cmd_clean_cache = f"for /d /r \"{target_dir}\" %d in (__pycache__) do rmdir /s /q \"%d\""
        cmd_clean_build = f"if exist \"{os.path.join(target_dir, 'build')}\" rmdir /s /q \"{os.path.join(target_dir, 'build')}\""
        cmd_clean_dist = f"if exist \"{os.path.join(target_dir, 'dist')}\" rmdir /s /q \"{os.path.join(target_dir, 'dist')}\""

        try:
            print(f"[{timestamp()}] [INFO] Cleaning Python artifacts in '{target_dir}'...")
            run_command(cmd_clean_pyc, shell=True)
            run_command(cmd_clean_cache, shell=True)
            run_command(cmd_clean_build, shell=True)
            run_command(cmd_clean_dist, shell=True)
            print(f"[{timestamp()}] [SUCCESS] Clean complete.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cleaning cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] pd-python-clean failed: {e}")
        return True

    if user_input.startswith("pd-python-all "):
        user_input = user_input[14:].strip()
        project_dir = user_input
        if not os.path.isdir(project_dir):
            print(f"[{timestamp()}] [ERROR] Directory '{project_dir}' not found.")
            return False

        # 1. Format
        cmd_fmt = f"black \"{project_dir}\""
        # 2. Lint
        cmd_lint = f"flake8 \"{project_dir}\""
        # 3. Type-check
        cmd_type = f"mypy \"{project_dir}\""
        # 4. Test
        cmd_test = f"pytest \"{project_dir}\""
        # 5. Coverage report
        cmd_cov = f"coverage run -m pytest \"{project_dir}\" && coverage report"
        # 6. Build wheel
        if os.path.isfile(os.path.join(project_dir, "pyproject.toml")):
            cmd_pack = f"cd \"{project_dir}\" && python -m build --wheel"
        else:
            cmd_pack = f"cd \"{project_dir}\" && python setup.py bdist_wheel"

        print(f"[{timestamp()}] [INFO] Running pd-python-all pipeline on '{project_dir}'...")
        try:
            # Format
            print(f"[{timestamp()}] [INFO] Formatting code...")
            run_command(cmd_fmt, shell=True)

            # Lint
            print(f"[{timestamp()}] [INFO] Linting code...")
            run_command(cmd_lint, shell=True)

            # Type-check
            print(f"[{timestamp()}] [INFO] Type-checking code...")
            run_command(cmd_type, shell=True)

            # Test
            print(f"[{timestamp()}] [INFO] Running tests...")
            run_command(cmd_test, shell=True)

            # Coverage
            print(f"[{timestamp()}] [INFO] Generating coverage report...")
            run_command(cmd_cov, shell=True)

            # Package
            print(f"[{timestamp()}] [INFO] Building distribution package...")
            code = run_command(cmd_pack, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] pd-python-all completed successfully.")
            else:
                print(f"[{timestamp()}] [ERROR] Packaging step failed with return code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Pipeline cancelled by user.")
        except subprocess.SubprocessError as e:
            print(f"[{timestamp()}] [ERROR] pd-python-all failed: {e}")
        return True

    if user_input.startswith(("pd-pudb ", "pd-ipdb ")):
        # pudb oder ipdb debug commands
        if user_input.startswith("pd-pudb "):
            user_input = user_input[8:].strip()
            module = "pudb"
        else:
            user_input = user_input[8:].strip()
            module = "ipdb"

        # Aktive Umgebung laden
        json_path = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/current_env.json")
        if not json_path.exists():
            print(f"[{timestamp()}] [ERROR] Environment config file not found: {json_path}")
            shutdown_jupyter_kernel()
            return True
        with open(json_path, 'r') as file:
            data = json.load(file)
            active_env_path = data.get("active_env")

        if not active_env_path:
            print(f"[{timestamp()}] [ERROR] No active environment found.")
            shutdown_jupyter_kernel()
            return True

        command = f"python -m {module} {user_input}"
        try:
            print(f"[{timestamp()}] [INFO] Debugging {user_input} with {module} in env {active_env_path}...\n")
            run_command(command, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Executing {module} command failed: {e}")
        return True

    if user_input.startswith("go run "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"go run {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with GO\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("go build "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"go build {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with GO\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("goc "):
        user_input = user_input[4:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"go build {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with GO Build\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-go "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"go build {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with GO Build\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-go "):
        script = user_input[6:].strip()

        # Remove .go suffix if present
        if script.endswith(".go"):
            script = script[:-3]

        # 1) Check if Delve (dlv) debugger is installed
        try:
            has_dlv = subprocess.run(
                ["which", "dlv"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            ).returncode == 0

            if not has_dlv:
                print(
                    f"[{timestamp()}] [INFO] `dlv` (Delve debugger) not found, installing with `go install github.com/go-delve/delve/cmd/dlv@latest`…")
                subprocess.run(
                    ["go", "install", "github.com/go-delve/delve/cmd/dlv@latest"],
                    check=True
                )
                print(f"[{timestamp()}] [INFO] `dlv` successfully installed.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error while installing dlv: {e}", file=sys.stderr)
            return True

        # 2) Debug Go program with dlv
        # Annahme: ausführbare Datei heißt wie das Script ohne .go
        executable = script

        print(f"[{timestamp()}] [INFO] Starting Go debugger (dlv) for {executable}")
        try:
            # Build the binary first (debug build)
            subprocess.run(["go", "build", "-gcflags", "all=-N -l", "-o", executable, f"{script}.go"], check=True)

            # Start debugger in headless mode, listening on port 2345 (Standard)
            cmd = ["dlv", "exec", f"./{executable}", "--headless", "--listen=:2345", "--api-version=2",
                   "--accept-multiclient"]

            proc = subprocess.Popen(cmd)
            proc.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error running dlv: {e}", file=sys.stderr)

        return True

    if user_input.startswith("pd-go-run "):
        target = user_input[10:].strip()
        cmd = f"go run \"{target}\""
        try:
            run_command(cmd, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Run cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] pd-go-run failed: {e}")
        return True

    if user_input.startswith("pd-go-build "):
        pkg = user_input[12:].strip()
        cmd = f"go build \"{pkg}\""
        try:
            code = run_command(cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Build completed.")
            else:
                print(f"[{timestamp()}] [ERROR] Build failed with code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Build cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] pd-go-build failed: {e}")
        return True

    if user_input.startswith("pd-go-test "):
        pkg = user_input[11:].strip()
        cmd = f"go test \"{pkg}\""
        try:
            run_command(cmd, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Tests cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] pd-go-test failed: {e}")
        return True

    if user_input.startswith("pd-go-format "):
        target = user_input[13:].strip()
        cmd = f"go fmt \"{target}\""
        try:
            code = run_command(cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Format completed.")
            else:
                print(f"[{timestamp()}] [ERROR] go fmt failed with code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Format cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] pd-go-format failed: {e}")
        return True

    if user_input.startswith("pd-go-lint "):
        target = user_input[11:].strip()
        cmd = f"go vet \"{target}\""
        try:
            code = run_command(cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] No issues found.")
            else:
                print(f"[{timestamp()}] [ERROR] go vet found issues, code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Lint cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] pd-go-lint failed: {e}")
        return True

    if user_input.startswith("pd-go-mod-tidy"):
        target = user_input[14:].strip()
        cmd = f"go mod tidy"
        if target:
            cmd = f"cd \"{target}\" && go mod tidy"
        try:
            code = run_command(cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] go mod tidy completed.")
            else:
                print(f"[{timestamp()}] [ERROR] go mod tidy failed with code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] go mod tidy cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] pd-go-mod-tidy failed: {e}")
        return True

    if user_input.startswith("pd-go-mod-vendor"):
        target = user_input[15:].strip()
        cmd = f"go mod vendor"
        if target:
            cmd = f"cd \"{target}\" && go mod vendor"
        try:
            code = run_command(cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] Vendor directory created.")
            else:
                print(f"[{timestamp()}] [ERROR] go mod vendor failed with code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] go mod vendor cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] pd-go-mod-vendor failed: {e}")
        return True

    if user_input.startswith("pd-go-install"):
        pkg = user_input[11:].strip()
        cmd = f"go install \"{pkg}\""
        try:
            code = run_command(cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] go install completed.")
            else:
                print(f"[{timestamp()}] [ERROR] go install failed with code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] go install cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] pd-go-install failed: {e}")
        return True

    if user_input.startswith("pd-go-cover"):
        target = user_input[13:].strip()
        html_flag = "--html" in target
        pkg = target.replace("--html", "").strip()
        cmd_run = f"go test -coverprofile=coverage.out \"{pkg}\""
        cmd_report = "go tool cover -func=coverage.out"
        cmd_html = "go tool cover -html=coverage.out -o coverage.html"
        try:
            code = run_command(cmd_run, shell=True)
            if code != 0:
                print(f"[{timestamp()}] [ERROR] go test -cover failed with code {code}.")
                return True
            run_command(cmd_report, shell=True)
            if html_flag:
                run_command(cmd_html, shell=True)
                print(f"[{timestamp()}] [SUCCESS] HTML coverage report created.")
            else:
                print(f"[{timestamp()}] [SUCCESS] Coverage summary above.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Coverage cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] pd-go-cover failed: {e}")
        return True

    if user_input.startswith("pd-go-bench"):
        pkg = user_input[11:].strip()
        if not pkg:
            pkg = "./..."
        cmd = f"go test -bench . \"{pkg}\""
        try:
            run_command(cmd, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Benchmarks cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] pd-go-bench failed: {e}")
        return True

    if user_input.startswith("pd-go-doc"):
        target = user_input[10:].strip()
        cmd = f"go doc \"{target}\""
        try:
            run_command(cmd, shell=True)
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] go doc cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] pd-go-doc failed: {e}")
        return True

    if user_input.startswith("pd-go-clean"):
        target = user_input[12:].strip()
        cmd_clean_cache = "go clean -cache -testcache -modcache"
        cmd_delete_bin = "del /Q *.exe 2>nul"
        try:
            run_command(cmd_clean_cache, shell=True)
            run_command(cmd_delete_bin, shell=True)
            print(f"[{timestamp()}] [SUCCESS] Clean completed.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Clean cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] pd-go-clean failed: {e}")
        return True

    if user_input.startswith("pd-go-compile-all"):
        source_dir = user_input[17:].strip()
        if not os.path.isdir(source_dir):
            print(f"[{timestamp()}] [ERROR] Directory '{source_dir}' not found.")
            return True
        go_files = []
        for root, _, files in os.walk(source_dir):
            for f in files:
                if f.endswith(".go"):
                    go_files.append(os.path.join(root, f))
        if not go_files:
            print(f"[{timestamp()}] [ERROR] No .go files in '{source_dir}'.")
            return True
        files_str = " ".join(f"\"{gf}\"" for gf in go_files)
        cmd = f"go build -o \"{source_dir}\\bin\\app.exe\" {files_str}"
        try:
            code = run_command(cmd, shell=True)
            if code == 0:
                print(f"[{timestamp()}] [SUCCESS] All Go files compiled to '{source_dir}\\bin\\app.exe'.")
            else:
                print(f"[{timestamp()}] [ERROR] Build failed with code {code}.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] pd-go-compile-all failed: {e}")
        return True

    if user_input.startswith("pd-go-run-all"):
        args = shlex.split(user_input[13:].strip())
        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Provide two arguments: directory and pattern.")
            return True
        package_dir, pattern = args
        if not os.path.isdir(package_dir):
            print(f"[{timestamp()}] [ERROR] Directory '{package_dir}' not found.")
            return True
        for root, _, files in os.walk(package_dir):
            for f in files:
                if f.endswith(".exe") and pattern in f:
                    exe_path = os.path.join(root, f)
                    print(f"[{timestamp()}] [INFO] Running '{exe_path}'...")
                    try:
                        run_command(f"\"{exe_path}\"", shell=True)
                    except KeyboardInterrupt:
                        print(f"[{timestamp()}] [INFO] Execution of '{exe_path}' cancelled.")
                    except subprocess.CalledProcessError as e:
                        print(f"[{timestamp()}] [ERROR] Running '{exe_path}' failed: {e}")
        return True

    if user_input.startswith("pd-go-all"):
        project_dir = user_input[10:].strip()
        if not os.path.isdir(project_dir):
            print(f"[{timestamp()}] [ERROR] Directory '{project_dir}' not found.")
            return True
        try:
            run_command(f"go mod tidy", shell=True)
            run_command(f"go build \"{project_dir}\"", shell=True)
            run_command(f"go test \"{project_dir}\"", shell=True)
            run_command(f"go run \"{project_dir}\"", shell=True)
            print(f"[{timestamp()}] [SUCCESS] pd-go-all pipeline completed.")
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Pipeline cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] pd-go-all failed: {e}")
        return True

    if user_input.startswith("julia "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"julia {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Julia\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("juliac "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"julia {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Julia\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-julia "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"julia {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Julia\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-julia "):
        script = user_input[9:].strip()

        # Remove .jl suffix if present
        if script.endswith(".jl"):
            script = script[:-3]

        # 1) Check if Debugger.jl is installed in Julia
        try:
            has_debugger = subprocess.run(
                [
                    "julia",
                    "-e",
                    "using Pkg; is_installed = any(x -> x.name == \"Debugger\", Pkg.installed()); if !is_installed exit(1) end"
                ],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            ).returncode == 0

            if not has_debugger:
                print(f"[{timestamp()}] [INFO] Debugger.jl not found, installing with `Pkg.add(\"Debugger\")` …")
                subprocess.run(
                    ["julia", "-e", "using Pkg; Pkg.add(\"Debugger\")"],
                    check=True
                )
                print(f"[{timestamp()}] [INFO] Debugger.jl successfully installed.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error while installing Debugger.jl: {e}", file=sys.stderr)
            return True

        # 2) Start debugging session with Julia Debugger
        print(f"[{timestamp()}] [INFO] Starting Julia debugger for {script}.jl")

        # Kommando, das das Skript im Debug-Modus lädt
        # Wir nutzen das REPL Debugger-Paket via julia -e
        cmd = [
            "julia",
            "-e",
            (
                f"using Debugger; @enter include(\"{script}.jl\")"
            )
        ]

        try:
            proc = subprocess.Popen(cmd)
            proc.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error running Julia Debugger: {e}", file=sys.stderr)

        return True

    if user_input.startswith("php "):
        user_input = user_input[4:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"php {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with PHP\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("phpc "):
        user_input = user_input[5:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"php {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with PHP\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-php "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"php {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with PHP\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("prphp "):
        filepath = os.path.abspath(user_input[6:].strip())

        if not os.path.isfile(filepath):
            print(f"[{timestamp()}] [ERROR] File '{filepath}' does not exist.")
            return True

        directory = os.path.dirname(filepath)
        filename = os.path.basename(filepath)

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        server_thread = threading.Thread(
            target=start_local_server,
            args=(directory, requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/{filename}"
        print(f"[{timestamp()}] [INFO] Opening '{filename}' in browser: {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server is running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        # Server durch "Dummy-Request" abbrechen
        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        # Auf Beendigung des Threads warten
        server_thread.join(timeout=5)

        # Sicherstellen, dass die URL nicht mehr erreichbar ist
        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except (urllib.error.URLError, ConnectionRefusedError):
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        # Jetzt erst zurückkehren
        return True

    if user_input.startswith("pd-php "):
        script = user_input[7:].strip()

        # Remove .php suffix if present
        if script.endswith(".php"):
            script = script[:-4]

        # 1) Check if Xdebug is installed/enabled (php -m lists modules)
        try:
            has_xdebug = subprocess.run(
                ["php", "-m"],
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                check=True,
                text=True
            ).stdout.lower().find("xdebug") != -1

            if not has_xdebug:
                print(
                    f"[{timestamp()}] [INFO] Xdebug not found/enabled. Please install and enable Xdebug to debug PHP scripts.")
                return True
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error checking PHP modules: {e}", file=sys.stderr)
            return True

        # 2) Start debugging PHP script with Xdebug
        # Hinweis: Xdebug läuft normalerweise als Debug-Client (IDE) oder via remote debugging
        # Zum Starten einfach php mit dem Skript ausführen, Xdebug muss konfiguriert sein.
        print(f"[{timestamp()}] [INFO] Starting PHP script {script}.php with Xdebug enabled (if configured).")

        cmd = ["php", f"{script}.php"]

        try:
            proc = subprocess.Popen(cmd)
            proc.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error running PHP script: {e}", file=sys.stderr)

        return True

    if user_input.startswith("prsql "):
        filepath = os.path.abspath(user_input[6:].strip())

        if not os.path.isfile(filepath):
            print(f"[{timestamp()}] [ERROR] File '{filepath}' does not exist.")
            return True

        if not filepath.lower().endswith((".sqlite", ".db", ".sql")):
            print(f"[{timestamp()}] [ERROR] Unsupported SQL file type: '{filepath}'")
            return True

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class SQLiteRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed_path = urllib.parse.urlparse(self.path)
                if parsed_path.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    try:
                        conn = sqlite3.connect(filepath)
                        cursor = conn.cursor()

                        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
                        tables = [row[0] for row in cursor.fetchall()]

                        html_content = "<html><head><title>SQLite Browser</title></head><body>"
                        html_content += f"<h1>Database: {html.escape(os.path.basename(filepath))}</h1>"

                        for table in tables:
                            html_content += f"<h2>Table: {html.escape(table)}</h2><table border='1'>"
                            cursor.execute(f"SELECT * FROM {table} LIMIT 50;")
                            rows = cursor.fetchall()
                            col_names = [description[0] for description in cursor.description]

                            html_content += "<tr>" + "".join(f"<th>{html.escape(col)}</th>" for col in col_names) + "</tr>"
                            for row in rows:
                                html_content += "<tr>" + "".join(f"<td>{html.escape(str(cell))}</td>" for cell in row) + "</tr>"
                            html_content += "</table><br>"

                        html_content += "</body></html>"
                        self.wfile.write(html_content.encode('utf-8'))

                    except Exception as e:
                        self.wfile.write(f"<h1>Error</h1><p>{html.escape(str(e))}</p>".encode('utf-8'))
                    finally:
                        conn.close()
                else:
                    self.send_error(404, "File not found.")

        def start_sql_server(port, container, event):
            with socketserver.TCPServer(("", port), SQLiteRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_sql_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening database in browser: {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server is running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except (urllib.error.URLError, ConnectionRefusedError):
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True

    if user_input.startswith("prmysql "):
        import mysql.connector
        from mysql.connector import Error
        
        # Beispiel: prmysql user:pass@localhost:3306/dbname
        conn_info = user_input[8:].strip()

        try:
            creds, host_db = conn_info.split("@")
            user, pwd = creds.split(":")
            host_port, db_name = host_db.split("/")
            host, port = host_port.split(":")
            port = int(port)
        except ValueError:
            print(f"[{timestamp()}] [ERROR] Invalid connection string format.")
            return True

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class MySQLRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed_path = urllib.parse.urlparse(self.path)
                if parsed_path.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    html_content = "<html><head><title>MySQL Browser</title></head><body>"
                    html_content += f"<h1>Database: {html.escape(db_name)}</h1>"

                    try:
                        conn = mysql.connector.connect(
                            host=host,
                            port=port,
                            user=user,
                            password=pwd,
                            database=db_name
                        )
                        cursor = conn.cursor()

                        cursor.execute("SHOW TABLES;")
                        tables = [row[0] for row in cursor.fetchall()]

                        for table in tables:
                            html_content += f"<h2>Table: {html.escape(table)}</h2><table border='1'>"
                            cursor.execute(f"SELECT * FROM `{table}` LIMIT 50;")
                            rows = cursor.fetchall()
                            col_names = [desc[0] for desc in cursor.description]

                            html_content += "<tr>" + "".join(f"<th>{html.escape(col)}</th>" for col in col_names) + "</tr>"
                            for row in rows:
                                html_content += "<tr>" + "".join(f"<td>{html.escape(str(cell))}</td>" for cell in row) + "</tr>"
                            html_content += "</table><br>"

                        cursor.close()
                        conn.close()

                    except Error as e:
                        html_content += f"<h1>Error</h1><p>{html.escape(str(e))}</p>"

                    html_content += "</body></html>"
                    self.wfile.write(html_content.encode('utf-8'))
                else:
                    self.send_error(404, "Not Found")

        def start_sql_server(port, container, event):
            with socketserver.TCPServer(("", port), MySQLRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_sql_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening MySQL browser at {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server is running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True

    if user_input.startswith("prpgsql "):
        import psycopg2
        from psycopg2 import OperationalError

        # Beispiel: prpgsql user:pass@localhost:5432/dbname
        conn_info = user_input[8:].strip()

        try:
            creds, host_db = conn_info.split("@")
            user, pwd = creds.split(":")
            host_port, db_name = host_db.split("/")
            host, port = host_port.split(":")
            port = int(port)
        except ValueError:
            print(f"[{timestamp()}] [ERROR] Invalid connection string format.")
            return True

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class PostgresRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed_path = urllib.parse.urlparse(self.path)
                if parsed_path.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    html_content = "<html><head><title>PostgreSQL Browser</title></head><body>"
                    html_content += f"<h1>Database: {html.escape(db_name)}</h1>"

                    try:
                        conn = psycopg2.connect(
                            host=host,
                            port=port,
                            user=user,
                            password=pwd,
                            dbname=db_name
                        )
                        cursor = conn.cursor()

                        cursor.execute("""
                            SELECT table_name FROM information_schema.tables
                            WHERE table_schema = 'public';
                        """)
                        tables = [row[0] for row in cursor.fetchall()]

                        for table in tables:
                            html_content += f"<h2>Table: {html.escape(table)}</h2><table border='1'>"
                            cursor.execute(f'SELECT * FROM "{table}" LIMIT 50;')
                            rows = cursor.fetchall()
                            col_names = [desc[0] for desc in cursor.description]

                            html_content += "<tr>" + "".join(f"<th>{html.escape(col)}</th>" for col in col_names) + "</tr>"
                            for row in rows:
                                html_content += "<tr>" + "".join(f"<td>{html.escape(str(cell))}</td>" for cell in row) + "</tr>"
                            html_content += "</table><br>"

                        cursor.close()
                        conn.close()

                    except OperationalError as e:
                        html_content += f"<h1>Connection Error</h1><p>{html.escape(str(e))}</p>"
                    except Exception as e:
                        html_content += f"<h1>Error</h1><p>{html.escape(str(e))}</p>"

                    html_content += "</body></html>"
                    self.wfile.write(html_content.encode('utf-8'))
                else:
                    self.send_error(404, "Not Found")

        def start_sql_server(port, container, event):
            with socketserver.TCPServer(("", port), PostgresRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_sql_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening PostgreSQL browser at {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server is running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True

    if user_input.startswith("prsqlite "):
        import sqlite3

        filepath = os.path.abspath(user_input[9:].strip())

        if not os.path.isfile(filepath):
            print(f"[{timestamp()}] [ERROR] File '{filepath}' does not exist.")
            return True

        if not filepath.lower().endswith((".sqlite", ".db", ".sql")):
            print(f"[{timestamp()}] [ERROR] Unsupported SQL file type: '{filepath}'")
            return True

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class SQLiteRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed_path = urllib.parse.urlparse(self.path)
                if parsed_path.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    html_content = "<html><head><title>SQLite Browser</title></head><body>"
                    html_content += f"<h1>Database: {html.escape(os.path.basename(filepath))}</h1>"

                    try:
                        conn = sqlite3.connect(filepath)
                        cursor = conn.cursor()

                        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
                        tables = [row[0] for row in cursor.fetchall()]

                        for table in tables:
                            html_content += f"<h2>Table: {html.escape(table)}</h2><table border='1'>"
                            cursor.execute(f"SELECT * FROM '{table}' LIMIT 50;")
                            rows = cursor.fetchall()
                            col_names = [description[0] for description in cursor.description]

                            html_content += "<tr>" + "".join(f"<th>{html.escape(col)}</th>" for col in col_names) + "</tr>"
                            for row in rows:
                                html_content += "<tr>" + "".join(f"<td>{html.escape(str(cell))}</td>" for cell in row) + "</tr>"
                            html_content += "</table><br>"

                    except Exception as e:
                        html_content += f"<h1>Error</h1><p>{html.escape(str(e))}</p>"
                    finally:
                        conn.close()

                    html_content += "</body></html>"
                    self.wfile.write(html_content.encode('utf-8'))
                else:
                    self.send_error(404, "File not found.")

        def start_sql_server(port, container, event):
            with socketserver.TCPServer(("", port), SQLiteRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_sql_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening database in browser: {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server is running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True

    if user_input.startswith("proracle "):
        import cx_Oracle  # Oracle DB API

        conn_info = user_input[9:].strip()

        try:
            creds, netloc = conn_info.split("@")
            user, pwd = creds.split(":")
            host_port, sid = netloc.split("/")
            host, port = host_port.split(":")
            port = int(port)
        except ValueError:
            print(f"[{timestamp()}] [ERROR] Invalid Oracle connection string format.")
            return True

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class OracleRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed_path = urllib.parse.urlparse(self.path)
                if parsed_path.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    html_content = "<html><head><title>Oracle DB Browser</title></head><body>"
                    html_content += f"<h1>Oracle Database: {html.escape(sid)}</h1>"

                    try:
                        dsn = cx_Oracle.makedsn(host, port, sid)
                        conn = cx_Oracle.connect(user=user, password=pwd, dsn=dsn)
                        cursor = conn.cursor()

                        cursor.execute("SELECT table_name FROM user_tables")
                        tables = [row[0] for row in cursor.fetchall()]

                        for table in tables:
                            html_content += f"<h2>Table: {html.escape(table)}</h2><table border='1'>"
                            cursor.execute(f'SELECT * FROM "{table}" WHERE ROWNUM <= 50')
                            rows = cursor.fetchall()
                            col_names = [desc[0] for desc in cursor.description]

                            html_content += "<tr>" + "".join(f"<th>{html.escape(col)}</th>" for col in col_names) + "</tr>"
                            for row in rows:
                                html_content += "<tr>" + "".join(f"<td>{html.escape(str(cell))}</td>" for cell in row) + "</tr>"
                            html_content += "</table><br>"

                        cursor.close()
                        conn.close()

                    except cx_Oracle.DatabaseError as e:
                        html_content += f"<h1>Oracle Error</h1><p>{html.escape(str(e))}</p>"
                    except Exception as e:
                        html_content += f"<h1>Error</h1><p>{html.escape(str(e))}</p>"

                    html_content += "</body></html>"
                    self.wfile.write(html_content.encode('utf-8'))
                else:
                    self.send_error(404, "Not Found")

        def start_sql_server(port, container, event):
            with socketserver.TCPServer(("", port), OracleRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_sql_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening Oracle DB browser at {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server is running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True
    
    if user_input.startswith("prmssql "):
        import pyodbc  # SQL Server-Treiber

        conn_info = user_input[8:].strip()

        try:
            creds, host_part = conn_info.split("@")
            user, pwd = creds.split(":")
            host_port, database = host_part.split("/")
            host, port = host_port.split(":")
            port = int(port)
        except ValueError:
            print(f"[{timestamp()}] [ERROR] Invalid connection string format. Use: user:pass@host:port/database")
            return True

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class MSSQLRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed_path = urllib.parse.urlparse(self.path)
                if parsed_path.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    html_content = "<html><head><title>SQL Server Browser</title></head><body>"
                    html_content += f"<h1>Microsoft SQL Server – Database: {html.escape(database)}</h1>"

                    try:
                        conn_str = (
                            f"DRIVER={{ODBC Driver 17 for SQL Server}};"
                            f"SERVER={host},{port};DATABASE={database};UID={user};PWD={pwd}"
                        )
                        conn = pyodbc.connect(conn_str, timeout=5)
                        cursor = conn.cursor()

                        cursor.execute("SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'")
                        tables = [row[0] for row in cursor.fetchall()]

                        for table in tables:
                            html_content += f"<h2>Table: {html.escape(table)}</h2><table border='1'>"
                            cursor.execute(f"SELECT TOP 50 * FROM [{table}]")
                            rows = cursor.fetchall()
                            col_names = [desc[0] for desc in cursor.description]

                            html_content += "<tr>" + "".join(f"<th>{html.escape(col)}</th>" for col in col_names) + "</tr>"
                            for row in rows:
                                html_content += "<tr>" + "".join(f"<td>{html.escape(str(cell))}</td>" for cell in row) + "</tr>"
                            html_content += "</table><br>"

                        cursor.close()
                        conn.close()

                    except Exception as e:
                        html_content += f"<h1>Error</h1><p>{html.escape(str(e))}</p>"

                    html_content += "</body></html>"
                    self.wfile.write(html_content.encode('utf-8'))
                else:
                    self.send_error(404, "Not Found")

        def start_sql_server(port, container, event):
            with socketserver.TCPServer(("", port), MSSQLRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_sql_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening SQL Server DB in browser: {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server is running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True
    
    if user_input.startswith("prdb2 "):
        import ibm_db
        import ibm_db_dbi
        conn_info = user_input[6:].strip()

        try:
            creds, host_part = conn_info.split("@")
            user, pwd = creds.split(":")
            host_port, database = host_part.split("/")
            host, port = host_port.split(":")
            port = int(port)
        except ValueError:
            print(f"[{timestamp()}] [ERROR] Invalid connection string format. Use: user:pass@host:port/database")
            return True

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class Db2RequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed_path = urllib.parse.urlparse(self.path)
                if parsed_path.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    html_content = "<html><head><title>IBM Db2 Browser</title></head><body>"
                    html_content += f"<h1>IBM Db2 – Database: {html.escape(database)}</h1>"

                    try:
                        conn_str = f"DATABASE={database};HOSTNAME={host};PORT={port};PROTOCOL=TCPIP;UID={user};PWD={pwd};"
                        conn = ibm_db.connect(conn_str, "", "")
                        dbi_conn = ibm_db_dbi.Connection(conn)
                        cursor = dbi_conn.cursor()

                        cursor.execute("SELECT tabname FROM syscat.tables WHERE tabschema = CURRENT SCHEMA")
                        tables = [row[0] for row in cursor.fetchall()]

                        for table in tables:
                            html_content += f"<h2>Table: {html.escape(table)}</h2><table border='1'>"
                            cursor.execute(f'SELECT * FROM "{table}" FETCH FIRST 50 ROWS ONLY')
                            rows = cursor.fetchall()
                            col_names = [desc[0] for desc in cursor.description]

                            html_content += "<tr>" + "".join(f"<th>{html.escape(col)}</th>" for col in col_names) + "</tr>"
                            for row in rows:
                                html_content += "<tr>" + "".join(f"<td>{html.escape(str(cell))}</td>" for cell in row) + "</tr>"
                            html_content += "</table><br>"

                        cursor.close()
                        dbi_conn.close()
                        ibm_db.close(conn)

                    except Exception as e:
                        html_content += f"<h1>Error</h1><p>{html.escape(str(e))}</p>"

                    html_content += "</body></html>"
                    self.wfile.write(html_content.encode('utf-8'))
                else:
                    self.send_error(404, "Not Found")

        def start_sql_server(port, container, event):
            with socketserver.TCPServer(("", port), Db2RequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_sql_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening IBM Db2 browser at {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server is running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True

    if user_input.startswith("praurora "):
        import mysql.connector
        import psycopg2

        conn_info = user_input[8:].strip()

        # Versuch, Connection-String zu parsen: user:pass@host:port/dbname
        try:
            creds, host_part = conn_info.split("@")
            user, pwd = creds.split(":")
            host_port, database = host_part.split("/")
            host, port = host_port.split(":")
            port = int(port)
        except Exception:
            print(f"[{timestamp()}] [ERROR] Invalid connection string. Format: user:pass@host:port/dbname")
            return True

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class AuroraRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed_path = urllib.parse.urlparse(self.path)
                if parsed_path.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    html_content = f"<html><head><title>Aurora Browser</title></head><body>"
                    html_content += f"<h1>Amazon Aurora Database: {html.escape(database)}</h1>"

                    try:
                        # Versuche MySQL-Verbindung
                        conn = mysql.connector.connect(
                            user=user,
                            password=pwd,
                            host=host,
                            port=port,
                            database=database,
                            connection_timeout=5
                        )
                        cursor = conn.cursor()

                        cursor.execute("SHOW TABLES")
                        tables = [row[0] for row in cursor.fetchall()]

                    except mysql.connector.Error:
                        # Fallback auf PostgreSQL versuchen
                        try:
                            conn = psycopg2.connect(
                                user=user,
                                password=pwd,
                                host=host,
                                port=port,
                                dbname=database,
                                connect_timeout=5
                            )
                            cursor = conn.cursor()
                            cursor.execute(
                                "SELECT tablename FROM pg_tables WHERE schemaname = 'public';"
                            )
                            tables = [row[0] for row in cursor.fetchall()]
                        except Exception as e:
                            self.wfile.write(f"<h1>Connection error</h1><p>{html.escape(str(e))}</p>".encode('utf-8'))
                            return

                    # Tabellen anzeigen
                    for table in tables:
                        html_content += f"<h2>Table: {html.escape(table)}</h2><table border='1'>"
                        try:
                            cursor.execute(f"SELECT * FROM {table} LIMIT 50;")
                            rows = cursor.fetchall()
                            col_names = [desc[0] for desc in cursor.description]

                            html_content += "<tr>" + "".join(f"<th>{html.escape(str(c))}</th>" for c in col_names) + "</tr>"
                            for row in rows:
                                html_content += "<tr>" + "".join(f"<td>{html.escape(str(cell))}</td>" for cell in row) + "</tr>"
                        except Exception as e:
                            html_content += f"<tr><td colspan='100%'>Error reading table: {html.escape(str(e))}</td></tr>"
                        html_content += "</table><br>"

                    cursor.close()
                    conn.close()

                    html_content += "</body></html>"
                    self.wfile.write(html_content.encode('utf-8'))

                else:
                    self.send_error(404, "File not found.")

        def start_sql_server(port, container, event):
            with socketserver.TCPServer(("", port), AuroraRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_sql_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not start within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening Amazon Aurora browser at {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True
    
    if user_input.startswith("prrds "):
        conn_info = user_input[6:].strip()

        try:
            creds, host_part = conn_info.split("@")
            user, pwd = creds.split(":")
            host_port, database = host_part.split("/")
            host, port = host_port.split(":")
            port = int(port)
        except Exception:
            print(f"[{timestamp()}] [ERROR] Invalid connection string. Format: user:pass@host:port/dbname")
            return True

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class RDSRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed_path = urllib.parse.urlparse(self.path)
                if parsed_path.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    html_content = f"<html><head><title>Amazon RDS Browser</title></head><body>"
                    html_content += f"<h1>Amazon RDS Database: {html.escape(database)}</h1>"

                    try:
                        # Versuch MySQL
                        import mysql.connector
                        conn = mysql.connector.connect(
                            user=user,
                            password=pwd,
                            host=host,
                            port=port,
                            database=database,
                            connection_timeout=5
                        )
                        cursor = conn.cursor()
                        cursor.execute("SHOW TABLES")
                        tables = [row[0] for row in cursor.fetchall()]
                    except Exception:
                        try:
                            # Versuch PostgreSQL
                            import psycopg2
                            conn = psycopg2.connect(
                                user=user,
                                password=pwd,
                                host=host,
                                port=port,
                                dbname=database,
                                connect_timeout=5
                            )
                            cursor = conn.cursor()
                            cursor.execute("SELECT tablename FROM pg_tables WHERE schemaname = 'public';")
                            tables = [row[0] for row in cursor.fetchall()]
                        except Exception as e:
                            self.wfile.write(f"<h1>Connection error</h1><p>{html.escape(str(e))}</p>".encode('utf-8'))
                            return

                    for table in tables:
                        html_content += f"<h2>Table: {html.escape(table)}</h2><table border='1'>"
                        try:
                            cursor.execute(f"SELECT * FROM {table} LIMIT 50;")
                            rows = cursor.fetchall()
                            col_names = [desc[0] for desc in cursor.description]

                            html_content += "<tr>" + "".join(f"<th>{html.escape(str(c))}</th>" for c in col_names) + "</tr>"
                            for row in rows:
                                html_content += "<tr>" + "".join(f"<td>{html.escape(str(cell))}</td>" for cell in row) + "</tr>"
                        except Exception as e:
                            html_content += f"<tr><td colspan='100%'>Error reading table: {html.escape(str(e))}</td></tr>"
                        html_content += "</table><br>"

                    cursor.close()
                    conn.close()

                    html_content += "</body></html>"
                    self.wfile.write(html_content.encode('utf-8'))
                else:
                    self.send_error(404, "File not found.")

        def start_sql_server(port, container, event):
            with socketserver.TCPServer(("", port), RDSRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_sql_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not start within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening Amazon RDS browser at {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True
    
    if user_input.startswith("prredis "):
        import redis
        # Verbindungstring: host:port,password (Passwort optional)
        conn_info = user_input[8:].strip()

        try:
            # host:port,password optional (z.B. localhost:6379,mysecret)
            parts = conn_info.split(",")
            host_port = parts[0]
            password = parts[1] if len(parts) > 1 else None
            host, port = host_port.split(":")
            port = int(port)
        except Exception:
            print(f"[{timestamp()}] [ERROR] Invalid Redis connection string. Format: host:port,password(optional)")
            return True

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class RedisRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed_path = urllib.parse.urlparse(self.path)
                if parsed_path.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    try:
                        r = redis.Redis(host=host, port=port, password=password, socket_connect_timeout=5)
                        keys = r.keys('*')[:50]  # max 50 keys
                    except Exception as e:
                        self.wfile.write(f"<h1>Connection error</h1><p>{html.escape(str(e))}</p>".encode('utf-8'))
                        return

                    html_content = f"<html><head><title>Redis Browser</title></head><body>"
                    html_content += f"<h1>Redis Server at {host}:{port}</h1>"
                    html_content += f"<h2>Keys (max 50)</h2><table border='1'>"
                    html_content += "<tr><th>Key</th><th>Type</th><th>Value (truncated)</th></tr>"

                    for key in keys:
                        try:
                            key_str = key.decode('utf-8')
                            key_type = r.type(key).decode('utf-8')
                            if key_type == 'string':
                                val = r.get(key)
                                val_str = val.decode('utf-8') if val else ''
                            elif key_type == 'list':
                                val = r.lrange(key, 0, 4)
                                val_str = ', '.join(x.decode('utf-8') for x in val) + ('...' if r.llen(key) > 5 else '')
                            elif key_type == 'set':
                                val = r.smembers(key)
                                val_str = ', '.join(x.decode('utf-8') for x in list(val)[:5]) + ('...' if len(val) > 5 else '')
                            else:
                                val_str = "(type not shown)"
                        except Exception as e:
                            val_str = f"Error reading: {e}"

                        html_content += f"<tr><td>{html.escape(key_str)}</td><td>{html.escape(key_type)}</td><td>{html.escape(val_str)}</td></tr>"

                    html_content += "</table></body></html>"
                    self.wfile.write(html_content.encode('utf-8'))

                else:
                    self.send_error(404, "File not found.")

        def start_redis_server(port, container, event):
            with socketserver.TCPServer(("", port), RedisRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_redis_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not start within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening Redis browser at {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True
    
    if user_input.startswith("prmongo "):
        from bson.json_util import dumps
        from pymongo import MongoClient

        # Verbindungstring erwartet im Format: mongodb://user:pass@host:port/dbname
        conn_str = user_input[8:].strip()

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class MongoRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed_path = urllib.parse.urlparse(self.path)
                if parsed_path.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    try:
                        client = MongoClient(conn_str, serverSelectionTimeoutMS=5000)
                        # Verbindungscheck
                        client.admin.command('ping')
                        db_name = conn_str.rsplit('/', 1)[-1]
                        db = client[db_name]
                        collections = db.list_collection_names()
                    except Exception as e:
                        self.wfile.write(f"<h1>Connection error</h1><p>{html.escape(str(e))}</p>".encode('utf-8'))
                        return

                    html_content = f"<html><head><title>MongoDB Browser</title></head><body>"
                    html_content += f"<h1>MongoDB Database: {html.escape(db_name)}</h1>"

                    for coll in collections:
                        html_content += f"<h2>Collection: {html.escape(coll)}</h2><table border='1'>"
                        html_content += "<tr><th>Document (JSON)</th></tr>"

                        try:
                            cursor = db[coll].find().limit(50)
                            for doc in cursor:
                                json_doc = dumps(doc, indent=2)
                                html_content += f"<tr><td><pre>{html.escape(json_doc)}</pre></td></tr>"
                        except Exception as e:
                            html_content += f"<tr><td>Error reading collection: {html.escape(str(e))}</td></tr>"

                        html_content += "</table><br>"

                    html_content += "</body></html>"
                    self.wfile.write(html_content.encode('utf-8'))
                else:
                    self.send_error(404, "File not found.")

        def start_mongo_server(port, container, event):
            with socketserver.TCPServer(("", port), MongoRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_mongo_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not start within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening MongoDB browser at {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True
    
    if user_input.startswith("prcassandra "):
        from cassandra.cluster import Cluster
        from cassandra.query import SimpleStatement

        # Eingabeformat: host:port,keyspace
        conn_info = user_input[11:].strip()

        try:
            host_port, keyspace = conn_info.split(",")
            host, port = host_port.split(":")
            port = int(port)
        except Exception:
            print(f"[{timestamp()}] [ERROR] Invalid input format. Use: host:port,keyspace")
            return True

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class CassandraRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed_path = urllib.parse.urlparse(self.path)
                if parsed_path.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    try:
                        cluster = Cluster([host], port=port)
                        session = cluster.connect(keyspace)
                        tables = session.execute(
                            "SELECT table_name FROM system_schema.tables WHERE keyspace_name = %s", (keyspace,)
                        )
                        table_names = [row.table_name for row in tables]
                    except Exception as e:
                        self.wfile.write(f"<h1>Connection error</h1><p>{html.escape(str(e))}</p>".encode('utf-8'))
                        return

                    html_content = f"<html><head><title>Cassandra Browser</title></head><body>"
                    html_content += f"<h1>Cassandra Keyspace: {html.escape(keyspace)}</h1>"

                    for table in table_names:
                        html_content += f"<h2>Table: {html.escape(table)}</h2><table border='1'>"
                        try:
                            stmt = SimpleStatement(f"SELECT * FROM {table} LIMIT 50")
                            rows = session.execute(stmt)
                            col_names = rows.column_names
                            html_content += "<tr>" + "".join(f"<th>{html.escape(col)}</th>" for col in col_names) + "</tr>"
                            for row in rows:
                                html_content += "<tr>" + "".join(f"<td>{html.escape(str(getattr(row, col)))}</td>" for col in col_names) + "</tr>"
                        except Exception as e:
                            html_content += f"<tr><td colspan='100%'>Error reading table: {html.escape(str(e))}</td></tr>"
                        html_content += "</table><br>"

                    html_content += "</body></html>"
                    self.wfile.write(html_content.encode('utf-8'))
                else:
                    self.send_error(404, "File not found.")

        def start_cassandra_server(port, container, event):
            with socketserver.TCPServer(("", port), CassandraRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_cassandra_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not start within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening Cassandra browser at {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True

    if user_input.startswith("prcouchdb "):
        # Input format: http://user:pass@host:port
        base_url = user_input[10:].strip().rstrip("/")

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class CouchDBRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed_path = urllib.parse.urlparse(self.path)
                if parsed_path.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    try:
                        # Retrieve all databases
                        resp = requests.get(f"{base_url}/_all_dbs", timeout=5)
                        resp.raise_for_status()
                        dbs = resp.json()
                    except Exception as e:
                        self.wfile.write(f"<h1>Connection error</h1><p>{html.escape(str(e))}</p>".encode('utf-8'))
                        return

                    html_content = f"<html><head><title>CouchDB Browser</title></head><body>"
                    html_content += f"<h1>CouchDB Server: {html.escape(base_url)}</h1>"

                    for db in dbs:
                        html_content += f"<h2>Database: {html.escape(db)}</h2><table border='1'>"
                        html_content += "<tr><th>Document ID</th><th>Content (JSON)</th></tr>"

                        try:
                            docs_resp = requests.get(f"{base_url}/{db}/_all_docs?include_docs=true&limit=50", timeout=5)
                            docs_resp.raise_for_status()
                            docs = docs_resp.json().get('rows', [])
                            for doc in docs:
                                doc_id = doc.get('id', '')
                                doc_content = doc.get('doc', {})
                                json_doc = json.dumps(doc_content, indent=2)
                                html_content += f"<tr><td>{html.escape(doc_id)}</td><td><pre>{html.escape(json_doc)}</pre></td></tr>"
                        except Exception as e:
                            html_content += f"<tr><td colspan='2'>Error reading database: {html.escape(str(e))}</td></tr>"

                        html_content += "</table><br>"

                    html_content += "</body></html>"
                    self.wfile.write(html_content.encode('utf-8'))

                else:
                    self.send_error(404, "File not found.")

        def start_couchdb_server(port, container, event):
            with socketserver.TCPServer(("", port), CouchDBRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_couchdb_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening CouchDB Browser at: {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server running on port {actual_port}. Press 'q' to stop.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to exit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1 second...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after multiple attempts.")

        return True

    if user_input.startswith("prarangodb "):
        from arango import ArangoClient
        # Input format: http://user:pass@host:port
        conn_str = user_input[11:].strip().rstrip("/")

        # Parse the URL
        import re
        m = re.match(r"http://(?:(?P<user>[^:]+):(?P<pass>[^@]+)@)?(?P<host>[^:]+):(?P<port>\d+)", conn_str)
        if not m:
            print(f"[{timestamp()}] [ERROR] Invalid connection format. Use: http://user:pass@host:port")
            return True

        user = m.group("user")
        password = m.group("pass")
        host = m.group("host")
        port = int(m.group("port"))

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class ArangoRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed_path = urllib.parse.urlparse(self.path)
                if parsed_path.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    try:
                        client = ArangoClient(hosts=f"http://{host}:{port}")
                        sys_db = client.db('_system', username=user, password=password)

                        # Retrieve all databases
                        dbs = sys_db.databases()

                        html_content = f"<html><head><title>ArangoDB Browser</title></head><body>"
                        html_content += f"<h1>ArangoDB Server: {html.escape(host)}:{port}</h1>"

                        for db_name in dbs:
                            html_content += f"<h2>Database: {html.escape(db_name)}</h2>"
                            try:
                                db = client.db(db_name, username=user, password=password)
                                collections = db.collections()
                            except Exception as e:
                                html_content += f"<p>Error accessing database: {html.escape(str(e))}</p>"
                                continue

                            for coll in collections:
                                if coll['type'] not in (2, 3):  # Document and Edge collections
                                    continue
                                coll_name = coll['name']
                                html_content += f"<h3>Collection: {html.escape(coll_name)}</h3><table border='1'>"

                                try:
                                    docs = db.aql.execute(f"FOR doc IN {coll_name} LIMIT 50 RETURN doc")
                                    docs_list = list(docs)
                                    if not docs_list:
                                        html_content += "<tr><td>No documents</td></tr>"
                                    else:
                                        keys = docs_list[0].keys()
                                        html_content += "<tr>" + "".join(f"<th>{html.escape(k)}</th>" for k in keys) + "</tr>"
                                        for doc in docs_list:
                                            html_content += "<tr>" + "".join(f"<td>{html.escape(str(doc.get(k, '')))}</td>" for k in keys) + "</tr>"
                                except Exception as e:
                                    html_content += f"<tr><td colspan='100%'>Error reading collection: {html.escape(str(e))}</td></tr>"

                                html_content += "</table><br>"

                        html_content += "</body></html>"
                        self.wfile.write(html_content.encode('utf-8'))

                    except Exception as e:
                        self.wfile.write(f"<h1>Connection error</h1><p>{html.escape(str(e))}</p>".encode('utf-8'))
                else:
                    self.send_error(404, "File not found.")

        def start_arango_server(port, container, event):
            with socketserver.TCPServer(("", port), ArangoRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_arango_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening ArangoDB Browser at: {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server running on port {actual_port}. Press 'q' to stop.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to exit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1 second...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after multiple attempts.")

        return True
    
    if user_input.startswith("prneo4j "):
        from neo4j import GraphDatabase

        # Input format: bolt://user:pass@host:port or neo4j://user:pass@host:port
        conn_str = user_input[8:].strip()

        import re
        # Parse connection string like bolt://user:pass@host:port
        pattern = r'^(bolt|neo4j)://(?P<user>[^:]+):(?P<pass>[^@]+)@(?P<host>[^:]+):(?P<port>\d+)$'
        match = re.match(pattern, conn_str)
        if not match:
            print(f"[{timestamp()}] [ERROR] Invalid connection format. Use: bolt://user:pass@host:port")
            return True

        scheme = match.group(1)
        user = match.group('user')
        password = match.group('pass')
        host = match.group('host')
        port = int(match.group('port'))

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class Neo4jRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                if self.path != "/":
                    self.send_error(404, "File not found.")
                    return

                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()

                try:
                    uri = f"{scheme}://{host}:{port}"
                    driver = GraphDatabase.driver(uri, auth=(user, password))

                    with driver.session() as session:
                        # Get all node labels
                        labels = session.run("CALL db.labels() YIELD label RETURN label").values()
                        labels = [label[0] for label in labels]

                        html_content = f"<html><head><title>Neo4j Browser</title></head><body>"
                        html_content += f"<h1>Neo4j Server: {host}:{port}</h1>"

                        for label in labels:
                            html_content += f"<h2>Label: {html.escape(label)}</h2><table border='1'>"
                            # Get up to 50 nodes of this label and their properties
                            query = f"MATCH (n:`{label}`) RETURN n LIMIT 50"
                            result = session.run(query)
                            nodes = [record["n"] for record in result]

                            if not nodes:
                                html_content += "<tr><td>No nodes found</td></tr>"
                            else:
                                # Collect all property keys from the first node to create header
                                keys = set()
                                for node in nodes:
                                    keys.update(node.keys())
                                keys = sorted(keys)

                                html_content += "<tr>" + "".join(f"<th>{html.escape(k)}</th>" for k in keys) + "</tr>"

                                for node in nodes:
                                    html_content += "<tr>"
                                    for k in keys:
                                        val = node.get(k, "")
                                        html_content += f"<td>{html.escape(str(val))}</td>"
                                    html_content += "</tr>"

                            html_content += "</table><br>"

                        html_content += "</body></html>"
                        self.wfile.write(html_content.encode('utf-8'))

                    driver.close()

                except Exception as e:
                    self.wfile.write(f"<h1>Error</h1><p>{html.escape(str(e))}</p>".encode('utf-8'))

        def start_neo4j_server(port, container, event):
            with socketserver.TCPServer(("", port), Neo4jRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_neo4j_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening Neo4j Browser at: {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server running on port {actual_port}. Press 'q' to stop.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True
    
    if user_input.startswith("prorientdb "):
        from pyorient import OrientDB

        # Input format: host:port user password
        # Example: prorientdb 127.0.0.1:2424 root root_password
        parts = user_input[11:].strip().split()
        if len(parts) != 3:
            print(f"[{timestamp()}] [ERROR] Invalid input. Use: prorientdb host:port user password")
            return True

        host_port, user, password = parts
        if ':' not in host_port:
            print(f"[{timestamp()}] [ERROR] Invalid host:port format")
            return True
        host, port_str = host_port.split(':', 1)
        try:
            port = int(port_str)
        except ValueError:
            print(f"[{timestamp()}] [ERROR] Invalid port number")
            return True

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class OrientDBRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                if self.path != "/":
                    self.send_error(404, "File not found.")
                    return

                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()

                try:
                    client = OrientDB(host, port)
                    session_id = client.connect(user, password)

                    # List all databases (only local server databases)
                    # pyorient does not provide a direct method to list all DBs, so this is a limitation
                    # Instead, we try a default DB or ask user to specify DB name (simple approach here)
                    # For demo, we ask user to specify a database to explore:

                    # Just example with a fixed DB name, or you can extend to dynamic input
                    db_name = "demo"  # Change to your database name or extend to ask user

                    if not client.db_exists(db_name, pyorient.STORAGE_TYPE_PLOCAL):
                        self.wfile.write(f"<h1>Error</h1><p>Database '{db_name}' does not exist.</p>".encode('utf-8'))
                        return

                    client.db_open(db_name, user, password)

                    # Get classes (tables)
                    classes = client.command("SELECT FROM (SELECT expand(classes) FROM metadata:schema)")

                    html_content = f"<html><head><title>OrientDB Browser</title></head><body>"
                    html_content += f"<h1>OrientDB Database: {html.escape(db_name)}</h1>"

                    for cls in classes:
                        class_name = cls.oRecordData['name']
                        html_content += f"<h2>Class: {html.escape(class_name)}</h2><table border='1'>"

                        try:
                            records = client.command(f"SELECT FROM {class_name} LIMIT 50")
                            if not records:
                                html_content += "<tr><td>No records found</td></tr>"
                            else:
                                # Extract keys from first record
                                keys = records[0].oRecordData.keys()
                                html_content += "<tr>" + "".join(f"<th>{html.escape(k)}</th>" for k in keys) + "</tr>"

                                for rec in records:
                                    html_content += "<tr>" + "".join(
                                        f"<td>{html.escape(str(rec.oRecordData.get(k, '')))}</td>" for k in keys) + "</tr>"
                        except Exception as e:
                            html_content += f"<tr><td colspan='100%'>Error reading class: {html.escape(str(e))}</td></tr>"

                        html_content += "</table><br>"

                    html_content += "</body></html>"
                    self.wfile.write(html_content.encode('utf-8'))

                    client.db_close()
                    client.close()

                except Exception as e:
                    self.wfile.write(f"<h1>Connection error</h1><p>{html.escape(str(e))}</p>".encode('utf-8'))

        def start_orientdb_server(port, container, event):
            with socketserver.TCPServer(("", port), OrientDBRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_orientdb_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening OrientDB Browser at: {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server running on port {actual_port}. Press 'q' to stop.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True
    
    if user_input.startswith("prravendb "):
        from ravendb import DocumentStore

        # Input format: url database_name
        # Example: prravendb http://localhost:8080 Northwind
        parts = user_input[10:].strip().split(maxsplit=1)
        if len(parts) != 2:
            print(f"[{timestamp()}] [ERROR] Invalid input. Use: prravendb url database_name")
            return True

        url, database_name = parts

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class RavenDBRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                if self.path != "/":
                    self.send_error(404, "File not found.")
                    return

                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()

                try:
                    store = DocumentStore([url], database_name)
                    store.initialize()

                    with store.open_session() as session:
                        # Get all collections - RavenDB doesn't provide direct API for all collections
                        # Workaround: Query all documents' metadata to extract collections
                        # Here, query the system collection of documents metadata and extract collections
                        collections_query = "from @all_docs as doc select distinct(doc['@collection'])"
                        # Note: RavenDB Python client does not support raw queries easily,
                        # so we'll approximate by querying indexes or use a known list if available.
                        # For demo, we will assume user provides collection names or you extend this.
                        
                        # For simplicity, list a few collections manually or just try one:
                        collections = ["Employees", "Orders"]  # Replace or make dynamic as needed

                        html_content = f"<html><head><title>RavenDB Browser</title></head><body>"
                        html_content += f"<h1>RavenDB Database: {database_name}</h1>"

                        for coll in collections:
                            html_content += f"<h2>Collection: {html.escape(coll)}</h2><table border='1'>"

                            # Query up to 50 documents in collection
                            results = session.query(collection_name=coll).take(50).all()
                            if not results:
                                html_content += "<tr><td>No documents found</td></tr>"
                            else:
                                # Use dict keys from first document for columns
                                keys = set()
                                for doc in results:
                                    keys.update(doc.keys())
                                keys = sorted(keys)

                                html_content += "<tr>" + "".join(f"<th>{html.escape(k)}</th>" for k in keys) + "</tr>"

                                for doc in results:
                                    html_content += "<tr>" + "".join(f"<td>{html.escape(str(doc.get(k, '')))}</td>" for k in keys) + "</tr>"

                            html_content += "</table><br>"

                        html_content += "</body></html>"
                        self.wfile.write(html_content.encode('utf-8'))

                    store.dispose()

                except Exception as e:
                    self.wfile.write(f"<h1>Error</h1><p>{html.escape(str(e))}</p>".encode('utf-8'))

        def start_ravendb_server(port, container, event):
            with socketserver.TCPServer(("", port), RavenDBRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_ravendb_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url_local = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening RavenDB Browser at: {url_local}")
        webbrowser.open(url_local)
        print(f"[{timestamp()}] [INFO] Server running on port {actual_port}. Press 'q' to stop.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url_local, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url_local, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True
    
    if user_input.startswith("prdynamodb "):
        import boto3
        from botocore.exceptions import ClientError

        # Input format: aws_access_key aws_secret_key region
        # Example: prdynamodb AKIA... abc123... us-west-2
        parts = user_input[11:].strip().split()
        if len(parts) != 3:
            print(f"[{timestamp()}] [ERROR] Invalid input. Use: prdynamodb aws_access_key aws_secret_key region")
            return True

        aws_access_key, aws_secret_key, region = parts

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class DynamoDBRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                if self.path != "/":
                    self.send_error(404, "File not found.")
                    return

                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()

                try:
                    dynamodb = boto3.resource(
                        'dynamodb',
                        aws_access_key_id=aws_access_key,
                        aws_secret_access_key=aws_secret_key,
                        region_name=region
                    )

                    tables = list(dynamodb.tables.all())
                    html_content = f"<html><head><title>DynamoDB Browser</title></head><body>"
                    html_content += f"<h1>DynamoDB Tables in Region: {html.escape(region)}</h1>"

                    if not tables:
                        html_content += "<p>No tables found.</p>"
                    else:
                        for table in tables:
                            html_content += f"<h2>Table: {html.escape(table.name)}</h2><table border='1'>"
                            try:
                                # Scan up to 50 items from the table
                                response = table.scan(Limit=50)
                                items = response.get('Items', [])
                                if not items:
                                    html_content += "<tr><td>No items found</td></tr>"
                                else:
                                    # Collect all keys from items
                                    keys = set()
                                    for item in items:
                                        keys.update(item.keys())
                                    keys = sorted(keys)

                                    html_content += "<tr>" + "".join(f"<th>{html.escape(k)}</th>" for k in keys) + "</tr>"

                                    for item in items:
                                        html_content += "<tr>" + "".join(
                                            f"<td>{html.escape(str(item.get(k, '')))}</td>" for k in keys) + "</tr>"

                            except ClientError as e:
                                html_content += f"<tr><td colspan='100%'>Error reading table: {html.escape(str(e))}</td></tr>"

                            html_content += "</table><br>"

                    html_content += "</body></html>"
                    self.wfile.write(html_content.encode('utf-8'))

                except Exception as e:
                    self.wfile.write(f"<h1>Error</h1><p>{html.escape(str(e))}</p>".encode('utf-8'))

        def start_dynamodb_server(port, container, event):
            with socketserver.TCPServer(("", port), DynamoDBRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_dynamodb_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening DynamoDB Browser at: {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server running on port {actual_port}. Press 'q' to stop.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True

    if user_input.startswith("prvec "):
        filepath = os.path.abspath(user_input[6:].strip())

        if not os.path.isfile(filepath):
            print(f"[{timestamp()}] [ERROR] File '{filepath}' does not exist.")
            return True

        if not filepath.lower().endswith((".index", ".faiss", ".vecdb")):
            print(f"[{timestamp()}] [ERROR] Unsupported vector database file: '{filepath}'")
            return True

        try:
            index = faiss.read_index(filepath)
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Could not load FAISS index: {e}")
            return True

        num_vectors = index.ntotal
        dim = index.d

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class VectorDBRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                if self.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()
                    html_content = "<html><head><title>Vector DB Info</title></head><body>"
                    html_content += f"<h1>FAISS Vector Database</h1>"
                    html_content += f"<p><strong>File:</strong> {html.escape(os.path.basename(filepath))}</p>"
                    html_content += f"<p><strong>Total Vectors:</strong> {num_vectors}</p>"
                    html_content += f"<p><strong>Dimensions:</strong> {dim}</p>"
                    html_content += "</body></html>"
                    self.wfile.write(html_content.encode('utf-8'))
                else:
                    self.send_error(404, "Not Found")

        def start_vec_server(port, container, event):
            with socketserver.TCPServer(("", port), VectorDBRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_vec_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not start within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening vector database in browser: {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server is running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except (urllib.error.URLError, ConnectionRefusedError):
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True

    if user_input.startswith("prrel "):
        filepath = os.path.abspath(user_input[6:].strip())

        if not os.path.isfile(filepath):
            print(f"[{timestamp()}] [ERROR] File '{filepath}' does not exist.")
            return True

        if not filepath.lower().endswith((".sqlite", ".db")):
            print(f"[{timestamp()}] [ERROR] Unsupported relational DB file: '{filepath}'")
            return True

        try:
            conn = sqlite3.connect(filepath)
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
            tables = cursor.fetchall()
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Could not read database: {e}")
            return True
        finally:
            conn.close()

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class RelationalDBHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                if self.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    html_content = "<html><head><title>Relational Database</title></head><body>"
                    html_content += f"<h1>Relational Database Viewer</h1>"
                    html_content += f"<p><strong>File:</strong> {html.escape(os.path.basename(filepath))}</p>"
                    html_content += "<ul>"

                    try:
                        conn = sqlite3.connect(filepath)
                        cursor = conn.cursor()

                        for (table,) in tables:
                            html_content += f"<li><strong>Table:</strong> {html.escape(table)}<br>"
                            try:
                                cursor.execute(f"PRAGMA table_info({table});")
                                columns = cursor.fetchall()
                                html_content += "<ul><li>Columns:<ul>"
                                for col in columns:
                                    html_content += f"<li>{html.escape(col[1])} ({col[2]})</li>"
                                html_content += "</ul></li>"

                                cursor.execute(f"SELECT COUNT(*) FROM {table};")
                                count = cursor.fetchone()[0]
                                html_content += f"<li>Total Rows: {count}</li></ul></li><br>"
                            except Exception as e:
                                html_content += f"<li>Error reading table: {html.escape(str(e))}</li>"
                        conn.close()
                    except Exception as e:
                        html_content += f"<p>Error loading DB: {html.escape(str(e))}</p>"

                    html_content += "</ul></body></html>"
                    self.wfile.write(html_content.encode('utf-8'))
                else:
                    self.send_error(404, "Not Found")

        def start_rel_server(port, container, event):
            with socketserver.TCPServer(("", port), RelationalDBHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_rel_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not start within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening relational DB in browser: {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server is running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except (urllib.error.URLError, ConnectionRefusedError):
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True

    if user_input.startswith("prpandas "):
        filepath = os.path.abspath(user_input[9:].strip())

        if not os.path.isfile(filepath):
            print(f"[{timestamp()}] [ERROR] File '{filepath}' does not exist.")
            return True

        supported_extensions = (".csv", ".xlsx", ".xls", ".json", ".parquet")
        if not filepath.lower().endswith(supported_extensions):
            print(f"[{timestamp()}] [ERROR] Unsupported file type: '{filepath}'")
            return True

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        class PandasRequestHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed_path = urllib.parse.urlparse(self.path)
                if parsed_path.path == "/":
                    self.send_response(200)
                    self.send_header("Content-type", "text/html")
                    self.end_headers()

                    try:
                        # Datei einlesen
                        if filepath.endswith(".csv"):
                            df = pd.read_csv(filepath)
                        elif filepath.endswith((".xlsx", ".xls")):
                            df = pd.read_excel(filepath)
                        elif filepath.endswith(".json"):
                            df = pd.read_json(filepath)
                        elif filepath.endswith(".parquet"):
                            df = pd.read_parquet(filepath)
                        else:
                            raise ValueError("Unsupported file format")

                        # HTML-Ausgabe
                        html_content = "<html><head><title>Pandas Viewer</title></head><body>"
                        html_content += f"<h1>DataFrame Preview: {html.escape(os.path.basename(filepath))}</h1>"

                        df_preview = df.head(50)
                        html_content += df_preview.to_html(border=1, escape=True, index=False)

                        html_content += "</body></html>"
                        self.wfile.write(html_content.encode('utf-8'))

                    except Exception as e:
                        self.wfile.write(f"<h1>Error</h1><p>{html.escape(str(e))}</p>".encode('utf-8'))

                else:
                    self.send_error(404, "File not found.")

        def start_pandas_server(port, container, event):
            with socketserver.TCPServer(("", port), PandasRequestHandler) as httpd:
                container['port'] = httpd.server_address[1]
                event.set()
                httpd.serve_forever()

        server_thread = threading.Thread(
            target=start_pandas_server,
            args=(requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/"
        print(f"[{timestamp()}] [INFO] Opening DataFrame in browser: {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server is running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except (urllib.error.URLError, ConnectionRefusedError):
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True

    if user_input.startswith("prhtml "):
        filepath = os.path.abspath(user_input[7:].strip())

        if not os.path.isfile(filepath):
            print(f"[{timestamp()}] [ERROR] File '{filepath}' does not exist.")
            return True

        directory = os.path.dirname(filepath)
        filename = os.path.basename(filepath)

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        server_thread = threading.Thread(
            target=start_local_server,
            args=(directory, requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/{filename}"
        print(f"[{timestamp()}] [INFO] Opening '{filename}' in browser: {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server is running on port {actual_port}. Press 'q' to stop it.")

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        try:
            urllib.request.urlopen(url, timeout=1)
        except:
            pass

        server_thread.join(timeout=5)

        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True

    if user_input.startswith("prpdf "):
        # user_input erwartet: "prpdf <pfad_zur_pdf>"
        filepath = os.path.abspath(user_input[6:].strip())

        if not os.path.isfile(filepath):
            print(f"[{timestamp()}] [ERROR] File '{filepath}' does not exist.")
            return True

        if not filepath.lower().endswith(".pdf"):
            print(f"[{timestamp()}] [ERROR] File '{filepath}' is not a PDF.")
            return True

        directory = os.path.dirname(filepath)
        filename = os.path.basename(filepath)

        requested_port = 8000
        port_container = {}
        server_started_event = threading.Event()

        # Thread starten
        server_thread = threading.Thread(
            target=start_local_server,
            args=(directory, requested_port, port_container, server_started_event),
            daemon=True
        )
        server_thread.start()

        # Maximal 5 Sekunden auf den Start warten
        if not server_started_event.wait(timeout=5):
            print(f"[{timestamp()}] [ERROR] Server could not be started within 5 seconds.")
            return True

        actual_port = port_container.get('port')
        url = f"http://localhost:{actual_port}/{filename}"
        print(f"[{timestamp()}] [INFO] Opening PDF '{filename}' in browser: {url}")
        webbrowser.open(url)
        print(f"[{timestamp()}] [INFO] Server is running on port {actual_port}. Press 'q' to stop it.")

        # Warte-Schleife für Benutzereingabe
        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    # Hier shutdown() auf dem Server aufrufen
                    # Dazu brauchen wir eine Referenz auf das server-Objekt;
                    # wir könnten es in port_container ablegen, z. B. port_container['server'] = server
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        # Wir müssen das Shutdown-Signal senden. Da wir den Server-Instanz nicht direkt haben,
        # könnten wir den HTTP-Endpunkt selbst als „Trigger“ verwenden oder – besser –
        # speichern wir beim Erzeugen in port_container auch die server-Instanz:
        try:
            # Senden eines shut-down-Requests an eine speziell dafür eingerichtete URL
            # (falls man eine Route dafür definiert). Hier nutzen wir einfach server.shutdown().
            server = port_container.get('server')
            if server:
                server.shutdown()
        except Exception:
            pass

        # Auf das Ende des Threads warten
        server_thread.join(timeout=5)

        # Prüfen, ob die URL nicht mehr erreichbar ist
        for _ in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1s...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after retries.")

        return True

    if user_input.startswith("prmd "):
        import markdown
        from markdown.extensions.toc import TocExtension

        filepath = os.path.abspath(user_input[5:].strip())

        # Datei-Existenz prüfen
        if not os.path.isfile(filepath):
            print(f"[{timestamp()}] [ERROR] File '{filepath}' does not exist.")
            return True

        # Dateiendung prüfen
        if not filepath.lower().endswith(".md"):
            print(f"[{timestamp()}] [ERROR] File '{filepath}' is not a Markdown file (.md).")
            return True

        directory = os.path.dirname(filepath)
        filename = os.path.basename(filepath)

        requested_port = 8001  # Port for Markdown server

        class MarkdownRenderHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                if self.path == "/render":
                    md_path = os.path.join(directory, filename)
                    if os.path.isfile(md_path):
                        try:
                            with open(md_path, "r", encoding="utf-8") as f:
                                md_text = f.read()

                            html = markdown.markdown(
                                md_text,
                                extensions=[
                                    'extra',
                                    'codehilite',
                                    TocExtension(permalink=True)
                                ],
                                output_format='html5'
                            )

                            full_html = f"""<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>{filename}</title>
        <style>
            body {{ font-family: Arial, sans-serif; margin: 40px; }}
            pre code {{ background-color: #f4f4f4; padding: 10px; display: block; white-space: pre-wrap; }}
            code {{ font-family: monospace; }}
            h1, h2, h3 {{ border-bottom: 1px solid #ddd; }}
        </style>
    </head>
    <body>
    {html}
    </body>
    </html>"""

                            self.send_response(200)
                            self.send_header("Content-Type", "text/html; charset=utf-8")
                            self.end_headers()
                            try:
                                self.wfile.write(full_html.encode("utf-8"))
                            except ConnectionAbortedError:
                                # Client hat Verbindung abgebrochen, ignoriere
                                pass
                        except Exception as e:
                            self.send_error(500, f"Error rendering Markdown: {e}")
                    else:
                        self.send_error(404, "File not found")
                else:
                    super().do_GET()

        # Server-Objekt global, um Shutdown von außen zu ermöglichen
        httpd = None

        def run_markdown_server():
            nonlocal httpd
            with socketserver.TCPServer(("", requested_port), MarkdownRenderHandler) as server:
                httpd = server
                print(f"[{timestamp()}] [INFO] Markdown server running at http://localhost:{requested_port}/render")
                server.serve_forever()

        # Server-Thread als Daemon starten
        server_thread = threading.Thread(target=run_markdown_server, daemon=True)
        server_thread.start()

        url = f"http://localhost:{requested_port}/render"
        print(f"[{timestamp()}] [INFO] Opening Markdown file '{filename}' in browser: {url}")
        webbrowser.open(url)

        try:
            while True:
                user_cmd = input().strip()
                if user_cmd.lower() == 'q' or user_cmd.lower() == '\x11':
                    print(f"[{timestamp()}] [INFO] Stopping server...")
                    break
                else:
                    print(f"[{timestamp()}] [INFO] Invalid input. Press 'q' to quit.")
        except (KeyboardInterrupt, EOFError):
            print(f"\n[{timestamp()}] [INFO] Input interrupted. Stopping server...")

        # Warten, bis Server-Thread beendet ist
        server_thread.join(timeout=5)

        # Prüfen, ob Server wirklich offline ist
        for attempt in range(5):
            try:
                urllib.request.urlopen(url, timeout=1)
                print(f"[{timestamp()}] [INFO] URL still reachable, waiting 1 second...")
                time.sleep(1)
            except:
                print(f"[{timestamp()}] [INFO] URL is now offline.")
                break
        else:
            print(f"[{timestamp()}] [INFO] URL still reachable after multiple attempts.")

        return True

    if user_input.startswith("lua "):
        user_input = user_input[4:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"lua {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Lua\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("glue srlua.exe "):
        user_input = user_input[15:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"glue srlua.exe {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile your code with PyInstaller")
            print(f"[{timestamp()}] [INFO] Note the systkas: glue srlua.exe script.luac myprogram.exe\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("luac "):
        user_input = user_input[5:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"glue srlua.exe {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile your code with Glue")
            print(f"[{timestamp()}] [INFO] Note the systkas: luac script.luac myprogram.exe\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-lua "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"lua {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Lua\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pce-lua "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"glue srlua.exe {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile your code with Glue")
            print(f"[{timestamp()}] [INFO] Note the systkas: pce-lua script.luac myprogram.exe\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-lua "):
        script = user_input[7:].strip()

        # Remove .lua suffix if present
        if script.endswith(".lua"):
            script = script[:-4]

        # 1) Check if mobdebug (Lua remote debugger) is installed
        # Wir prüfen, ob 'mobdebug' verfügbar ist, indem wir lua versuchen, es zu require'n
        try:
            has_mobdebug = subprocess.run(
                [
                    "lua",
                    "-e",
                    "local status, _ = pcall(require, 'mobdebug'); if not status then os.exit(1) end"
                ],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            ).returncode == 0

            if not has_mobdebug:
                print(
                    f"[{timestamp()}] [INFO] mobdebug not found. Please install it via LuaRocks with `luarocks install mobdebug`.")
                return True
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error checking mobdebug: {e}", file=sys.stderr)
            return True

        # 2) Start debugging session with mobdebug
        # mobdebug funktioniert als remote Debugger, also muss das Skript mobdebug starten oder man startet es mit einem Debug-Launcher
        print(f"[{timestamp()}] [INFO] Starting Lua script {script}.lua with mobdebug.")

        # Wir starten lua mit mobdebug und dem Script; hier ein einfaches Beispiel mit mobdebug.start()
        cmd = [
            "lua",
            "-e",
            (
                    "local mobdebug = require('mobdebug'); mobdebug.start(); dofile('" + f"{script}.lua" + "')"
            )
        ]

        try:
            proc = subprocess.Popen(cmd)
            proc.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error running Lua debugger: {e}", file=sys.stderr)

        return True

    if user_input.startswith("tsc "):
        user_input = user_input[4:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"tsc {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Tsc\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-tsc "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"tsc {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Tsc\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("ts-node "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ts-node {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with TypeScript NodeJs\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("tsc "):
        user_input = user_input[4:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ts-node {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with TypeScript NodeJs\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-ts "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ts-node {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with TypeScript NodeJs\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("prts "):
        ts_path = user_input[5:].strip()
        ts_path = os.path.abspath(ts_path)

        if not os.path.isfile(ts_path):
            print(f"[{timestamp()}] [ERROR] File not found: {ts_path}")
            return True

        base, ext = os.path.splitext(ts_path)
        if ext.lower() != ".ts":
            print(f"[{timestamp()}] [ERROR] Unsupported extension '{ext}'. Expected a .ts file.")
            return True

        js_path = base + ".js"

        print(f"[{timestamp()}] [INFO] Compiling TypeScript file: {ts_path}")
        compile_command = f"tsc \"{ts_path}\""
        compile_proc = subprocess.run(compile_command, shell=True)

        if compile_proc.returncode != 0:
            print(f"[{timestamp()}] [ERROR] Compilation failed.")
            return True

        if not os.path.isfile(js_path):
            print(f"[{timestamp()}] [ERROR] Compiled JS file not found: {js_path}")
            return True

        print(f"[{timestamp()}] [INFO] Running compiled JS: {js_path}")
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        run_command_js = f"node \"{js_path}\""
        process = subprocess.Popen(
            run_command_js,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            shell=True,
            text=True
        )
        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Execution canceled by user.")
        return True

    if user_input.startswith("pc-typescript "):
        user_input = user_input[14:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ts-node {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with TypeScript NodeJs\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-ts "):
        script = user_input[6:].strip()

        # Remove .ts suffix if present
        if script.endswith(".ts"):
            script = script[:-3]

        # 1) Check if ts-node and typescript are installed
        try:
            # Prüfen ob ts-node installiert ist
            has_ts_node = subprocess.run(
                ["ts-node", "--version"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            ).returncode == 0

            # Prüfen ob typescript installiert ist
            has_typescript = subprocess.run(
                ["tsc", "--version"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            ).returncode == 0

            if not has_ts_node or not has_typescript:
                print(
                    f"[{timestamp()}] [INFO] ts-node or typescript not found, installing with `npm install -g ts-node typescript`…")
                subprocess.run(
                    ["npm", "install", "-g", "ts-node", "typescript"],
                    check=True
                )
                print(f"[{timestamp()}] [INFO] ts-node and typescript successfully installed.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error while installing ts-node/typescript: {e}", file=sys.stderr)
            return True

        # 2) Start debugging with Node.js Inspector via ts-node
        print(f"[{timestamp()}] [INFO] Starting TypeScript debugger for {script}.ts on port 9229")

        cmd = [
            "node",
            "--inspect-brk=9229",
            "-r",
            "ts-node/register",
            f"{script}.ts"
        ]

        try:
            proc = subprocess.Popen(cmd)
            proc.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error running TypeScript debugger: {e}", file=sys.stderr)

        return True

    if user_input.startswith("pd-typescript "):
        script = user_input[14:].strip()

        # Remove .ts suffix if present
        if script.endswith(".ts"):
            script = script[:-3]

        # 1) Check if ts-node and typescript are installed
        try:
            # Prüfen ob ts-node installiert ist
            has_ts_node = subprocess.run(
                ["ts-node", "--version"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            ).returncode == 0

            # Prüfen ob typescript installiert ist
            has_typescript = subprocess.run(
                ["tsc", "--version"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            ).returncode == 0

            if not has_ts_node or not has_typescript:
                print(
                    f"[{timestamp()}] [INFO] ts-node or typescript not found, installing with `npm install -g ts-node typescript`…")
                subprocess.run(
                    ["npm", "install", "-g", "ts-node", "typescript"],
                    check=True
                )
                print(f"[{timestamp()}] [INFO] ts-node and typescript successfully installed.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error while installing ts-node/typescript: {e}", file=sys.stderr)
            return True

        # 2) Start debugging with Node.js Inspector via ts-node
        print(f"[{timestamp()}] [INFO] Starting TypeScript debugger for {script}.ts on port 9229")

        cmd = [
            "node",
            "--inspect-brk=9229",
            "-r",
            "ts-node/register",
            f"{script}.ts"
        ]

        try:
            proc = subprocess.Popen(cmd)
            proc.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error running TypeScript debugger: {e}", file=sys.stderr)

        return True

    if user_input.startswith("kotlinc "):
        user_input = user_input[8:].strip()
        args = user_input.split()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Syntax: kotlinc <input.kt> <output.jar>")
            return True

        input_file, output_file = args
        command = f"kotlinc {input_file} -include-runtime -d {output_file}"

        try:
            print(f"[{timestamp()}] [INFO] Compiling {input_file} → {output_file}\n")
            process = subprocess.Popen(command, shell=True, stdin=sys.stdin,
                                       stdout=sys.stdout, stderr=sys.stderr, text=True)
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation canceled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Compilation failed: {e}")
        return True

    if user_input.startswith("kotlinc1 "):
        user_input = user_input[9:].strip()
        args = user_input.split()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        if len(args) != 2:
            print(f"[{timestamp()}] [ERROR] Syntax: kotlinc <input.kt> <output.jar>")
            return True

        input_file, output_file = args
        command = f"kotlinc {input_file} -include-runtime -d {output_file}"

        try:
            print(f"[{timestamp()}] [INFO] Compiling {input_file} → {output_file}\n")
            process = subprocess.Popen(command, shell=True, stdin=sys.stdin,
                                       stdout=sys.stdout, stderr=sys.stderr, text=True)
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Compilation canceled by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Compilation failed: {e}")
        return True

    if user_input.startswith("kotlinc2 "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"java -jar {user_input}"  # .jar

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Java\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("kotlinc3 "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"kotlinc -script {user_input}"  # .kts

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Kotlinc\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-kotlin "):
        user_input = user_input[10:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"kotlinc -script {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Kotlinc\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("swift "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"swift {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Swift\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-kotlin "):
        script = user_input[10:].strip()

        # Remove .kt suffix if present
        if script.endswith(".kt"):
            script = script[:-3]

        # 1) Check if kotlinc (Kotlin compiler) and kotlin runtime are installed
        try:
            has_kotlinc = subprocess.run(
                ["kotlinc", "-version"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            ).returncode == 0

            has_kotlin = subprocess.run(
                ["kotlin", "-version"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            ).returncode == 0

            if not has_kotlinc or not has_kotlin:
                print(
                    f"[{timestamp()}] [ERROR] Kotlin compiler or runtime not found. Please install Kotlin (https://kotlinlang.org/docs/command-line.html).")
                return True
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error checking Kotlin installation: {e}", file=sys.stderr)
            return True

        # 2) Compile Kotlin script to jar/class files
        jar_file = f"{script}.jar"
        try:
            print(f"[{timestamp()}] [INFO] Compiling Kotlin script {script}.kt to jar...")
            subprocess.run(
                ["kotlinc", f"{script}.kt", "-include-runtime", "-d", jar_file],
                check=True
            )
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Kotlin compilation failed: {e}", file=sys.stderr)
            return True

        # 3) Start debugger (using Java Debug Wire Protocol, JDWP)
        # Wir starten die JVM mit Debug-Optionen (port 5005, warten auf Debugger)
        print(f"[{timestamp()}] [INFO] Starting Kotlin debugger for {script}.kt on port 5005")

        cmd = [
            "java",
            "-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005",
            "-jar",
            jar_file
        ]

        try:
            proc = subprocess.Popen(cmd)
            proc.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error running Kotlin debugger: {e}", file=sys.stderr)

        return True

    if user_input.startswith("swiftc "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"swift {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile your code with Swift")
            print(f"[{timestamp()}] [INFO] Note the systkas: swiftc hello.swift -o hello.exe\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-swift "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"swift {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Swift\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-swift "):
        script = user_input[9:].strip()

        # Remove .swift suffix if present
        if script.endswith(".swift"):
            script = script[:-6]

        # 1) Check if swiftc (Swift compiler) is installed
        try:
            has_swiftc = subprocess.run(
                ["swiftc", "-version"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            ).returncode == 0

            if not has_swiftc:
                print(
                    f"[{timestamp()}] [ERROR] Swift compiler (swiftc) not found. Please install Swift from https://swift.org/download/")
                return True
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error checking swiftc installation: {e}", file=sys.stderr)
            return True

        # 2) Compile Swift script to executable
        executable = script
        try:
            print(f"[{timestamp()}] [INFO] Compiling Swift script {script}.swift...")
            subprocess.run(
                ["swiftc", f"{script}.swift", "-g", "-o", executable],
                check=True
            )
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Swift compilation failed: {e}", file=sys.stderr)
            return True

        # 3) Start debugger with lldb
        # lldb startet und stoppt direkt am Programmstart (suspend)
        print(f"[{timestamp()}] [INFO] Starting Swift debugger for {script}.swift with lldb")

        cmd = [
            "lldb",
            executable,
            "--",
            # Optional: hier können noch Programmargumente eingefügt werden
        ]

        try:
            proc = subprocess.Popen(cmd)
            proc.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error running lldb debugger: {e}", file=sys.stderr)

        return True

    if user_input.startswith("dart run "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"dart run {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Dart\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("dartc "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"dart run {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Dart")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-dart "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"dart run {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Dart\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-dart "):
        script = user_input[8:].strip()

        # Remove .dart suffix if present
        if script.endswith(".dart"):
            script = script[:-5]

        # 1) Check if dart SDK is installed
        try:
            has_dart = subprocess.run(
                ["dart", "--version"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            ).returncode == 0

            if not has_dart:
                print(f"[{timestamp()}] [ERROR] Dart SDK not found. Please install Dart from https://dart.dev/get-dart")
                return True
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error checking Dart installation: {e}", file=sys.stderr)
            return True

        # 2) Start Dart script in debug mode with Observatory (now Dart VM Service)
        # Standardmäßig läuft der Debugger auf Port 8181
        print(f"[{timestamp()}] [INFO] Starting Dart debugger for {script}.dart on port 8181")

        cmd = [
            "dart",
            "run",
            "--observe=8181",
            f"{script}.dart"
        ]

        try:
            proc = subprocess.Popen(cmd)
            proc.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error running Dart debugger: {e}", file=sys.stderr)

        return True

    if user_input.startswith("ghc "):
        user_input = user_input[4:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ghc {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Ghc")
            print(f"[{timestamp()}] [INFO] Note the systkas: ghc hello.hs -o hello.exe\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("ghci "):
        user_input = user_input[5:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ghci {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Ghci")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-haskell "):
        user_input = user_input[11:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ghci {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Ghci\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True
    
    if user_input.startswith("pd-haskell "):
        script = user_input[11:].strip()

        # Remove .go suffix if present
        if script.endswith(".go"):
            script = script[:-3]

        # 1) Check if Delve (dlv) debugger is installed
        try:
            has_dlv = subprocess.run(
                ["which", "dlv"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            ).returncode == 0

            if not has_dlv:
                print(
                    f"[{timestamp()}] [INFO] `dlv` (Delve debugger) not found, installing with `go install github.com/go-delve/delve/cmd/dlv@latest`…")
                subprocess.run(
                    ["go", "install", "github.com/go-delve/delve/cmd/dlv@latest"],
                    check=True
                )
                print(f"[{timestamp()}] [INFO] `dlv` successfully installed.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error while installing dlv: {e}", file=sys.stderr)
            return True

        # 2) Debug Go program with dlv
        # Annahme: ausführbare Datei heißt wie das Script ohne .go
        executable = script

        print(f"[{timestamp()}] [INFO] Starting Go debugger (dlv) for {executable}")
        try:
            # Build the binary first (debug build)
            subprocess.run(["go", "build", "-gcflags", "all=-N -l", "-o", executable, f"{script}.go"], check=True)

            # Start debugger in headless mode, listening on port 2345 (Standard)
            cmd = ["dlv", "exec", f"./{executable}", "--headless", "--listen=:2345", "--api-version=2",
                   "--accept-multiclient"]

            proc = subprocess.Popen(cmd)
            proc.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] Error running dlv: {e}", file=sys.stderr)

        return True

    if user_input.startswith("dotnet fsi "):
        user_input = user_input[11:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"dotnet fsi {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Dotnet Fsi\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-fs "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"dotnet fsi {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Dotnet Fsi\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("scalac "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"scalac {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Scalac\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-scala "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"scalac {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Scalac\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-scala "):
        user_input = user_input[9:].strip()

        if not user_input.endswith(".scala"):
            print(f"{timestamp()} [ERROR] Please provide a `.scala` file.")
            return True

        script_name = os.path.splitext(user_input)[0]  # ohne .scala
        class_name = script_name  # Standard-Annahme: Klassenname = Dateiname
        class_file = f"{class_name}.class"

        # 1. Check ob scalac und java vorhanden sind
        if which("scalac") is None:
            print(f"{timestamp()} [ERROR] `scalac` (Scala compiler) not found. Please install Scala.")
            return True
        if which("java") is None:
            print(f"{timestamp()} [ERROR] `java` not found. Please install JDK.")
            return True

        print(f"{timestamp()} [INFO] Compiling {user_input} with scalac...")

        # 2. Kompilieren
        compile_result = subprocess.run(
            ["scalac", user_input],
            stdin=subprocess.DEVNULL,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        if compile_result.returncode != 0:
            print(f"{timestamp()} [ERROR] Compilation failed:")
            print(compile_result.stderr)
            return True
        else:
            print(f"{timestamp()} [INFO] Compilation successful.")

        # 3. Start Debugging (Java JDWP)
        print(f"{timestamp()} [INFO] Launching Java Debugger for class: {class_name}")

        debug_command = [
            "java",
            "-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005",
            class_name
        ]

        try:
            proc = subprocess.Popen(debug_command)
            proc.wait()
        except KeyboardInterrupt:
            print(f"{timestamp()} [INFO] Debugging cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"{timestamp()} [ERROR] Error while running debugger: {e}", file=sys.stderr)

        return True

    if user_input.startswith("clj "):
        user_input = user_input[4:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"clj {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Clj\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-clj "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"clj {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Clj\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("ocamlc "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ocamlc {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile your code with ocamlc")
            print(f"[{timestamp()}] [INFO] Note the systkas: ocamlc hello.ml -o hello.exe\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-ocaml "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ocamlc {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile your code with ocamlc")
            print(f"[{timestamp()}] [INFO] Note the systkas: pc-ocaml hello.ml -o hello.exe\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-ocaml "):
        user_input = user_input[9:].strip()

        if not user_input.endswith(".ml"):
            print(f"{timestamp()} [ERROR] Please provide a `.ml` OCaml source file.")
            return True

        script_name = os.path.splitext(user_input)[0]  # ohne .ml
        bytecode_file = f"{script_name}.byte"

        # 1. Check ob ocamlc und ocamldebug vorhanden sind
        if which("ocamlc") is None:
            print(f"{timestamp()} [ERROR] `ocamlc` (OCaml bytecode compiler) not found. Please install OCaml.")
            return True
        if which("ocamldebug") is None:
            print(f"{timestamp()} [ERROR] `ocamldebug` not found. Please install OCaml Debugger.")
            return True

        print(f"{timestamp()} [INFO] Compiling {user_input} with ocamlc...")

        # 2. Kompilieren zu Bytecode (mit Debug-Info)
        compile_result = subprocess.run(
            ["ocamlc", "-g", "-o", bytecode_file, user_input],
            stdin=subprocess.DEVNULL,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        if compile_result.returncode != 0:
            print(f"{timestamp()} [ERROR] Compilation failed:")
            print(compile_result.stderr)
            return True
        else:
            print(f"{timestamp()} [INFO] Compilation successful.")

        # 3. Debug starten mit ocamldebug
        print(f"{timestamp()} [INFO] Launching OCaml Debugger for {bytecode_file}")

        try:
            proc = subprocess.Popen(["ocamldebug", bytecode_file])
            proc.wait()
        except KeyboardInterrupt:
            print(f"{timestamp()} [INFO] Debugging cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"{timestamp()} [ERROR] Error while running ocamldebug: {e}", file=sys.stderr)

        return True

    if user_input.startswith("elixir "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"elixir {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Elixir\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-elixir "):
        user_input = user_input[10:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"elixir {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Elixir\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-elixir "):
        user_input = user_input[10:].strip()

        if not user_input.endswith(".ex"):
            print(f"{timestamp()} [ERROR] Please provide a `.ex` Elixir source file.")
            return True

        script_name = os.path.splitext(user_input)[0]

        # 1. Prüfen ob elixir und iex vorhanden sind
        if which("elixir") is None:
            print(f"{timestamp()} [ERROR] `elixir` not found. Please install Elixir.")
            return True
        if which("iex") is None:
            print(f"{timestamp()} [ERROR] `iex` not found. Please install Elixir.")
            return True

        print(f"{timestamp()} [INFO] Launching Elixir Debugger with :debugger and {user_input}")

        # 2. Start Debug-Session in iex mit dem Modul
        debug_command = [
            "iex",
            "--erl", "-sdebugger",  # Start mit :debugger
            "-r", user_input  # Lade die Datei
        ]

        try:
            proc = subprocess.Popen(debug_command)
            proc.wait()
        except KeyboardInterrupt:
            print(f"{timestamp()} [INFO] Debugging cancelled by user.")
        except subprocess.CalledProcessError as e:
            print(f"{timestamp()} [ERROR] Error while running iex: {e}", file=sys.stderr)

        return True

    if user_input.startswith("elm make "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"elm make {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile your code with Elm Make ")
            print(f"[{timestamp()}] [INFO] Note the systkas: elm make src/Main.elm --output=main.js\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-elm "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"elm make {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile your code with Elm Make ")
            print(f"[{timestamp()}] [INFO] Note the systkas: pc-elm src/Main.elm --output=main.js\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-elm "):
        user_input = user_input[7:].strip()

        if not user_input.endswith(".elm"):
            print(f"{timestamp()} [ERROR] Please provide a `.elm` Elm source file.")
            return True

        script_name = os.path.splitext(user_input)[0]
        output_file = "elm_debug.html"

        # 1. Prüfen ob elm vorhanden ist
        if which("elm") is None:
            print(
                f"{timestamp()} [ERROR] `elm` not found. Please install Elm: https://guide.elm-lang.org/install/elm.html")
            return True

        print(f"{timestamp()} [INFO] Compiling {user_input} with elm in debug mode...")

        # 2. Kompilieren mit Debug-Modus
        compile_result = subprocess.run(
            ["elm", "make", user_input, "--output", output_file, "--debug"],
            stdin=subprocess.DEVNULL,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        if compile_result.returncode != 0:
            print(f"{timestamp()} [ERROR] Compilation failed:")
            print(compile_result.stderr)
            return True
        else:
            print(f"{timestamp()} [INFO] Compilation successful. Output: {output_file}")

        # 3. HTML im Browser öffnen
        print(f"{timestamp()} [INFO] Opening debug viewer in browser...")
        try:
            if sys.platform.startswith("win"):
                os.startfile(output_file)
            elif sys.platform == "darwin":
                subprocess.run(["open", output_file])
            else:
                subprocess.run(["xdg-open", output_file])
        except Exception as e:
            print(f"{timestamp()} [ERROR] Could not open browser: {e}")

        return True

    if user_input.startswith("v run "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"v run {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with V\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-v "):
        user_input = user_input[5:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"v run {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with V\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-v "):
        # 1) Argument auslesen
        user_input = user_input[5:].strip()
        if not user_input.endswith(".v"):
            print(f"{timestamp()} [ERROR] Please specify a `.v` file.")
            return True

        # Basisname (ohne .v) und Quelldatei
        script_name = os.path.splitext(user_input)[0]
        source_file = user_input
        executable = script_name  # V legt unter Linux/Mac das Binary standardmäßig auf den Basisnamen

        # 2) Prüfen, ob 'v' (Compiler) und 'gdb' (Debugger) verfügbar sind
        if which("v") is None:
            print(f"{timestamp()} [ERROR] `v` compiler not found. Please install V: https://vlang.io")
            return True
        if which("gdb") is None:
            print(
                f"{timestamp()} [ERROR] `gdb` (GNU Debugger) not found. Please install gdb (e.g., `sudo apt install gdb`).")
            return True

        # 3) Kompilieren mit Debug-Informationen
        print(f"{timestamp()} [INFO] Compiling {source_file} with debug info (v -g)...")
        compile_cmd = ["v", "-g", source_file]

        try:
            compile_proc = subprocess.run(
                compile_cmd,
                stdin=subprocess.DEVNULL,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
        except Exception as e:
            print(f"{timestamp()} [ERROR] Error starting the compiler: {e}", file=sys.stderr)
            return True

        if compile_proc.returncode != 0:
            print(f"{timestamp()} [ERROR] Compilation failed:")
            print(compile_proc.stderr.strip())
            return True
        else:
            print(f"{timestamp()} [INFO] Compilation successful. Binary file: {executable}")

        # 4) Debuggen mit gdb
        print(f"{timestamp()} [INFO] Start GNU Debugger (gdb) for {executable}...")
        # gdb erwartet in der Regel den Pfad zum Binärprogramm
        debug_cmd = ["gdb", "--args", f"./{executable}"]

        try:
            dbg_proc = subprocess.Popen(debug_cmd)
            dbg_proc.wait()
        except KeyboardInterrupt:
            print(f"{timestamp()} [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"{timestamp()} [ERROR] Error running gdb: {e}", file=sys.stderr)

        return True

    if user_input.startswith("zig build-exe "):
        user_input = user_input[14:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"zig build-exe {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Zig\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("zigc "):
        user_input = user_input[5:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"zig build-exe {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Zig\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-zig "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"zig build-exe {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Zig\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-zig "):
        # 1) Argument auslesen und überprüfen
        user_input = user_input[7:].strip()  # Entferne "pd-zig " (7 Zeichen)
        if not user_input.endswith(".zig"):
            print(f"{timestamp()} [ERROR] Please specify a `.zig` file.")
            return True

        source_file = user_input
        script_name = os.path.splitext(source_file)[0]  # Basisname ohne .zig
        executable = script_name  # Zig legt standardmäßig das Binary auf den Basisnamen

        # 2) Prüfen, ob 'zig' (Compiler) und 'gdb' (Debugger) verfügbar sind
        if which("zig") is None:
            print(
                f"{timestamp()} [ERROR] `zig` compiler not found. Please install Zig: https://ziglang.org/download/")
            return True
        if which("gdb") is None:
            print(
                f"{timestamp()} [ERROR] `gdb` (GNU Debugger) not found. Please install gdb (e.g., `sudo apt install gdb`).")
            return True

        # 3) Kompilieren mit Debug-Informationen (-g)
        print(f"{timestamp()} [INFO] Compile {source_file} with debug info (zig build-exe -g)...")
        compile_cmd = ["zig", "build-exe", "-g", source_file]
        try:
            compile_proc = subprocess.run(
                compile_cmd,
                stdin=subprocess.DEVNULL,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
        except Exception as e:
            print(f"{timestamp()} [ERROR] Error calling compiler: {e}", file=sys.stderr)
            return True

        if compile_proc.returncode != 0:
            print(f"{timestamp()} [ERROR] Compilation failed:")
            print(compile_proc.stderr.strip())
            return True
        else:
            print(f"{timestamp()} [INFO] Compilation successful. Binary file: {executable}")

        # 4) Debuggen mit gdb
        print(f"{timestamp()} [INFO] Start GNU Debugger (gdb) for {executable}...")
        debug_cmd = ["gdb", "--args", f"./{executable}"]
        try:
            dbg_proc = subprocess.Popen(debug_cmd)
            dbg_proc.wait()
        except KeyboardInterrupt:
            print(f"{timestamp()} [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"{timestamp()} [ERROR] Error running gdb: {e}", file=sys.stderr)

        return True

    if user_input.startswith("nim compile "):
        user_input = user_input[12:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"nim compile {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Nim\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("nimc "):
        user_input = user_input[5:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"nim compile {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Nim\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-nim "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"nim compile {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Nim\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-nim "):
        # 1) Argument (Dateiname) extrahieren und trimmen
        user_input = user_input[7:].strip()  # Entferne "pd-nim " (7 Zeichen)
        if not user_input.endswith(".nim"):
            print(f"{timestamp()} [ERROR] Please specify a `.nim` file.")
            return True

        source_file = user_input
        script_name = os.path.splitext(source_file)[0]  # Basisname ohne .nim

        # Unter Windows kann es nötig sein, .exe anzuhängen.
        # Hier belassen wir es zunächst plattformunabhängig als Basisname.
        executable = script_name

        # 2) Prüfen, ob 'nim' (Compiler) und 'gdb' (Debugger) verfügbar sind
        if which("nim") is None:
            print(
                f"{timestamp()} [ERROR] `nim` compiler not found. Please install Nim: https://nim-lang.org/install.html")
            return True
        if which("gdb") is None:
            print(
                f"{timestamp()} [ERROR] `gdb` (GNU Debugger) not found. Please install gdb (e.g., `sudo apt install gdb`).")
            return True

        # 3) Kompilieren mit Debug-Informationen
        print(f"{timestamp()} [INFO] Compile {source_file} with debug info (nim c -d:debug --debugger:native)...")
        compile_cmd = [
            "nim", "c",
            "-d:debug",  # Schalter, damit Nim mit Debug-Symbolen kompiliert
            "--debugger:native",  # Explizit den nativen Debugger (gdb/lldb) verwenden
            "-o:" + executable,  # Legt den Namen des Binaries fest
            source_file
        ]
        try:
            compile_proc = subprocess.run(
                compile_cmd,
                stdin=subprocess.DEVNULL,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
        except Exception as e:
            print(f"{timestamp()} [ERROR] Error calling Nim compiler: {e}", file=sys.stderr)
            return True

        if compile_proc.returncode != 0:
            print(f"{timestamp()} [ERROR] Compilation failed: ")
            # Zeige stderr vom Compiler an
            print(compile_proc.stderr.strip())
            return True
        else:
            print(f"{timestamp()} [INFO] Compilation successful. Binary file: {executable}")

        # 4) Debuggen mit gdb
        print(f"{timestamp()} [INFO] Start GNU Debugger (gdb) for {executable}...")
        debug_cmd = ["gdb", "--args", f"./{executable}"]
        try:
            dbg_proc = subprocess.Popen(debug_cmd)
            dbg_proc.wait()
        except KeyboardInterrupt:
            print(f"{timestamp()} [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"{timestamp()} [ERROR] Error running gdb: {e}", file=sys.stderr)

        return True

    if user_input.startswith("bazel run //explorer -- ./"):
        user_input = user_input[26:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"bazel run //explorer -- ./{user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Bazel\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("carbanc "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"bazel run //explorer -- ./{user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Bazel\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-carban "):
        user_input = user_input[10:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"bazel run //explorer -- ./{user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Bazel\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-carban "):
        # 1) Argument (Dateiname) extrahieren und trimmen
        user_input = user_input[len("pd-carban "):].strip()
        if not user_input.endswith(".carban"):
            print(f"{timestamp()} [ERROR] Please specify a `.carban` file.")
            return True

        source_file = user_input
        script_name = os.path.splitext(source_file)[0]  # Basisname ohne .carban
        executable = script_name  # Der Carban-Compiler sollte ein Binary mit demselben Basisnamen erzeugen

        # 2) Prüfen, ob 'carban' (Compiler) und 'gdb' (Debugger) verfügbar sind
        if which("carban") is None:
            print(f"{timestamp()} [ERROR] `carban` compiler not found."
                  f"Please install Carban from https://carban-lang.org/install or from your package manager.")
            return True
        if which("gdb") is None:
            print(f"{timestamp()} [ERROR] `gdb` (GNU Debugger) not found."
                  f"Please install gdb (e.g. `sudo apt install gdb`).")
            return True

        # 3) Kompilieren mit Debug-Informationen
        print(f"{timestamp()} [INFO] Compile {source_file} with debug info (carban compile -g)...")
        compile_cmd = [
            "carban", "compile",
            "-g",  # Schalter für Debug-Symbole (angommen)
            source_file,
            "-o", executable  # Legt den Namen des Ausgabebinaries fest
        ]
        try:
            compile_proc = subprocess.run(
                compile_cmd,
                stdin=subprocess.DEVNULL,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
        except Exception as e:
            print(f"{timestamp()} [ERROR] Error calling the Carban compiler: {e}", file=sys.stderr)
            return True

        if compile_proc.returncode != 0:
            print(f"{timestamp()} [ERROR] Compilation failed:")
            # Zeige stderr vom Compiler an
            for line in compile_proc.stderr.strip().splitlines():
                print(line)
            return True
        else:
            print(f"{timestamp()} [INFO] Compilation successful. Binary file: {executable}")

        # 4) Debuggen mit gdb
        print(f"{timestamp()} [INFO] Start GNU Debugger (gdb) for {executable}...")
        debug_cmd = ["gdb", "--args", f"./{executable}"]
        try:
            dbg_proc = subprocess.Popen(debug_cmd)
            dbg_proc.wait()
        except KeyboardInterrupt:
            print(f"{timestamp()} [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"{timestamp()} [ERROR] Error running gdb: {e}", file=sys.stderr)

        return True

    if user_input.startswith("solc --bin --abi "):
        user_input = user_input[17:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"solc --bin --abi {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Solc -> solc --bin --abi\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("solidityc "):
        user_input = user_input[10:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"solc --bin --abi {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Solc -> solc --bin --abi")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-solidity "):
        user_input = user_input[12:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"solc --bin --abi {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Solc -> solc --bin --abi\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-solidity "):
        # 1) Argument (Dateiname) extrahieren und trimmen
        user_input = user_input[len("pd-solidity "):].strip()
        if not user_input.endswith(".sol"):
            print(f"{timestamp()} [ERROR] Please specify a `.sol` file.")
            return True

        source_file = user_input
        script_name = os.path.splitext(source_file)[0]  # Basisname ohne .sol

        # 2) Prüfen, ob 'solc' (Solidity-Compiler) und 'evm' (EVM-Binary) verfügbar sind
        if which("solc") is None:
            print(
                f"{timestamp()} [ERROR] `solc` (Solidity compiler) not found."
                f"Please install Solidity (e.g. via `npm install -g solc` or from your package manager)."
            )
            return True
        if which("evm") is None:
            print(
                f"{timestamp()} [ERROR] `evm` (EVM interpreter from go-ethereum) not found."
                f"Please install go-ethereum (`geth`) or the `evm` binary separately."
            )
            return True

        # 3) Kompilieren mit solc → JSON-Output mit Bytecode
        print(f"{timestamp()} [INFO] Compile {source_file} (solc --combined-json bin)...")
        try:
            # Wir nutzen --combined-json bin, damit wir ein JSON erhalten, in dem alle Contracts enthalten sind
            proc = subprocess.run(
                ["solc", "--combined-json", "bin", source_file],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
        except Exception as e:
            print(f"{timestamp()} [ERROR] Error calling solc: {e}", file=sys.stderr)
            return True

        if proc.returncode != 0:
            print(f"{timestamp()} [ERROR] Compilation failed:")
            print(proc.stderr.strip())
            return True

        # 4) JSON parsen und ersten Contract-Bytecode extrahieren
        try:
            combined = json.loads(proc.stdout)
            # `contracts` ist ein Dictionary: "Dateiname.sol:ContractName" → { "bin": "<hex>" }
            contracts_dict = combined.get("contracts", {})
            if not contracts_dict:
                print(f"{timestamp()} [ERROR] Could not find any contracts in the output.")
                return True

            # Nimm den ersten Contract-Eintrag
            first_key = next(iter(contracts_dict))
            contract_data = contracts_dict[first_key]
            bytecode_hex = contract_data.get("bin", "")
            if not bytecode_hex:
                print(f"{timestamp()} [ERROR] Binary bytecode of the contract is empty.")
                return True
            # Prefix 0x, damit evm ihn richtig interpretiert
            bytecode = "0x" + bytecode_hex
        except json.JSONDecodeError as e:
            print(f"{timestamp()} [ERROR] Could not parse JSON output from solc: {e}", file=sys.stderr)
            return True

        print(f"{timestamp()} [INFO] Bytecode extracted (length: {len(bytecode_hex)} hex characters).")

        # 5) Bytecode temporär in eine Datei schreiben (evm akzeptiert auch direkten Hex-String, aber
        #    zur Übersicht speichern wir ihn kurz)
        try:
            tmp = tempfile.NamedTemporaryFile(prefix=f"{script_name}_", suffix=".hex", delete=False, mode="w",
                                              encoding="utf-8")
            tmp.write(bytecode_hex)
            tmp.flush()
            tmp.close()
            hex_file = tmp.name
        except Exception as e:
            print(f"{timestamp()} [ERROR] Could not create temporary hex file: {e}", file=sys.stderr)
            return True

        print(f"{timestamp()} [INFO] Bytecode written to temporary file: {hex_file}")

        # 6) Debuggen mit EVM-Interpreter
        print(f"{timestamp()} [INFO] Starting EVM interpreter in debug mode...")
        # evm --code <hex> --debug run
        # Wir übergeben hier direkt den Hex-String. Alternativ könnte man auch: ["evm", "--codefile", hex_file, "--debug", "run"]
        debug_cmd = ["evm", "--code", bytecode, "--debug", "run"]

        try:
            dbg_proc = subprocess.Popen(debug_cmd)
            dbg_proc.wait()
        except KeyboardInterrupt:
            print(f"{timestamp()} [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"{timestamp()} [ERROR] Error running evm: {e}", file=sys.stderr)
        finally:
            # 7) Aufräumen: temporäre Datei löschen
            try:
                os.remove(hex_file)
                print(f"{timestamp()} [INFO] Remove temporary file: {hex_file}")
            except Exception:
                # Swallow any deletion error silently
                pass

        return True

    if user_input.startswith("hhvm "):
        user_input = user_input[5:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"hhvm {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Hhvm\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("hackc "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"hhvm {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Hhvm\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-hack "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"hhvm {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Hhvm\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-hack "):
        # 1) Argument extrahieren und trimmen
        filename = user_input[len("pd-hack "):].strip()
        if not (filename.endswith(".hack") or filename.endswith(".php")):
            print(f"{timestamp()} [ERROR] Please specify a `.hack` or `.php` file that uses hack syntax.")
            return True

        # Basisname (z. B. "MyScript" von "MyScript.hack" oder "MyScript.php")
        base_name = os.path.splitext(filename)[0]

        # 2) Verfügbarkeit von hh_client und hhvm prüfen
        if which("hh_client") is None:
            print(f"{timestamp()} [ERROR] `hh_client` (hack type checker) not found."
                  f"Please install `hh_single_type_check` or HHVM with `hh_client`."
                  f"See: https://docs.hhvm.com/hack/getting-started/getting-started")
            return True
        if which("hhvm") is None:
            print(f"{timestamp()} [ERROR] `hhvm` not found. Please install HHVM: https://hhvm.com/")
            return True

        # 3) Typprüfung mit hh_client
        print(f"{timestamp()} [INFO] Starting type checking of `{filename}` with `hh_client check-file`...")
        try:
            # Wir nutzen `hh_client` im Check-File-Modus, um nur diese Datei zu prüfen
            # Achtung: hh_client erwartet in der Regel ein Projekt-Verzeichnis mit einer .hhconfig-Datei.
            # Wenn du nur eine einzelne Datei prüfen möchtest, kannst du hh_client mit --json nutzen und
            # das Verzeichnis deines Projekts übergeben (hier: aktuelles Verzeichnis ".").
            #
            # Beispiel: hh_client check-file --json . <pfad-zur-datei>
            proc = subprocess.run(
                ["hh_client", "check-file", "--json", ".", filename],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
        except Exception as e:
            print(f"{timestamp()} [ERROR] Could not start `hh_client`: {e}", file=sys.stderr)
            return True

        # 3a) Rückgabewert überprüfen
        if proc.returncode != 0:
            print(f"{timestamp()} [ERROR] Type check failed. hh_client reports:")
            # hh_client gibt sowohl auf stdout (JSON-Fehler) als auch stderr text aus – beides ausgeben
            if proc.stderr.strip():
                print(proc.stderr.strip())
            if proc.stdout.strip():
                print(proc.stdout.strip())
            print(f"{timestamp()} [INFO] Please correct the typos listed above before continuing.")
            return True
        else:
            print(f"{timestamp()} [INFO] Type check successful - no errors found in `{filename}`.")

        # 4) HHVM im Debug-Modus (DBGP) starten
        #
        # Wir wählen hier DBGP-Port 8080, Host 0.0.0.0 (Zugriff von lokalem Rechner).
        # IDEs (VS Code + Vdebug, PhpStorm, vim+Vdebug) können sich dann an diesen Port hängen.
        #
        # Wichtige HHVM-Ini-Einstellungen:
        #   - hhvm.debugger.enable = 1        (Debugging aktivieren)
        #   - hhvm.debugger.port = 8080       (Port, an dem HHVM auf Debug-Anfragen wartet)
        #   - hhvm.debugger.host = 0.0.0.0     (Host, an dem Debugger lauscht – 0.0.0.0 bedeutet „alle Schnittstellen“)
        #   - hhvm.idekey = "PHPSTORM" (oder ein anderer, den deine IDE erwartet)
        #
        # Beispielaufruf:
        #   hhvm \
        #    -c /dev/null \
        #    -d hhvm.debugger.enable=1 \
        #    -d hhvm.debugger.port=8080 \
        #    -d hhvm.debugger.host=0.0.0.0 \
        #    -d hhvm.idekey=VDEBUG \
        #    filename.hack
        #
        # Hinweis: -c /dev/null sorgt dafür, dass HHVM keine globale Konfiguration lädt und wir nur
        # die hier gesetzten Debug-Flags nutzen. Unter Windows kann -c NUL lauten, je nach Umgebung.
        #
        print(f"{timestamp()} [INFO] Starting HHVM in debug mode (DBGP) for `{filename}`...")
        hhvm_cmd = [
            "hhvm",
            "-c", "/dev/null",
            "-d", "hhvm.debugger.enable=1",
            "-d", "hhvm.debugger.port=8080",
            "-d", "hhvm.debugger.host=0.0.0.0",
            "-d", "hhvm.idekey=VDEBUG",
            filename
        ]

        # Unter Windows müsste -c auf NUL statt /dev/null zeigen:
        if os.name == "nt":
            hhvm_cmd[2] = "NUL"  # statt "/dev/null"

        try:
            dbg_proc = subprocess.Popen(hhvm_cmd)
            print(f"{timestamp()} [INFO] HHVM is running. Debugger is listening on port 8080."
                  f"Start your IDE with DBGP (IDEKEY=VDEBUG).")
            dbg_proc.wait()
        except KeyboardInterrupt:
            print(f"{timestamp()} [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"{timestamp()} [ERROR] Error running HHVM: {e}", file=sys.stderr)

        return True

    if user_input.startswith("crystal run "):
        user_input = user_input[12:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"crystal run {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Crystal\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("crystalc "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"crystal run {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Crystal\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-crystal "):
        user_input = user_input[11:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"crystal run {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Crystal\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-crystal "):
        # 1) Argument (Dateiname) extrahieren und trimmen
        filename = user_input[len("pd-crystal "):].strip()
        if not (filename.endswith(".cr") or filename.endswith(".crystal")):
            print(f"{timestamp()} [ERROR] Please specify a `.cr` or `.crystal` file.")
            return True

        # Basisname (z. B. "MyApp" von "MyApp.cr")
        base_name = os.path.splitext(filename)[0]

        # Unter Windows könnte Crystal ebenfalls .exe erzeugen, gegebenenfalls anpassen:
        executable = base_name
        if os.name == "nt":
            executable += ".exe"

        # 2) Verfügbarkeit von 'crystal' (Compiler) prüfen
        if which("crystal") is None:
            print(
                f"{timestamp()} [ERROR] `crystal` compiler not found. Please install Crystal: https://crystal-lang.org/install/")
            return True

        # 3) Kompilieren mit Debug-Info
        print(f"{timestamp()} [INFO] Compiling `{filename}` with debug information (`crystal build --debug`)…")
        compile_cmd = [
            "crystal",
            "build",
            "--debug",  # DWARF-Debug-Symbole einbetten
            "-o", executable,  # Ausgabename des Binaries
            filename
        ]
        try:
            compile_proc = subprocess.run(
                compile_cmd,
                stdin=subprocess.DEVNULL,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
        except Exception as e:
            print(f"{timestamp()} [ERROR] Error calling the Crystal compiler: {e}", file=sys.stderr)
            return True

        if compile_proc.returncode != 0:
            print(f"{timestamp()} [ERROR] Compilation failed: ")
            if compile_proc.stderr:
                print(compile_proc.stderr.strip())
            return True
        else:
            print(f"{timestamp()} [INFO] Compilation successful. Binary file: `{executable}`")

        # 4) Prüfen, ob 'gdb' oder 'lldb' verfügbar sind (priorisiere gdb, fallback lldb)
        debugger = None
        if which("gdb") is not None:
            debugger = "gdb"
        elif which("lldb") is not None:
            debugger = "lldb"
        else:
            print(f"{timestamp()} [ERROR] Neither `gdb` nor `lldb` found."
                  f"Please install a native debugger (e.g. `gdb` or `lldb`).")
            return True

        # 5) Debuggen starten
        if debugger == "gdb":
            print(f"{timestamp()} [INFO] Start GNU Debugger (gdb) for `{executable}`…")
            debug_cmd = ["gdb", "--args", f"./{executable}"]
        else:
            print(f"{timestamp()} [INFO] Start LLVM Debugger (lldb) for `{executable}`…")
            debug_cmd = ["lldb", f"./{executable}"]

        try:
            dbg_proc = subprocess.Popen(debug_cmd)
            dbg_proc.wait()
        except KeyboardInterrupt:
            print(f"{timestamp()} [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"{timestamp()} [ERROR] Error running debugger ({debugger}): {e}", file=sys.stderr)

        return True

    if user_input.startswith("haxe -main "):
        user_input = user_input[11:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"haxe -main {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile your code with Haxe")
            print(f"[{timestamp()}] [INFO] Note the systkas: haxe -main Hello -js hello.js\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("haxec "):
        user_input = user_input[6:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"haxe -main {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile your code with Haxe")
            print(f"[{timestamp()}] [INFO] Note the systkas: haxec Hello -js hello.js\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-haxe "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"haxe -main {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile your code with Haxe")
            print(f"[{timestamp()}] [INFO] Note the systkas: pc-haxe Hello -js hello.js\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pd-haxe "):
        # 1) Argument (Dateiname) extrahieren und trimmen
        filename = user_input[len("pd-haxe "):].strip()
        if not filename.endswith(".hx"):
            print(f"{timestamp()} [ERROR] Please specify a `.hx` file.")
            return True

        # Basisname (z. B. "Main" von "Main.hx")
        base_name = os.path.splitext(filename)[0]

        # 3) Prüfen, ob 'haxe' (Compiler) vorhanden ist
        if which("haxe") is None:
            print(
                f"{timestamp()} [ERROR] `haxe` compiler not found. Please install Haxe: https://haxe.org/download/")
            return True

        # 4) Prüfen, ob 'gdb' oder 'lldb' (Debugger) vorhanden sind
        debugger = None
        if which("gdb") is not None:
            debugger = "gdb"
        elif which("lldb") is not None:
            debugger = "lldb"
        else:
            print(
                f"{timestamp()} [ERROR] Neither `gdb` nor `lldb` was found. Please install a native debugger (e.g. `gdb` or `lldb`).")
            return True

        # 4) Kompilieren mit Debug-Informationen in C++
        print(f"{timestamp()} [INFO] Compiling `{filename}` with debug info (haxe → C++ via hxcpp)…")
        # Befehl: haxe -main <base_name> -cpp bin --debug
        compile_cmd = [
            "haxe",
            "-main", base_name,
            "-cpp", "bin",
            "--debug"
        ]
        try:
            compile_proc = subprocess.run(
                compile_cmd,
                stdin=subprocess.DEVNULL,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
        except Exception as e:
            print(f"{timestamp()} [ERROR] Error calling the Haxe compiler: {e}", file=sys.stderr)
            return True

        if compile_proc.returncode != 0:
            print(f"{timestamp()} [ERROR] Haxe compilation failed:")
            if compile_proc.stderr:
                print(compile_proc.stderr.strip())
            return True
        else:
            print(f"{timestamp()} [INFO] Haxe generation successful. Switching to `bin/` to build...")

        # 5) In das Verzeichnis 'bin' wechseln und 'make' ausführen
        bin_dir = os.path.join(os.getcwd(), "bin")
        if not os.path.isdir(bin_dir):
            print(
                f"{timestamp()} [ERROR] Directory `bin/` not found after generating HAXE. Is hxcpp installed and configured?")
            return True

        # Unter macOS kann das Executable später die Endung ".app" haben; wir gehen erst vom Standard aus.
        os.chdir(bin_dir)
        print(f"{timestamp()} [INFO] Run `make` in the `bin/` directory to build the native binary…")
        try:
            make_proc = subprocess.run(
                ["make"],
                stdin=subprocess.DEVNULL,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
        except Exception as e:
            print(f"{timestamp()} [ERROR] Error running `make`: {e}", file=sys.stderr)
            os.chdir("..")
            return True

        if make_proc.returncode != 0:
            print(f"{timestamp()} [ERROR] Build with `make` failed:")
            if make_proc.stderr:
                print(make_proc.stderr.strip())
            os.chdir("..")
            return True
        else:
            print(f"{timestamp()} [INFO] Build successful. Switch back to the root directory...")
            os.chdir("..")

        # 6) Debugger aufrufen
        # Unter Linux/macOS befindet sich das Binary meist direkt in bin/<base_name>
        # Unter Windows: bin\<base_name>.exe
        if os.name == "nt":
            executable_path = os.path.join("bin", base_name + ".exe")
        else:
            executable_path = os.path.join("bin", base_name)

        if not os.path.isfile(executable_path):
            print(
                f"{timestamp()} [ERROR] Executable `{executable_path}` not found. Build may have failed.")
            return True

        # 7) Debuggen starten
        if debugger == "gdb":
            print(f"{timestamp()} [INFO] Start GNU Debugger (gdb) for `{executable_path}`…")
            debug_cmd = ["gdb", "--args", executable_path]
        else:
            print(f"{timestamp()} [INFO] Start LLVM Debugger (lldb) for `{executable_path}`…")
            debug_cmd = ["lldb", executable_path]

        try:
            dbg_proc = subprocess.Popen(debug_cmd)
            dbg_proc.wait()
        except KeyboardInterrupt:
            print(f"{timestamp()} [INFO] Debugging aborted by user.")
        except subprocess.CalledProcessError as e:
            print(f"{timestamp()} [ERROR] Error running debugger ({debugger}): {e}", file=sys.stderr)

        return True

    if user_input.startswith("gfortran -o "):
        user_input = user_input[12:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"gfortran -o {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile your code with Gfortran")
            print(f"[{timestamp()}] [INFO] Note the systkas: gfortran -o hello hello.f90")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("ifort -o "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"ifort -o {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile your code with Ifort")
            print(f"[{timestamp()}] [INFO] Note the systkas: ifort -o hello hello.f90\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-fortran "):
        user_input = user_input[11:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"gfortran -o {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile your code with Gfortran")
            print(f"[{timestamp()}] [INFO] Note the systkas: pc-fortran hello hello.f90\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("sbcl --script "):
        user_input = user_input[14:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"sbcl --script {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Sbcl\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-lisp "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"sbcl --script {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Sbcl\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("racket "):
        user_input = user_input[7:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"racket {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Racket\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("racketc "):
        user_input = user_input[8:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"racket {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Racket\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-racket "):
        user_input = user_input[10:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"racket {user_input}"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Racket\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc command: {e}")
        return True

    if user_input.startswith("pc-algol "):
        user_input = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        # Compile the Algol60 source code
        compile_command = "wsl gcc algol60.c -o algol60"
        compile_process = subprocess.Popen(compile_command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                           shell=True, text=True)

        # Execute the compiled program with arguments
        command_3 = f"./algol60 {user_input}"
        run_process = subprocess.Popen(command_3, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                       text=True)

        try:
            print(f"[{timestamp()}] [INFO] Compile {user_input} with Gcc\n")
            compile_process.wait()
            run_process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing command: {e}")

        return True

    if user_input.startswith("pcf "):
        user_input = user_input[4:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        current_dir = Path.cwd().resolve()

        command = f"""powershell New-Item -Path "{current_dir}\\{user_input}"  -ItemType File"""

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] File created: {current_dir}\\{user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pcfo "):
        user_input = user_input[5:].strip()
        current_dir = Path.cwd().resolve()
        folder_path = current_dir / user_input

        if folder_path.exists():
            print(f"[{timestamp()}] [INFO] Folder already exists: {folder_path}")
        else:
            command = f'mkdir "{user_input}"'  # In Anführungszeichen für Leerzeichen-Support

            try:
                process = subprocess.Popen(
                    command,
                    stdin=sys.stdin,
                    stdout=sys.stdout,
                    stderr=sys.stderr,
                    shell=True,
                    text=True
                )
                process.wait()

                # Prüfen, ob mkdir erfolgreich war (Ordner jetzt existiert)
                if folder_path.exists():
                    print(f"[{timestamp()}] [INFO] Folder created: {folder_path}")
                else:
                    print(f"[{timestamp()}] [ERROR] Folder creation failed: {folder_path}")
            except KeyboardInterrupt:
                print(f"[{timestamp()}] [INFO] Cancellation by user.")
            except subprocess.CalledProcessError as e:
                print(f"[{timestamp()}] [ERROR] executing mkdir command: {e}")
        # Ende des pcfo-Kommandos
        return True

    if user_input.startswith("pcfo&cd "):
        folder_name = user_input[8:].strip()
        current_dir = Path.cwd().resolve()
        new_folder_path = current_dir / folder_name

        if new_folder_path.exists():
            print(f"[{timestamp()}] [INFO] Folder already exists: {new_folder_path}")
        else:
            try:
                new_folder_path.mkdir(parents=True, exist_ok=False)
                print(f"[{timestamp()}] [INFO] Folder created: {new_folder_path}")
            except Exception as e:
                print(f"[{timestamp()}] [ERROR] Could not create folder: {e}")
                return False

        # Change directory
        try:
            change_directory(new_folder_path)
            print(f"[{timestamp()}] [INFO] Changed directory to: {new_folder_path}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error changing directory: {e}")
            return False

        # Environment handling
        found = find_env_in_current_dir()
        saved = load_saved_env()

        if found:
            if found != saved:
                save_current_env(found)
            return found
        else:
            return saved if saved else str(Path(DEFAULT_ENV_DIR).resolve())

        return False

    if user_input.startswith("pcfo&pcd "):
        folder_name = user_input[8:].strip()
        current_dir = Path.cwd().resolve()
        new_folder_path = current_dir / folder_name

        if new_folder_path.exists():
            print(f"[{timestamp()}] [INFO] Folder already exists: {new_folder_path}")
        else:
            try:
                new_folder_path.mkdir(parents=True, exist_ok=False)
                print(f"[{timestamp()}] [INFO] Folder created: {new_folder_path}")
            except Exception as e:
                print(f"[{timestamp()}] [ERROR] Could not create folder: {e}")
                return False

        # Change directory
        try:
            change_directory(new_folder_path)
            print(f"[{timestamp()}] [INFO] Changed directory to: {new_folder_path}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error changing directory: {e}")
            return False

        # Environment handling
        found = find_env_in_current_dir()
        saved = load_saved_env()

        if found:
            if found != saved:
                save_current_env(found)
            return found
        else:
            return saved if saved else str(Path(DEFAULT_ENV_DIR).resolve())

        return False

    # pc-postgresql: startet einen PostgreSQL-Dienst (Service-Name muss als Argument angegeben werden)
    # Beispiel-Aufruf: "pc-postgresql postgresql-x64-15"
    if user_input.startswith("pc-postgresql "):
        service_name = user_input[14:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f'net start "{service_name}"'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Starting PostgreSQL service '{service_name}'\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc-postgresql command: {e}")
        return True

    # pc-mysql: startet einen MySQL-/MariaDB-Dienst (Service-Name muss als Argument angegeben werden)
    # Beispiel-Aufruf: "pc-mysql MySQL80" oder "pc-mysql MySQL"
    if user_input.startswith("pc-mysql "):
        service_name = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f'net start "{service_name}"'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Starting MySQL service '{service_name}'\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc-mysql command: {e}")
        return True

    # pc-mongodb: startet einen MongoDB-Dienst (Service-Name muss als Argument angegeben werden)
    # Beispiel-Aufruf: "pc-mongodb MongoDB"
    if user_input.startswith("pc-mongodb "):
        service_name = user_input[11:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f'net start "{service_name}"'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Starting MongoDB service '{service_name}'\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc-mongodb command: {e}")
        return True

    # pc-sqlserver: startet einen Microsoft SQL Server-Dienst (Service-Name muss als Argument angegeben werden)
    # Beispiel-Aufruf: "pc-sqlserver MSSQLSERVER"
    if user_input.startswith("pc-sqlserver "):
        service_name = user_input[13:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f'net start "{service_name}"'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Starting SQL Server service '{service_name}'\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc-sqlserver command: {e}")
        return True

    # pc-service-stop: stoppt einen beliebigen Windows-Dienst (Service-Name muss als Argument angegeben werden)
    # Beispiel-Aufruf: "pc-service-stop postgresql-x64-15"
    if user_input.startswith("pc-service-stop "):
        service_name = user_input[16:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f'net stop "{service_name}"'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Stopping service '{service_name}'\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc-service-stop command: {e}")
        return True

    # pc-mariadb: startet einen MariaDB-Dienst (Service-Name angeben)
    # Beispiel: "pc-mariadb MariaDB"
    if user_input.startswith("pc-mariadb "):
        service_name = user_input[11:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f'net start "{service_name}"'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Starting MariaDB service '{service_name}'\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc-mariadb command: {e}")
        return True

    # pc-redis: startet einen Redis-Dienst (Service-Name angeben)
    # Beispiel: "pc-redis Redis"
    if user_input.startswith("pc-redis "):
        service_name = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f'net start "{service_name}"'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Starting Redis service '{service_name}'\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc-redis command: {e}")
            
    # pc-oracle: startet einen Oracle XE-Dienst (Service-Name angeben)
    # Beispiel: "pc-oracle OracleServiceXE"
    if user_input.startswith("pc-oracle "):
        service_name = user_input[10:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f'net start "{service_name}"'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Starting Oracle service '{service_name}'\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc-oracle command: {e}")
        return True

    # pc-couchdb: startet einen CouchDB-Dienst (Service-Name angeben)
    # Beispiel: "pc-couchdb ApacheCouchDB"
    if user_input.startswith("pc-couchdb "):
        service_name = user_input[11:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f'net start "{service_name}"'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Starting CouchDB service '{service_name}'\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc-couchdb command: {e}")
        return True

    # pc-firebird: startet einen Firebird-Dienst (Service-Name angeben)
    # Beispiel: "pc-firebird FirebirdGuardianDefaultInstance"
    if user_input.startswith("pc-firebird "):
        service_name = user_input[12:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f'net start "{service_name}"'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Starting Firebird service '{service_name}'\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc-firebird command: {e}")
        return True

    # pc-cassandra: startet einen Cassandra-Dienst (Service-Name angeben)
    # Beispiel: "pc-cassandra Apache Cassandra"
    if user_input.startswith("pc-cassandra "):
        service_name = user_input[13:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f'net start "{service_name}"'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Starting Cassandra service '{service_name}'\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc-cassandra command: {e}")
        return True

    # pc-elasticsearch: startet einen Elasticsearch-Dienst (Service-Name angeben)
    # Beispiel: "pc-elasticsearch elasticsearch-service-x64"
    if user_input.startswith("pc-elasticsearch "):
        service_name = user_input[16:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f'net start "{service_name}"'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Starting Elasticsearch service '{service_name}'\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc-elasticsearch command: {e}")
        return True

    # pc-neo4j: startet einen Neo4j-Dienst (Service-Name angeben)
    # Beispiel: "pc-neo4j neo4j"
    if user_input.startswith("pc-neo4j "):
        service_name = user_input[9:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f'net start "{service_name}"'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Starting Neo4j service '{service_name}'\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc-neo4j command: {e}")
        return True

    # pc-influxdb: startet einen InfluxDB-Dienst (Service-Name angeben)
    # Beispiel: "pc-influxdb influxdb"
    if user_input.startswith("pc-influxdb "):
        service_name = user_input[12:].strip()
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        command = f'net start "{service_name}"'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Starting InfluxDB service '{service_name}'\n")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pc-influxdb command: {e}")
        return True

    if user_input.startswith("jup "):
        if user_input.lower() == "jup q":
            print(f"[{timestamp()}] [INFO] Terminated by 'q'")
            shutdown_jupyter_kernel()
            return True
        if user_input == "jup \x11":  # Ctrl + Q
            print(f"[{timestamp()}] [INFO] Terminated by Ctrl + Q")
            shutdown_jupyter_kernel()
            return True

        file_input = user_input[4:].strip()

        if file_input.endswith(".jup"):
            file_input = file_input[:-4] + ".ipynb"

        try:
            file_path = Path(file_input).resolve()
            file_path.parent.mkdir(parents=True, exist_ok=True)

            # Notebook anlegen, falls nicht vorhanden
            if not file_path.exists():
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write("""{
             "cells": [],
             "metadata": {},
             "nbformat": 4,
             "nbformat_minor": 2
            }""")

            # Aktive Umgebung laden
            json_path = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/current_env.json")
            with open(json_path, 'r') as file:
                data = json.load(file)
                active_env_path = data.get("active_env")

            if not active_env_path:
                print(f"[{timestamp()}] [ERROR] No active environment found.")
                shutdown_jupyter_kernel()
                return True

            active_env = Path(active_env_path)
            python_exe = active_env / "Scripts" / "python.exe"

            fixed_python = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/.env/Scripts/python.exe")
            if not fixed_python.exists():
                print(f"[{timestamp()}] [ERROR] Fixed Python interpreter for Jupyter not found: {fixed_python}")
                shutdown_jupyter_kernel()
                return True

            # Prüfen, ob ipykernel installiert ist
            print(f"[{timestamp()}] [INFO] Checking ipykernel in the active environment...")
            result = subprocess.run([str(python_exe), "-m", "pip", "show", "ipykernel"], capture_output=True, text=True)

            kernel_name = f"venv_{active_env.name}_kernel"

            if result.returncode != 0:
                print(f"[{timestamp()}] [INFO] ipykernel not found. Installing ipykernel...")
                subprocess.run([str(python_exe), "-m", "pip", "install", "ipykernel"], check=True)
                print(f"[{timestamp()}] [INFO] ipykernel installed.")

                subprocess.run([
                    str(python_exe), "-m", "ipykernel", "install",
                    "--user",
                    "--name", kernel_name,
                    "--display-name", f"Python (venv: {active_env.name})"
                ], check=True)

            # Notebook mit korrektem Kernel verknüpfen
            set_kernel_in_notebook(
                notebook_path=file_path,
                kernel_name=kernel_name,
                display_name=f"Python (venv: {active_env.name})"
            )

            # Jupyter starten
            proc = subprocess.Popen([str(fixed_python), "-m", "notebook", str(file_path)])

            time.sleep(5)

            url_path = file_path.relative_to(Path.cwd()).as_posix()
            webbrowser.open_new(f"http://localhost:8888/notebooks/{url_path}")

            print(
                f"[{timestamp()}] [INFO] Started Jupyter Notebook with kernel '{kernel_name}'. Waiting for it to close...")

            proc.wait()

            print(f"[{timestamp()}] [INFO] Jupyter Notebook has been closed. Continuing...")

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] An error occurred: {e}")
            shutdown_jupyter_kernel()
            return True

        return True

    if user_input.startswith("prj "):
        if user_input.lower() == "prj q":
            print(f"[{timestamp()}] [INFO] Terminated by 'q'")
            shutdown_jupyter_kernel()
            return True
        if user_input == "prj \x11":  # Ctrl + Q
            print(f"[{timestamp()}] [INFO] Terminated by Ctrl + Q")
            shutdown_jupyter_kernel()
            return True

        file_input = user_input[4:].strip()

        if file_input.endswith(".jup"):
            file_input = file_input[:-4] + ".ipynb"

        if file_input.endswith(".pj"):
            file_input = file_input[:-4] + ".ipynb"

        try:
            file_path = Path(file_input).resolve()
            file_path.parent.mkdir(parents=True, exist_ok=True)

            # Notebook anlegen, falls nicht vorhanden
            if not file_path.exists():
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write("""{
             "cells": [],
             "metadata": {},
             "nbformat": 4,
             "nbformat_minor": 2
            }""")

            # Aktive Umgebung laden
            json_path = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/current_env.json")
            with open(json_path, 'r') as file:
                data = json.load(file)
                active_env_path = data.get("active_env")

            if not active_env_path:
                print(f"[{timestamp()}] [ERROR] No active environment found.")
                shutdown_jupyter_kernel()
                return True

            active_env = Path(active_env_path)
            python_exe = active_env / "Scripts" / "python.exe"

            fixed_python = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/.env/Scripts/python.exe")
            if not fixed_python.exists():
                print(f"[{timestamp()}] [ERROR] Fixed Python interpreter for Jupyter not found: {fixed_python}")
                shutdown_jupyter_kernel()
                return True

            # Prüfen, ob ipykernel installiert ist
            print(f"[{timestamp()}] [INFO] Checking ipykernel in the active environment...")
            result = subprocess.run([str(python_exe), "-m", "pip", "show", "ipykernel"], capture_output=True, text=True)

            kernel_name = f"venv_{active_env.name}_kernel"

            if result.returncode != 0:
                print(f"[{timestamp()}] [INFO] ipykernel not found. Installing ipykernel...")
                subprocess.run([str(python_exe), "-m", "pip", "install", "ipykernel"], check=True)
                print(f"[{timestamp()}] [INFO] ipykernel installed.")

                subprocess.run([
                    str(python_exe), "-m", "ipykernel", "install",
                    "--user",
                    "--name", kernel_name,
                    "--display-name", f"Python (venv: {active_env.name})"
                ], check=True)

            # Notebook mit korrektem Kernel verknüpfen
            set_kernel_in_notebook(
                notebook_path=file_path,
                kernel_name=kernel_name,
                display_name=f"Python (venv: {active_env.name})"
            )

            # Jupyter starten
            proc = subprocess.Popen([str(fixed_python), "-m", "notebook", str(file_path)])

            time.sleep(5)

            url_path = file_path.relative_to(Path.cwd()).as_posix()
            webbrowser.open_new(f"http://localhost:8888/notebooks/{url_path}")

            print(
                f"[{timestamp()}] [INFO] Started Jupyter Notebook with kernel '{kernel_name}'. Waiting for it to close...")

            proc.wait()

            print(f"[{timestamp()}] [INFO] Jupyter Notebook has been closed. Continuing...")

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] An error occurred: {e}")
            shutdown_jupyter_kernel()
            return True

        return True

    if user_input.startswith("jupyter "):
        if user_input.lower() == "jup q":
            print(f"[{timestamp()}] [INFO] Terminated by 'q'")
            shutdown_jupyter_kernel()
            return True
        if user_input == "jup \x11":  # Ctrl + Q
            print(f"[{timestamp()}] [INFO] Terminated by Ctrl + Q")
            shutdown_jupyter_kernel()
            return True

        file_input = user_input[8:].strip()

        if file_input.endswith(".jup"):
            file_input = file_input[:-4] + ".ipynb"

        try:
            file_path = Path(file_input).resolve()
            file_path.parent.mkdir(parents=True, exist_ok=True)

            # Notebook anlegen, falls nicht vorhanden
            if not file_path.exists():
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write("""{
             "cells": [],
             "metadata": {},
             "nbformat": 4,
             "nbformat_minor": 2
            }""")

            # Aktive Umgebung laden
            json_path = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/current_env.json")
            with open(json_path, 'r') as file:
                data = json.load(file)
                active_env_path = data.get("active_env")

            if not active_env_path:
                print(f"[{timestamp()}] [ERROR] No active environment found.")
                shutdown_jupyter_kernel()
                return True

            active_env = Path(active_env_path)
            python_exe = active_env / "Scripts" / "python.exe"

            fixed_python = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/.env/Scripts/python.exe")
            if not fixed_python.exists():
                print(f"[{timestamp()}] [ERROR] Fixed Python interpreter for Jupyter not found: {fixed_python}")
                shutdown_jupyter_kernel()
                return True

            # Prüfen, ob ipykernel installiert ist
            print(f"[{timestamp()}] [INFO] Checking ipykernel in the active environment...")
            result = subprocess.run([str(python_exe), "-m", "pip", "show", "ipykernel"], capture_output=True, text=True)

            kernel_name = f"venv_{active_env.name}_kernel"

            if result.returncode != 0:
                print(f"[{timestamp()}] [INFO] ipykernel not found. Installing ipykernel...")
                subprocess.run([str(python_exe), "-m", "pip", "install", "ipykernel"], check=True)
                print(f"[{timestamp()}] [INFO] ipykernel installed.")

                subprocess.run([
                    str(python_exe), "-m", "ipykernel", "install",
                    "--user",
                    "--name", kernel_name,
                    "--display-name", f"Python (venv: {active_env.name})"
                ], check=True)

            # Notebook mit korrektem Kernel verknüpfen
            set_kernel_in_notebook(
                notebook_path=file_path,
                kernel_name=kernel_name,
                display_name=f"Python (venv: {active_env.name})"
            )

            # Jupyter starten
            proc = subprocess.Popen([str(fixed_python), "-m", "notebook", str(file_path)])

            time.sleep(5)

            url_path = file_path.relative_to(Path.cwd()).as_posix()
            webbrowser.open_new(f"http://localhost:8888/notebooks/{url_path}")

            print(
                f"[{timestamp()}] [INFO] Started Jupyter Notebook with kernel '{kernel_name}'. Waiting for it to close...")

            proc.wait()

            print(f"[{timestamp()}] [INFO] Jupyter Notebook has been closed. Continuing...")

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] An error occurred: {e}")
            shutdown_jupyter_kernel()
            return True

    if user_input.startswith("jupyter notebook "):
        if user_input.lower() == "jup q":
            print(f"[{timestamp()}] [INFO] Terminated by 'q'")
            shutdown_jupyter_kernel()
            return True
        if user_input == "jup \x11":  # Ctrl + Q
            print(f"[{timestamp()}] [INFO] Terminated by Ctrl + Q")
            shutdown_jupyter_kernel()
            return True

        file_input = user_input[17:].strip()

        if file_input.endswith(".jup"):
            file_input = file_input[:-4] + ".ipynb"

        try:
            file_path = Path(file_input).resolve()
            file_path.parent.mkdir(parents=True, exist_ok=True)

            # Notebook anlegen, falls nicht vorhanden
            if not file_path.exists():
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write("""{
             "cells": [],
             "metadata": {},
             "nbformat": 4,
             "nbformat_minor": 2
            }""")

            # Aktive Umgebung laden
            json_path = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/current_env.json")
            with open(json_path, 'r') as file:
                data = json.load(file)
                active_env_path = data.get("active_env")

            if not active_env_path:
                print(f"[{timestamp()}] [ERROR] No active environment found.")
                shutdown_jupyter_kernel()
                return True

            active_env = Path(active_env_path)
            python_exe = active_env / "Scripts" / "python.exe"

            fixed_python = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/.env/Scripts/python.exe")
            if not fixed_python.exists():
                print(f"[{timestamp()}] [ERROR] Fixed Python interpreter for Jupyter not found: {fixed_python}")
                shutdown_jupyter_kernel()
                return True

            # Prüfen, ob ipykernel installiert ist
            print(f"[{timestamp()}] [INFO] Checking ipykernel in the active environment...")
            result = subprocess.run([str(python_exe), "-m", "pip", "show", "ipykernel"], capture_output=True, text=True)

            kernel_name = f"venv_{active_env.name}_kernel"

            if result.returncode != 0:
                print(f"[{timestamp()}] [INFO] ipykernel not found. Installing ipykernel...")
                subprocess.run([str(python_exe), "-m", "pip", "install", "ipykernel"], check=True)
                print(f"[{timestamp()}] [INFO] ipykernel installed.")

                subprocess.run([
                    str(python_exe), "-m", "ipykernel", "install",
                    "--user",
                    "--name", kernel_name,
                    "--display-name", f"Python (venv: {active_env.name})"
                ], check=True)

            # Notebook mit korrektem Kernel verknüpfen
            set_kernel_in_notebook(
                notebook_path=file_path,
                kernel_name=kernel_name,
                display_name=f"Python (venv: {active_env.name})"
            )

            # Jupyter starten
            proc = subprocess.Popen([str(fixed_python), "-m", "notebook", str(file_path)])

            time.sleep(5)

            url_path = file_path.relative_to(Path.cwd()).as_posix()
            webbrowser.open_new(f"http://localhost:8888/notebooks/{url_path}")

            print(
                f"[{timestamp()}] [INFO] Started Jupyter Notebook with kernel '{kernel_name}'. Waiting for it to close...")

            proc.wait()

            print(f"[{timestamp()}] [INFO] Jupyter Notebook has been closed. Continuing...")

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] An error occurred: {e}")
            shutdown_jupyter_kernel()
            return True

    if user_input.startswith("jup-p "):
        if user_input.lower() == "jup q":
            print(f"[{timestamp()}] [INFO] Terminated by 'q'")
            shutdown_jupyter_kernel()
            return True
        if user_input == "jup \x11":  # Ctrl + Q
            print(f"[{timestamp()}] [INFO] Terminated by Ctrl + Q")
            shutdown_jupyter_kernel()
            return True

        file_input = user_input[6:].strip()

        if file_input.endswith(".jup"):
            file_input = file_input[:-4] + ".ipynb"

        try:
            file_path = Path(file_input).resolve()
            file_path.parent.mkdir(parents=True, exist_ok=True)

            # Create empty notebook if it doesn't exist
            if not file_path.exists():
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write("""{
         "cells": [],
         "metadata": {},
         "nbformat": 4,
         "nbformat_minor": 2
        }""")

            # Load active venv path from JSON
            json_path = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/current_env.json")
            with open(json_path, 'r') as file:
                data = json.load(file)
                active_env_path = data.get("active_env")

            if not active_env_path:
                print(f"[{timestamp()}] [ERROR] No active environment found.")
                shutdown_jupyter_kernel()
                return True

            active_env = Path(active_env_path)
            python_exe = active_env / "Scripts" / "python.exe"

            # Fixed python interpreter to start Jupyter Notebook
            fixed_python = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/.env/Scripts/python.exe")
            if not fixed_python.exists():
                print(f"[{timestamp()}] [ERROR] Fixed Python interpreter for Jupyter not found: {fixed_python}")
                shutdown_jupyter_kernel()
                return True

            # Step 0: Ensure ipykernel is installed in the active venv
            print(f"[{timestamp()}] [INFO] Checking ipykernel in the active environment...")
            result = subprocess.run([str(python_exe), "-m", "pip", "show", "ipykernel"], capture_output=True, text=True)
            if result.returncode != 0:
                print(f"[{timestamp()}] [INFO] ipykernel not found. Installing ipykernel...")
                subprocess.run([str(python_exe), "-m", "pip", "install", "ipykernel"], check=True)
                print(f"[{timestamp()}] [INFO] ipykernel installed.")

            # Step 1: Register the kernel pointing to the active venv python
            kernel_name = f"venv_{active_env.name}_kernel"
            subprocess.run([
                str(python_exe), "-m", "ipykernel", "install",
                "--user",
                "--name", kernel_name,
                "--display-name", f"Python (venv: {active_env.name})"
            ], check=True)

            # Neu: Kernel in Notebook setzen, damit Jupyter direkt den richtigen Kernel lädt
            set_kernel_in_notebook(
                notebook_path=file_path,
                kernel_name=kernel_name,
                display_name=f"Python (venv: {active_env.name})"
            )

            # Step 2: Start Jupyter Notebook with the fixed interpreter (which runs Jupyter)
            proc = subprocess.Popen([str(fixed_python), "-m", "notebook", str(file_path)])

            # Step 3: Wait a bit for Jupyter to start
            time.sleep(5)

            # Step 4: Open notebook in default browser
            url_path = file_path.relative_to(Path.cwd()).as_posix()
            webbrowser.open_new(f"http://localhost:8888/notebooks/{url_path}")

            print(
                f"[{timestamp()}] [INFO] Started Jupyter Notebook with kernel '{kernel_name}'. Kernel is used automatically.")

            proc.wait()

            print(f"[{timestamp()}] [INFO] JupyterLab has been closed. Continuing...")

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] An error occurred: {e}")

        return True

    if user_input.startswith("jup-j "):
        # Abbruchkürzel: 'jup-j q' oder Ctrl+Q (ASCII 0x11)
        if user_input.lower() == "jup q":
            print(f"[{timestamp()}] [INFO] Terminated by 'q'")
            shutdown_jupyter_kernel()
            return True
        if user_input == "jup \x11":  # Ctrl + Q
            print(f"[{timestamp()}] [INFO] Terminated by Ctrl + Q")
            shutdown_jupyter_kernel()
            return True

        # Extrahiere Dateinamen/Path hinter "jup-j "
        file_input = user_input[6:].strip()

        # Wenn Dateiendung .jup, ersetze sie durch .ipynb
        if file_input.lower().endswith(".jup"):
            file_input = file_input[:-4] + ".ipynb"

        # Wenn keine Endung angegeben ist, hänge .ipynb an
        if not Path(file_input).suffix:
            file_input = file_input + ".ipynb"

        try:
            file_path = Path(file_input).resolve()
            # Erstelle übergeordnete Ordner, falls nötig
            file_path.parent.mkdir(parents=True, exist_ok=True)

            # Falls Notebook noch nicht existiert: leeres Template mit Julia-Kernel-Metadaten anlegen
            if not file_path.exists():
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write("""{
          "cells": [],
          "metadata": {
            "kernelspec": {
              "display_name": "Julia",
              "language": "julia",
              "name": "julia-1.9"
            },
            "language_info": {
              "file_extension": ".jl",
              "mimetype": "application/julia",
              "name": "julia",
              "version": "1.9"
            }
          },
          "nbformat": 4,
          "nbformat_minor": 2
        }""")
                    # Hinweis: kernelspec.name sollte der tatsächlichen Julia-Version entsprechen,
                    # z. B. "julia-1.9" oder was IJulia registriert.

            # 1) Julia finden
            #    Zuerst im PATH suchen, sonst im aktuellen Verzeichnis
            julia_path = shutil.which("julia")
            if julia_path is None:
                # Falls nicht in PATH, im aktuellen Verzeichnis suchen
                cand_win = Path.cwd() / "julia.exe"
                cand_unix = Path.cwd() / "julia"
                if cand_win.exists():
                    julia_path = str(cand_win)
                elif cand_unix.exists():
                    julia_path = str(cand_unix)
                else:
                    print(f"[{timestamp()}] [ERROR] Julia not found (neither in PATH nor in the current directory).")
                    shutdown_jupyter_kernel()
                    return True

            print(f"[{timestamp()}] [INFO] Used Julia executable: {julia_path}")

            # 2) Prüfen/Installieren von IJulia
            try:
                # Check if IJulia is installed
                check_cmd = [
                    julia_path,
                    "-e",
                    "using IJulia; quit()"
                ]
                result = subprocess.run(check_cmd, capture_output=True, text=True)
                if result.returncode != 0:
                    # IJulia is not installed → install and register
                    print(f"[{timestamp()}] [INFO] IJulia is not installed. Starting installation...")
                    install_cmd = [
                        julia_path,
                        "-e",
                        "import Pkg; Pkg.add(\"IJulia\"); using IJulia; installkernel(\"Julia\")"
                    ]
                    install_result = subprocess.run(install_cmd, capture_output=True, text=True)
                    if install_result.returncode != 0:
                        print(f"[{timestamp()}] [ERROR] Error during IJulia installation:")
                        print(install_result.stdout or install_result.stderr)
                        shutdown_jupyter_kernel()
                        return True
                    else:
                        print(f"[{timestamp()}] [INFO] IJulia successfully installed and registered.")
                else:
                    # IJulia is already installed – maybe just re-register the kernel
                    print(f"[{timestamp()}] [INFO] IJulia is already installed. Re-registering kernel...")
                    register_cmd = [
                        julia_path,
                        "-e",
                        "using IJulia; installkernel(\"Julia\", force = true)"
                    ]
                    reg_result = subprocess.run(register_cmd, capture_output=True, text=True)
                    if reg_result.returncode != 0:
                        print(f"[{timestamp()}] [WARNING] Could not rerun IJulia::installkernel:")
                        print(reg_result.stdout or reg_result.stderr)
                    else:
                        print(f"[{timestamp()}] [INFO] IJulia kernel registration updated.")
            except Exception as e:
                print(f"[{timestamp()}] [ERROR] Error during IJulia installation/check: {e}")
                shutdown_jupyter_kernel()
                return True

            # 3) Jupyter Notebook starten
            #    Wir suchen zuerst nach 'jupyter-notebook' im PATH
            jupyter_exe = shutil.which("jupyter-notebook") or shutil.which("jupyter")
            if jupyter_exe is None:
                print(f"[{timestamp()}] [ERROR] 'jupyter-notebook' not found. Please install Jupyter or add it to PATH.")
                shutdown_jupyter_kernel()
                return True

            # Start notebook process (in background)
            print(f"[{timestamp()}] [INFO] Starting Jupyter Notebook...")
            proc = subprocess.Popen([jupyter_exe, "notebook", str(file_path)])
            time.sleep(3)  # short pause to allow server to start

            # Open notebook URL: default URL is localhost:8888/notebooks/<relative path>
            current_dir = Path.cwd().resolve()
            try:
                url_path = file_path.relative_to(current_dir).as_posix()
            except ValueError:
                # If file is outside current working directory,
                # use absolute path (usually works anyway)
                url_path = file_path.as_posix()

            notebook_url = f"http://localhost:8888/notebooks/{url_path}"
            webbrowser.open_new(notebook_url)
            print(f"[{timestamp()}] [INFO] Jupyter Notebook started. Opening: {notebook_url}")
            print(f"[{timestamp()}] [INFO] In the notebook, select 'Julia' in the kernel menu at top right (if not selected automatically).")

            proc.wait()

            print(f"[{timestamp()}] [INFO] JupyterLab has been closed. Continuing...")

        except Exception as e:
            print(f"[{timestamp()}] [INFO] An unexpected error occurred: {e}")

        return True

    if user_input.startswith("jup-r "):
        # Kürzel für Abbruch: 'jup-r q' oder Ctrl+Q (ASCII 0x11)
        if user_input.lower() == "jup q":
            print(f"[{timestamp()}] [INFO] Terminated by 'q'")
            shutdown_jupyter_kernel()
            return True
        if user_input == "jup \x11":  # Ctrl + Q
            print(f"[{timestamp()}] [INFO] Terminated by Ctrl + Q")
            shutdown_jupyter_kernel()
            return True

        # Extrahiere Dateinamen/Path hinter "jup-r "
        file_input = user_input[6:].strip()

        # Wenn Dateiendung .jup, ersetze sie durch .ipynb
        if file_input.lower().endswith(".jup"):
            file_input = file_input[:-4] + ".ipynb"

        # Wenn keine Endung angegeben ist, füge .ipynb hinzu
        if not Path(file_input).suffix:
            file_input = file_input + ".ipynb"

        try:
            file_path = Path(file_input).resolve()
            # Erstelle übergeordnete Ordner, falls nötig
            file_path.parent.mkdir(parents=True, exist_ok=True)

            # Falls Notebook noch nicht existiert: leeres Template anlegen
            if not file_path.exists():
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write("""{
          "cells": [],
          "metadata": {
            "kernelspec": {
              "display_name": "R",
              "language": "R",
              "name": "ir"
            },
            "language_info": {
              "codemirror_mode": "r",
              "file_extension": ".r",
              "mimetype": "text/x-r-source",
              "name": "R",
              "pygments_lexer": "r"
            }
          },
          "nbformat": 4,
          "nbformat_minor": 2
        }""")
                    # Hinweis: Metadata enthält schon R-Kernel-Definition

            # 1) Rscript finden
            #    Zuerst im PATH suchen, sonst im Arbeitsverzeichnis
            rscript_path = shutil.which("Rscript")
            if rscript_path is None:
                # Falls nicht in PATH, im aktuellen Verzeichnis suchen
                cand_win = Path.cwd() / "Rscript.exe"
                cand_unix = Path.cwd() / "Rscript"
                if cand_win.exists():
                    rscript_path = str(cand_win)
                elif cand_unix.exists():
                    rscript_path = str(cand_unix)
                else:
                    print(f"[{timestamp()}] [INFO] Rscript not found (neither in PATH nor in current directory).")
                    shutdown_jupyter_kernel()
                    return True

            print(f"[{timestamp()}] [INFO] Used Rscript: {rscript_path}")

            # 2) Prüfen/Installieren von IRkernel
            #    IRkernel wird benötigt, damit Jupyter den R-Kernel erkennt.
            try:
                # Check if IRkernel is installed
                check_cmd = [
                    rscript_path,
                    "-e",
                    "if (!requireNamespace('IRkernel', quietly=TRUE)) quit(status=1)"
                ]
                result = subprocess.run(check_cmd, capture_output=True, text=True)
                if result.returncode != 0:
                    # IRkernel is not installed → install and register
                    print(f"[{timestamp()}] [INFO] IRkernel is not installed. Starting installation...")
                    install_cmd = [
                        rscript_path,
                        "-e",
                        "install.packages('IRkernel', repos='https://cloud.r-project.org'); IRkernel::installspec()"
                    ]
                    install_result = subprocess.run(install_cmd, capture_output=True, text=True)
                    if install_result.returncode != 0:
                        print(f"[{timestamp()}] [ERROR] Error during IRkernel installation:")
                        print(install_result.stdout or install_result.stderr)
                        shutdown_jupyter_kernel()
                        return True
                    else:
                        print(f"[{timestamp()}] [INFO] IRkernel successfully installed and registered.")
                else:
                    # IRkernel is already present – maybe just register (to be safe)
                    print(f"[{timestamp()}] [INFO] IRkernel already installed. Registering (installspec)...")
                    register_cmd = [
                        rscript_path,
                        "-e",
                        "IRkernel::installspec(user = FALSE)"
                    ]
                    reg_result = subprocess.run(register_cmd, capture_output=True, text=True)
                    if reg_result.returncode != 0:
                        print(f"[{timestamp()}] [WARNING] Could not rerun IRkernel::installspec:")
                        print(reg_result.stdout or reg_result.stderr)
                    else:
                        print(f"[{timestamp()}] [INFO] IRkernel registration updated.")
            except Exception as e:
                print(f"[{timestamp()}] [ERROR] Error during IRkernel installation/check: {e}")
                shutdown_jupyter_kernel()
                return True

            # 3) Jupyter Notebook starten
            #    Wir versuchen zuerst, 'jupyter-notebook' über PATH zu starten:
            jupyter_exe = shutil.which("jupyter-notebook") or shutil.which("jupyter")
            if jupyter_exe is None:
                print(f"[{timestamp()}] [ERROR] 'jupyter-notebook' not found. Please install Jupyter or add it to PATH.")
                shutdown_jupyter_kernel()
                return True

            # Starte Notebook-Prozess (im Hintergrund)
            # Hinweis: Bei Bedarf kann man hier auch 'jupyter lab' benutzen.
            print(f"[{timestamp()}] [INFO] Starting Jupyter Notebook...")
            proc = subprocess.Popen([jupyter_exe, "notebook", str(file_path)])
            time.sleep(3)  # short pause to allow server start

            # Notebook-URL öffnen: Standard-URL lautet localhost:8888/notebooks/<relativer Pfad>
            current_dir = Path.cwd().resolve()
            try:
                url_path = file_path.relative_to(current_dir).as_posix()
            except ValueError:
                # Wenn sich die Datei außerhalb des aktuellen Arbeitsverzeichnisses befindet,
                # nehmen wir den absoluten Pfad (funktioniert in den meisten Fällen trotzdem)
                url_path = file_path.as_posix()

            notebook_url = f"http://localhost:8888/notebooks/{url_path}"
            webbrowser.open_new(notebook_url)
            print(f"[{timestamp()}] [INFO] Jupyter Notebook started. Opening: {notebook_url}")
            print("[{timestamp()}] [INFO] In the notebook, please select 'R' in the kernel menu at top right (if not selected automatically).")

            proc.wait()

            print(f"[{timestamp()}] [INFO] JupyterLab has been closed. Continuing...")

        except Exception as e:
            print(f"[{timestamp()}] [INFO] An unexpected error occurred: {e}")

        return True

    if user_input.startswith("jupl "):
        if user_input.lower() == "jup q":
            print(f"[{timestamp()}] [INFO] Terminated by 'q'")
            shutdown_jupyter_kernel()
            return True
        if user_input == "jup \x11":  # Ctrl + Q
            print(f"[{timestamp()}] [INFO] Terminated by Ctrl + Q")
            shutdown_jupyter_kernel()
            return True

        file_input = user_input[5:].strip()

        try:
            # Optional: falls ein Pfad angegeben wurde, diesen auflösen
            file_path = Path(file_input).resolve()

            # Fester Pfad zum Python, das JupyterLab starten soll
            fixed_python = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/.env/Scripts/python.exe")
            if not fixed_python.exists():
                print(f"[{timestamp()}] [ERROR] Fixed Python interpreter for Jupyter not found: {fixed_python}")
                shutdown_jupyter_kernel()
                return True

            # JupyterLab starten (ohne Kernel-Registrierung etc.)
            proc = subprocess.Popen([str(fixed_python), "-m", "jupyter", "lab", str(file_path) if file_input else ""])

            # Optional: kleine Pause, damit JupyterLab startet
            time.sleep(3)

            # Browser öffnen mit Standard-JupyterLab-URL (ohne expliziten Pfad, da jupyter lab das öffnet)
            webbrowser.open_new("http://localhost:8888/lab")

            print(f"[{timestamp()}] [INFO] Started JupyterLab.")

            proc.wait()

            print(f"[{timestamp()}] [INFO] JupyterLab has been closed. Continuing...")

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] An error occurred: {e}")
            shutdown_jupyter_kernel()

        return True

    if user_input.startswith("jupyter lab "):
        if user_input.lower() == "jupl q":
            print(f"[{timestamp()}] [INFO] Terminated by 'q'")
            return True
        if user_input == "jupl \x11":  # Ctrl + Q
            print(f"[{timestamp()}] [INFO] Terminated by Ctrl + Q")
            return True

        file_input = user_input[5:].strip()

        try:
            # Optional: falls ein Pfad angegeben wurde, diesen auflösen
            file_path = Path(file_input).resolve()

            # Fester Pfad zum Python, das JupyterLab starten soll
            fixed_python = Path(f"C:/Users/{os.getlogin()}/p-terminal/pp-term/.env/Scripts/python.exe")
            if not fixed_python.exists():
                print(f"[{timestamp()}] [ERROR] Fixed Python interpreter for Jupyter not found: {fixed_python}")
                return True

            # JupyterLab starten (ohne Kernel-Registrierung etc.)
            proc = subprocess.Popen([str(fixed_python), "-m", "jupyter", "lab", str(file_path) if file_input else ""])

            # Optional: kleine Pause, damit JupyterLab startet
            time.sleep(3)

            # Browser öffnen mit Standard-JupyterLab-URL (ohne expliziten Pfad, da jupyter lab das öffnet)
            webbrowser.open_new("http://localhost:8888/lab")

            print(f"[{timestamp()}] [INFO] Started JupyterLab.")

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] An error occurred: {e}")

        return True

    if user_input.startswith("spyder "):
        file_input = user_input[7:].strip()

        if not file_input:
            print(f"[{timestamp()}] [ERROR] No file specified.")
            return True

        try:
            file_path = Path(file_input).resolve()
            file_path.parent.mkdir(parents=True, exist_ok=True)

            # Datei anlegen, falls sie nicht existiert
            if not file_path.exists():
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write("# You have created a new Python file using the PP-Terminal.\n")

            # Pfad zu Spyder in der .env
            current_env = Path(f"C:/Users/{getpass.getuser()}/p-terminal/pp-term/.env")
            spyder_exe = current_env / "Scripts" / "spyder.exe"

            if not spyder_exe.exists():
                print(f"[{timestamp()}] [ERROR] Spyder not found at: {spyder_exe}")
                shutdown_spy()
                return True

            print(f"[{timestamp()}] [INFO] Launching Spyder with file:\n{file_path}")
            print(f"[{timestamp()}] [INFO] Spyder executable: {spyder_exe}")

            # Spyder nur mit Datei starten (kein --python-interpreter)
            subprocess.Popen([
                str(spyder_exe),
                "--new-instance",
                str(file_path)
            ])

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Failed to launch Spyder: {e}")
            shutdown_spy()
            return True

        return True

    if user_input.startswith("spyder-pip "):
        file_input = user_input[11:].strip()

        if not file_input:
            print(f"[{timestamp()}] [ERROR] No file specified.")
            return True

        try:
            file_path = Path(file_input).resolve()
            file_path.parent.mkdir(parents=True, exist_ok=True)

            # Datei anlegen, falls sie nicht existiert
            if not file_path.exists():
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write("# You have created a new Python file using the PP-Terminal.\n")

            # Pfad zu Spyder in der .env
            current_env = Path(f"C:/Users/{getpass.getuser()}/p-terminal/pp-term/.env")
            spyder_exe = current_env / "Scripts" / "spyder.exe"

            if not spyder_exe.exists():
                print(f"[{timestamp()}] [ERROR] Spyder not found at: {spyder_exe}")
                shutdown_spy()
                return True

            print(f"[{timestamp()}] [INFO] Launching Spyder with file:\n{file_path}")
            print(f"[{timestamp()}] [INFO] Spyder executable: {spyder_exe}")

            # Spyder nur mit Datei starten (kein --python-interpreter)
            subprocess.Popen([
                str(spyder_exe),
                "--new-instance",
                str(file_path)
            ])

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Failed to launch Spyder: {e}")
            shutdown_spy()
            return True

        return True

    if user_input.startswith("prs "):
        file_input = user_input[4:].strip()

        if not file_input:
            print(f"[{timestamp()}] [ERROR] No file specified.")
            return True

        try:
            file_path = Path(file_input).resolve()
            file_path.parent.mkdir(parents=True, exist_ok=True)

            # Datei anlegen, falls sie nicht existiert
            if not file_path.exists():
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write("# You have created a new Python file using the PP-Terminal.\n")

            # Pfad zu Spyder in der .env
            current_env = Path(f"C:/Users/{getpass.getuser()}/p-terminal/pp-term/.env")
            spyder_exe = current_env / "Scripts" / "spyder.exe"

            if not spyder_exe.exists():
                print(f"[{timestamp()}] [ERROR] Spyder not found at: {spyder_exe}")
                shutdown_spy()
                return True

            print(f"[{timestamp()}] [INFO] Launching Spyder with file:\n{file_path}")
            print(f"[{timestamp()}] [INFO] Spyder executable: {spyder_exe}")

            # Spyder nur mit Datei starten (kein --python-interpreter)
            subprocess.Popen([
                str(spyder_exe),
                "--new-instance",
                str(file_path)
            ])

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Failed to launch Spyder: {e}")
            shutdown_spy()
            return True

        return True

    if user_input.startswith("pff "):
        user_input = user_input[4:].strip()
        current_dir = Path.cwd().resolve()

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"""powershell Get-ChildItem -Path "{current_dir}" -Recurse -Filter "{user_input}" """

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff-name "):
        user_input = user_input[9:].strip()
        current_dir = Path.cwd().resolve()

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"""powershell Get-ChildItem -Path "{current_dir}" -Recurse -Filter "{user_input}" """

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff2 "):
        user_input = user_input[5:].strip()
        current_dir = Path.cwd().resolve()

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f'powershell Get-ChildItem -Path "{current_dir}" -Recurse | Where-Object {{ $_.Name -like "*{user_input}*" }}'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff-name-like "):
        user_input = user_input[14:].strip()
        current_dir = Path.cwd().resolve()

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f'powershell Get-ChildItem -Path "{current_dir}" -Recurse | Where-Object {{ $_.Name -like "*{user_input}*" }}'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff3 "):
        user_input = user_input[5:].strip()
        current_dir = Path.cwd().resolve()

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"""powershell Get-ChildItem -Path "{current_dir}" -Recurse -Include *{user_input}"""

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff-name-include "):
        user_input = user_input[17:].strip()
        current_dir = Path.cwd().resolve()

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"""powershell Get-ChildItem -Path "{current_dir}" -Recurse -Include *{user_input}"""

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff-text "):
        user_input = user_input[9:].strip()
        current_dir = Path.cwd().resolve()

        extensions = ["*.txt", "*.md", "*.log", "*.pdf", "*.docx", "*.xlsx", "*.pptx", "*.csv", "*.json", "*.xml",
                      "*.yaml", "*.ini", "*.html", "*.js", "*.py"]

        patterns = " -Include " + ",".join(extensions)

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"""powershell -Command "Get-ChildItem -Recurse -Path '{current_dir}'{patterns} | Select-String -Pattern '{user_input}'" """

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff-word "):
        user_input = user_input[9:].strip()
        current_dir = Path.cwd().resolve()

        extensions = ["*.txt", "*.md", "*.log", "*.pdf", "*.docx", "*.xlsx", "*.pptx", "*.csv", "*.json", "*.xml",
                      "*.yaml", "*.ini", "*.html", "*.js", "*.py"]

        patterns = " -Include " + ",".join(extensions)

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"""powershell -Command "Get-ChildItem -Recurse -Path '{current_dir}'{patterns} | Select-String -Pattern '{user_input}'" """

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff-word-text "):
        user_input = user_input[13:].strip()
        current_dir = Path.cwd().resolve()

        extensions = ["*.txt", "*.md", "*.log", "*.pdf", "*.docx", "*.xlsx", "*.pptx", "*.csv", "*.json", "*.xml",
                      "*.yaml", "*.ini", "*.html", "*.js", "*.py"]

        patterns = " -Include " + ",".join(extensions)

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"""powershell -Command "Get-ChildItem -Recurse -Path '{current_dir}'{patterns} | Select-String -Pattern '{user_input}'" """

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff4-code "):
        user_input = user_input[10:].strip()
        current_dir = Path.cwd().resolve()

        extensions = ["*.py", "*.pyc", "*.pyo", "*.ipynb", "*.r", "*.rmd", "*.jl", "*.m", "*.nb", "*.nbp", "*.sage",
                      "*.scm", "*.ss", "*.clj", "*.cljs", "*.cljc", "*.edn",
                      "*.c", "*.cpp", "*.cc", "*.cxx", "*.h", "*.hpp", "*.hh", "*.hxx", "*.cs", "*.java", "*.kt",
                      "*.kts", "*.scala", "*.go", "*.rs", "*.swift", "*.dart",
                      "*.ts", "*.tsx", "*.js", "*.jsx", "*.mjs", "*.cjs", "*.php", "*.phtml", "*.php3", "*.php4",
                      "*.php5", "*.rb", "*.pl", "*.pm", "*.lua", "*.vb", "*.vbs",
                      "*.asm", "*.s", "*.f", "*.f90", "*.f95", "*.pas", "*.pp", "*.d", "*.nim", "*.ada", "*.adb",
                      "*.ads", "*.lisp", "*.el", "*.cl", "*.ex", "*.exs", "*.erl",
                      "*.hrl", "*.ml", "*.mli", "*.mll", "*.mly", "*.groovy", "*.gvy", "*.gy", "*.gsh", "*.tcl", "*.tk",
                      "*.coffee", "*.sc", "*.rkt", "*.hs", "*.lhs", "*.fs",
                      "*.fsi", "*.fsx", "*.fsscript", "*.n", "*.nqc", "*.v", "*.vh", "*.sv", "*.svh", "*.vhdl", "*.vhd",
                      "*.html", "*.htm", "*.xhtml", "*.css", "*.scss", "*.less", "*.xml", "*.json", "*.yaml", "*.yml",
                      "*.toml", "*.ini", "*.env", "*.cfg", "*.conf",
                      "*.sql", "*.db", "*.sqlite", "*.mdb", "*.accdb", "*.csv", "*.tsv", "*.parquet", "*.avro", "*.orc",
                      "*.hdf5", "*.feather", "*.arrow",
                      "*.sh", "*.bash", "*.zsh", "*.ksh", "*.csh", "*.bat", "*.cmd", "*.ps1", "*.psm1", "*.psd1",
                      "*.scpt", "*.applescript", "*.vbs", "*.wsf",
                      "*.make", "*.mak", "*.cmake", "*.gradle", "*.pom", "*.build", "*.proj", "*.sln", "*.csproj",
                      "*.vcxproj", "*.xcodeproj", "*.ninja",
                      "*.md", "*.markdown", "*.rst", "*.asciidoc", "*.adoc", "*.tex", "*.latex", "*.bib", "*.doc",
                      "*.docx", "*.odt", "*.pdf",
                      "*.properties", "*.settings", "*.prefs", "*.config", "*.cfg", "*.conf", "*.ini", "*.toml",
                      "*.yaml", "*.yml", "*.json",
                      "*.log", "*.out", "*.err", "*.bak", "*.tmp", "*.lock", "*.pid", "*.swp", "*.swo", "*.orig",
                      "*.rej",
                      "*.vue", "*.svelte", "*.astro", "*.elm", "*.purs", "*.res", "*.re", "*.ml", "*.mli", "*.mll",
                      "*.mly", "*.zig", "*.vala", "*.vapi", "*.nim", "*.nimble",
                      "*.ktm", "*.kts", "*.cl", "*.clw", "*.cls", "*.m", "*.mm", "*.ml", "*.mli", "*.mll", "*.mly",
                      "*.fs", "*.fsi", "*.fsx", "*.fsscript",
                      "*.r", "*.rmd", "*.rhtml", "*.rxml", "*.rjs", "*.rpy", "*.rpyc", "*.rbc", "*.rbw", "*.erb",
                      "*.haml", "*.slim", "*.liquid",
                      "*.ejs", "*.hbs", "*.mustache", "*.pug", "*.jade", "*.njk", "*.nunjucks", "*.twig", "*.blade.php",
                      "*.latte", "*.volt", "*.tmpl", "*.tpl",
                      "*.jsp", "*.jspx", "*.asp", "*.aspx", "*.ascx", "*.ashx", "*.asmx", "*.cshtml", "*.vbhtml",
                      "*.cgi", "*.fcgi", "*.pl", "*.pm", "*.t", "*.pod", "*.psgi",
                      "*.ex", "*.exs", "*.eex", "*.leex", "*.heex",
                      "*.erl", "*.hrl", "*.yaws",
                      "*.lisp", "*.el", "*.cl", "*.scm", "*.ss", "*.rkt", "*.rktl", "*.rktd",
                      "*.hs", "*.lhs", "*.purs", "*.agda", "*.lagda", "*.lagda.tex",
                      "*.ml", "*.mli", "*.mll", "*.mly",
                      "*.fs", "*.fsi", "*.fsx", "*.fsscript",
                      "*.d", "*.di",
                      "*.nim", "*.nims", "*.nimble",
                      "*.vala", "*.vapi",
                      "*.zig",
                      "*.v", "*.vh", "*.sv", "*.svh", "*.vhdl", "*.vhd",
                      "*.q", "*.ql", "*.qvs",
                      "*.sas", "*.sas7bdat", "*.sas7bcat", "*.sas7bvew", "*.sast", "*.sastat", "*.sasm", "*.sasmacr",
                      "*.sascfg", "*.sasxpt",
                      "*.spv", "*.spo", "*.sps", "*.sav", "*.zsav", "*.por",
                      "*.dta",
                      "*.do", "*.ado", "*.dta", "*.gph",
                      "*.m", "*.mat", "*.fig", "*.mex", "*.mexw32", "*.mexw64", "*.mexmaci64",
                      "*.ipynb", "*.py", "*.pyc", "*.pyo", "*.pyd", "*.pyw", "*.pyz",
                      "*.r", "*.rdata", "*.rds", "*.rda", "*.rmd", "*.rproj",
                      "*.jl", "*.jld", "*.jld2", "*.bson", "*.feather", "*.parquet",
                      "*.csv", "*.tsv", "*.xls", "*.xlsx", "*.ods",
                      "*.json", "*.jsonl", "*.ndjson", "*.yaml", "*.yml", "*.toml", "*.ini", "*.cfg", "*.conf",
                      "*.xml", "*.xsd", "*.xsl", "*.xslt", "*.dtd",
                      "*.sql", "*.sqlite", "*.db", "*.dbf", "*.mdb", "*.accdb",
                      "*.hdf5", "*.h5", "*.nc", "*.cdf", "*.grib", "*.grb", "*.grb2",
                      "*.npz", "*.npy", "*.mat", "*.rda", "*.rds", "*.feather", "*.parquet",
                      "*.log", "*.out", "*.err", "*.txt", "*.md", "*.rst", "*.adoc", "*.asciidoc",
                      "*.tex", "*.bib", "*.cls", "*.sty", "*.dtx", "*.ins",
                      "*.pdf", "*.ps", "*.eps", "*.svg", "*.png", "*.jpg", "*.jpeg", "*.gif", "*.bmp", "*.tiff",
                      "*.mp3", "*.wav", "*.flac", "*.ogg", "*.m4a", "*.aac", "*.wma",
                      "*.mp4", "*.mkv", "*.avi", "*.mov", "*.wmv", "*.flv", "*.webm",
                      "*.zip", "*.tar", "*.gz", "*.bz2", "*.xz", "*.7z", "*.rar", "*.iso", "*.dmg",
                      "*.exe", "*.msi", "*.apk", "*.app", "*.deb", "*.rpm", "*.bin", "*.run", "*.sh", "*.bat", "*.cmd",
                      "*.ps1",
                      "*.dll", "*.so", "*.dylib", "*.a", "*.lib", "*.o", "*.obj",
                      "*.jar", "*.war", "*.ear", "*.class", "*.dex", "*.apk", "*.aar",
                      "*.xpi", "*.crx", "*.nex", "*.appx", "*.appxbundle", "*.msix", "*.msixbundle",
                      "*.vbox", "*.vbox-prev", "*.vdi", "*.vmdk", "*.vhd", "*.vhdx", "*.qcow", "*.qcow2", "*.img",
                      "*.ovf", "*.ova", "*.iso", "*.img", "*.dmg",
                      "*.pem", "*.crt", "*.cer", "*.key", "*.csr", "*.pfx", "*.p12", "*.der", "*.jks", "*.keystore",
                      "*.asc", "*.sig", "*.gpg", "*.pgp",
                      "*.log", "*.bak", "*.old", "*.tmp", "*.swp", "*.swo", "*.lock", "*.pid",
                      "*.torrent", "*.nzb", "*.magnet",
                      "*.ics", "*.vcf", "*.vcs", "*.ical", "*.icalendar",
                      "*.eml", "*.msg", "*.mbox", "*.pst", "*.ost",
                      "*.srt", "*.sub", "*.ass", "*.ssa", "*.vtt",
                      "*.cue", "*.bin", "*.iso", "*.nrg", "*.mds", "*.mdf", "*.ccd", "*.img", "*.toast",
                      "*.cue", "*.ape", "*.flac", "*.wv", "*.tta", "*.tak", "*.alac", "*.m4a",
                      "*.sfv", "*.md5", "*.sha1", "*.sha256", "*.sha512",
                      "*.torrent", "*.nzb", "*.magnet",
                      "*.ics", "*.vcf", "*.vcs", "*.ical", "*.icalendar",
                      "*.eml", "*.msg", "*.mbox", "*.pst", "*.ost",
                      "*.srt", "*.sub", "*.ass", "*.ssa", "*.vtt",
                      "*.cue", "*.bin", "*.iso", "*.nrg", "*.mds", "*.mdf", "*.ccd", "*.img", "*.toast",
                      "*.cue", "*.ape", "*.flac", "*.wv", "*.tta", "*.tak", "*.al"]

        patterns = " -Include " + ",".join(extensions)

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"""powershell -Command "Get-ChildItem -Recurse -Path '{current_dir}'{patterns} | Select-String -Pattern '{user_input}'" """

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff-word-code "):
        user_input = user_input[14:].strip()
        current_dir = Path.cwd().resolve()

        extensions = ["*.py", "*.pyc", "*.pyo", "*.ipynb", "*.r", "*.rmd", "*.jl", "*.m", "*.nb", "*.nbp", "*.sage",
                      "*.scm", "*.ss", "*.clj", "*.cljs", "*.cljc", "*.edn",
                      "*.c", "*.cpp", "*.cc", "*.cxx", "*.h", "*.hpp", "*.hh", "*.hxx", "*.cs", "*.java", "*.kt",
                      "*.kts", "*.scala", "*.go", "*.rs", "*.swift", "*.dart",
                      "*.ts", "*.tsx", "*.js", "*.jsx", "*.mjs", "*.cjs", "*.php", "*.phtml", "*.php3", "*.php4",
                      "*.php5", "*.rb", "*.pl", "*.pm", "*.lua", "*.vb", "*.vbs",
                      "*.asm", "*.s", "*.f", "*.f90", "*.f95", "*.pas", "*.pp", "*.d", "*.nim", "*.ada", "*.adb",
                      "*.ads", "*.lisp", "*.el", "*.cl", "*.ex", "*.exs", "*.erl",
                      "*.hrl", "*.ml", "*.mli", "*.mll", "*.mly", "*.groovy", "*.gvy", "*.gy", "*.gsh", "*.tcl", "*.tk",
                      "*.coffee", "*.sc", "*.rkt", "*.hs", "*.lhs", "*.fs",
                      "*.fsi", "*.fsx", "*.fsscript", "*.n", "*.nqc", "*.v", "*.vh", "*.sv", "*.svh", "*.vhdl", "*.vhd",
                      "*.html", "*.htm", "*.xhtml", "*.css", "*.scss", "*.less", "*.xml", "*.json", "*.yaml", "*.yml",
                      "*.toml", "*.ini", "*.env", "*.cfg", "*.conf",
                      "*.sql", "*.db", "*.sqlite", "*.mdb", "*.accdb", "*.csv", "*.tsv", "*.parquet", "*.avro", "*.orc",
                      "*.hdf5", "*.feather", "*.arrow",
                      "*.sh", "*.bash", "*.zsh", "*.ksh", "*.csh", "*.bat", "*.cmd", "*.ps1", "*.psm1", "*.psd1",
                      "*.scpt", "*.applescript", "*.vbs", "*.wsf",
                      "*.make", "*.mak", "*.cmake", "*.gradle", "*.pom", "*.build", "*.proj", "*.sln", "*.csproj",
                      "*.vcxproj", "*.xcodeproj", "*.ninja",
                      "*.md", "*.markdown", "*.rst", "*.asciidoc", "*.adoc", "*.tex", "*.latex", "*.bib", "*.doc",
                      "*.docx", "*.odt", "*.pdf",
                      "*.properties", "*.settings", "*.prefs", "*.config", "*.cfg", "*.conf", "*.ini", "*.toml",
                      "*.yaml", "*.yml", "*.json",
                      "*.log", "*.out", "*.err", "*.bak", "*.tmp", "*.lock", "*.pid", "*.swp", "*.swo", "*.orig",
                      "*.rej",
                      "*.vue", "*.svelte", "*.astro", "*.elm", "*.purs", "*.res", "*.re", "*.ml", "*.mli", "*.mll",
                      "*.mly", "*.zig", "*.vala", "*.vapi", "*.nim", "*.nimble",
                      "*.ktm", "*.kts", "*.cl", "*.clw", "*.cls", "*.m", "*.mm", "*.ml", "*.mli", "*.mll", "*.mly",
                      "*.fs", "*.fsi", "*.fsx", "*.fsscript",
                      "*.r", "*.rmd", "*.rhtml", "*.rxml", "*.rjs", "*.rpy", "*.rpyc", "*.rbc", "*.rbw", "*.erb",
                      "*.haml", "*.slim", "*.liquid",
                      "*.ejs", "*.hbs", "*.mustache", "*.pug", "*.jade", "*.njk", "*.nunjucks", "*.twig", "*.blade.php",
                      "*.latte", "*.volt", "*.tmpl", "*.tpl",
                      "*.jsp", "*.jspx", "*.asp", "*.aspx", "*.ascx", "*.ashx", "*.asmx", "*.cshtml", "*.vbhtml",
                      "*.cgi", "*.fcgi", "*.pl", "*.pm", "*.t", "*.pod", "*.psgi",
                      "*.ex", "*.exs", "*.eex", "*.leex", "*.heex",
                      "*.erl", "*.hrl", "*.yaws",
                      "*.lisp", "*.el", "*.cl", "*.scm", "*.ss", "*.rkt", "*.rktl", "*.rktd",
                      "*.hs", "*.lhs", "*.purs", "*.agda", "*.lagda", "*.lagda.tex",
                      "*.ml", "*.mli", "*.mll", "*.mly",
                      "*.fs", "*.fsi", "*.fsx", "*.fsscript",
                      "*.d", "*.di",
                      "*.nim", "*.nims", "*.nimble",
                      "*.vala", "*.vapi",
                      "*.zig",
                      "*.v", "*.vh", "*.sv", "*.svh", "*.vhdl", "*.vhd",
                      "*.q", "*.ql", "*.qvs",
                      "*.sas", "*.sas7bdat", "*.sas7bcat", "*.sas7bvew", "*.sast", "*.sastat", "*.sasm", "*.sasmacr",
                      "*.sascfg", "*.sasxpt",
                      "*.spv", "*.spo", "*.sps", "*.sav", "*.zsav", "*.por",
                      "*.dta",
                      "*.do", "*.ado", "*.dta", "*.gph",
                      "*.m", "*.mat", "*.fig", "*.mex", "*.mexw32", "*.mexw64", "*.mexmaci64",
                      "*.ipynb", "*.py", "*.pyc", "*.pyo", "*.pyd", "*.pyw", "*.pyz",
                      "*.r", "*.rdata", "*.rds", "*.rda", "*.rmd", "*.rproj",
                      "*.jl", "*.jld", "*.jld2", "*.bson", "*.feather", "*.parquet",
                      "*.csv", "*.tsv", "*.xls", "*.xlsx", "*.ods",
                      "*.json", "*.jsonl", "*.ndjson", "*.yaml", "*.yml", "*.toml", "*.ini", "*.cfg", "*.conf",
                      "*.xml", "*.xsd", "*.xsl", "*.xslt", "*.dtd",
                      "*.sql", "*.sqlite", "*.db", "*.dbf", "*.mdb", "*.accdb",
                      "*.hdf5", "*.h5", "*.nc", "*.cdf", "*.grib", "*.grb", "*.grb2",
                      "*.npz", "*.npy", "*.mat", "*.rda", "*.rds", "*.feather", "*.parquet",
                      "*.log", "*.out", "*.err", "*.txt", "*.md", "*.rst", "*.adoc", "*.asciidoc",
                      "*.tex", "*.bib", "*.cls", "*.sty", "*.dtx", "*.ins",
                      "*.pdf", "*.ps", "*.eps", "*.svg", "*.png", "*.jpg", "*.jpeg", "*.gif", "*.bmp", "*.tiff",
                      "*.mp3", "*.wav", "*.flac", "*.ogg", "*.m4a", "*.aac", "*.wma",
                      "*.mp4", "*.mkv", "*.avi", "*.mov", "*.wmv", "*.flv", "*.webm",
                      "*.zip", "*.tar", "*.gz", "*.bz2", "*.xz", "*.7z", "*.rar", "*.iso", "*.dmg",
                      "*.exe", "*.msi", "*.apk", "*.app", "*.deb", "*.rpm", "*.bin", "*.run", "*.sh", "*.bat", "*.cmd",
                      "*.ps1",
                      "*.dll", "*.so", "*.dylib", "*.a", "*.lib", "*.o", "*.obj",
                      "*.jar", "*.war", "*.ear", "*.class", "*.dex", "*.apk", "*.aar",
                      "*.xpi", "*.crx", "*.nex", "*.appx", "*.appxbundle", "*.msix", "*.msixbundle",
                      "*.vbox", "*.vbox-prev", "*.vdi", "*.vmdk", "*.vhd", "*.vhdx", "*.qcow", "*.qcow2", "*.img",
                      "*.ovf", "*.ova", "*.iso", "*.img", "*.dmg",
                      "*.pem", "*.crt", "*.cer", "*.key", "*.csr", "*.pfx", "*.p12", "*.der", "*.jks", "*.keystore",
                      "*.asc", "*.sig", "*.gpg", "*.pgp",
                      "*.log", "*.bak", "*.old", "*.tmp", "*.swp", "*.swo", "*.lock", "*.pid",
                      "*.torrent", "*.nzb", "*.magnet",
                      "*.ics", "*.vcf", "*.vcs", "*.ical", "*.icalendar",
                      "*.eml", "*.msg", "*.mbox", "*.pst", "*.ost",
                      "*.srt", "*.sub", "*.ass", "*.ssa", "*.vtt",
                      "*.cue", "*.bin", "*.iso", "*.nrg", "*.mds", "*.mdf", "*.ccd", "*.img", "*.toast",
                      "*.cue", "*.ape", "*.flac", "*.wv", "*.tta", "*.tak", "*.alac", "*.m4a",
                      "*.sfv", "*.md5", "*.sha1", "*.sha256", "*.sha512",
                      "*.torrent", "*.nzb", "*.magnet",
                      "*.ics", "*.vcf", "*.vcs", "*.ical", "*.icalendar",
                      "*.eml", "*.msg", "*.mbox", "*.pst", "*.ost",
                      "*.srt", "*.sub", "*.ass", "*.ssa", "*.vtt",
                      "*.cue", "*.bin", "*.iso", "*.nrg", "*.mds", "*.mdf", "*.ccd", "*.img", "*.toast",
                      "*.cue", "*.ape", "*.flac", "*.wv", "*.tta", "*.tak", "*.al"]

        patterns = " -Include " + ",".join(extensions)

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"""powershell -Command "Get-ChildItem -Recurse -Path '{current_dir}'{patterns} | Select-String -Pattern '{user_input}'" """

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff4-config "):
        user_input = user_input[12:].strip()
        current_dir = Path.cwd().resolve()

        extensions = [
            "*.ini", "*.conf", "*.cfg", "*.cnf", "*.cf", "*.config", "*.yaml", "*.yml", "*.toml", "*.json",
            "*.xml", "*.properties", "*.plist", "*.desktop", "*.rc",
            "*.service", "*.target", "*.mount", "*.socket", "*.timer", "*.override", "*.env", "*.editorconfig",
            "*.htaccess", "*.dsconfig", "*.dsc", "*.pro", "*.reg", "*.sys", "*.hocon", "*.cson",
            "*.xsd", "*.xsl", "*.xslt", "*.dtd", "*.xproj", "*.xaml", "*.xmi", "*.xpl", "*.xproc", "*.xquery",
            "*.xq", "*.xql", "*.xqm", "*.xqy", "*.xs", "*.xslt", "*.xsl", "*.xojo_code", "*.xojo_menu",
            "*.xojo_report", "*.xojo_script", "*.xojo_toolbar", "*.xojo_window", "*.xtend", "*.yang"
        ]

        patterns = " -Include " + ",".join(extensions)

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"""powershell -Command "Get-ChildItem -Recurse -Path '{current_dir}'{patterns} | Select-String -Pattern '{user_input}'" """

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff-word-config "):
        user_input = user_input[16:].strip()
        current_dir = Path.cwd().resolve()

        extensions = [
            "*.ini", "*.conf", "*.cfg", "*.cnf", "*.cf", "*.config", "*.yaml", "*.yml", "*.toml", "*.json",
            "*.xml", "*.properties", "*.plist", "*.desktop", "*.rc",
            "*.service", "*.target", "*.mount", "*.socket", "*.timer", "*.override", "*.env", "*.editorconfig",
            "*.htaccess", "*.dsconfig", "*.dsc", "*.pro", "*.reg", "*.sys", "*.hocon", "*.cson",
            "*.xsd", "*.xsl", "*.xslt", "*.dtd", "*.xproj", "*.xaml", "*.xmi", "*.xpl", "*.xproc", "*.xquery",
            "*.xq", "*.xql", "*.xqm", "*.xqy", "*.xs", "*.xslt", "*.xsl", "*.xojo_code", "*.xojo_menu",
            "*.xojo_report", "*.xojo_script", "*.xojo_toolbar", "*.xojo_window", "*.xtend", "*.yang"
        ]

        patterns = " -Include " + ",".join(extensions)

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"""powershell -Command "Get-ChildItem -Recurse -Path '{current_dir}'{patterns} | Select-String -Pattern '{user_input}'" """

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff4-scripts "):
        user_input = user_input[13:].strip()
        current_dir = Path.cwd().resolve()

        extensions = [
            "*.ahk", "*.applescript", "*.asp", "*.aspx", "*.awk", "*.bat", "*.bash", "*.btm", "*.cgi", "*.clj",
            "*.cljs", "*.cljc", "*.cmd", "*.csh", "*.dart",
            "*.edn", "*.el", "*.erb", "*.ex", "*.exs", "*.fish", "*.fs", "*.fsx", "*.fsi", "*.gsh", "*.groovy", "*.gvy",
            "*.gy", "*.jl", "*.js",
            "*.jse", "*.jsx", "*.ksh", "*.kt", "*.kts", "*.lisp", "*.lua", "*.mak", "*.make", "*.m", "*.mli", "*.mll",
            "*.mly", "*.mjs", "*.ml",
            "*.mm", "*.ncl", "*.nsi", "*.nsh", "*.nut", "*.pl", "*.pm", "*.ps1", "*.ps1xml", "*.psd1", "*.psm1",
            "*.psrc", "*.pssc", "*.py", "*.pyc",
            "*.pyo", "*.pyw", "*.r", "*.raku", "*.rakumod", "*.rakutest", "*.rb", "*.rkt", "*.rktd", "*.rktl", "*.rmd",
            "*.rex", "*.rexx", "*.run", "*.scpt",
            "*.scptd", "*.sh", "*.sps", "*.spt", "*.svm", "*.t", "*.tcsh", "*.tcl", "*.ts", "*.tsx", "*.vim", "*.vbs",
            "*.vbe", "*.wsf", "*.command",
            "*.coffee", "*.gradle", "*.scm"
        ]

        patterns = " -Include " + ",".join(extensions)

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"""powershell -Command "Get-ChildItem -Recurse -Path '{current_dir}'{patterns} | Select-String -Pattern '{user_input}'" """

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff-word-scripts "):
        user_input = user_input[17:].strip()
        current_dir = Path.cwd().resolve()

        extensions = [
            "*.ahk", "*.applescript", "*.asp", "*.aspx", "*.awk", "*.bat", "*.bash", "*.btm", "*.cgi", "*.clj",
            "*.cljs", "*.cljc", "*.cmd", "*.csh", "*.dart",
            "*.edn", "*.el", "*.erb", "*.ex", "*.exs", "*.fish", "*.fs", "*.fsx", "*.fsi", "*.gsh", "*.groovy", "*.gvy",
            "*.gy", "*.jl", "*.js",
            "*.jse", "*.jsx", "*.ksh", "*.kt", "*.kts", "*.lisp", "*.lua", "*.mak", "*.make", "*.m", "*.mli", "*.mll",
            "*.mly", "*.mjs", "*.ml",
            "*.mm", "*.ncl", "*.nsi", "*.nsh", "*.nut", "*.pl", "*.pm", "*.ps1", "*.ps1xml", "*.psd1", "*.psm1",
            "*.psrc", "*.pssc", "*.py", "*.pyc",
            "*.pyo", "*.pyw", "*.r", "*.raku", "*.rakumod", "*.rakutest", "*.rb", "*.rkt", "*.rktd", "*.rktl", "*.rmd",
            "*.rex", "*.rexx", "*.run", "*.scpt",
            "*.scptd", "*.sh", "*.sps", "*.spt", "*.svm", "*.t", "*.tcsh", "*.tcl", "*.ts", "*.tsx", "*.vim", "*.vbs",
            "*.vbe", "*.wsf", "*.command",
            "*.coffee", "*.gradle", "*.scm"
        ]

        patterns = " -Include " + ",".join(extensions)

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"""powershell -Command "Get-ChildItem -Recurse -Path '{current_dir}'{patterns} | Select-String -Pattern '{user_input}'" """

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff5-text "):
        user_input = user_input[9:].strip()
        current_dir = Path.cwd().resolve()

        extensions = ["*.txt", "*.md", "*.log", "*.pdf", "*.docx", "*.xlsx", "*.pptx", "*.csv", "*.json", "*.xml",
                      "*.yaml", "*.ini", "*.html", "*.js", "*.py"]

        path_patterns = ",".join(f"'{current_dir}\\{ext}'" for ext in extensions)
        escaped_pattern = user_input.replace("'", "''")

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"Select-String -Path {path_patterns} -Pattern '{escaped_pattern}' -Recurse"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff-word-text-fast "):
        user_input = user_input[18:].strip()
        current_dir = Path.cwd().resolve()

        extensions = ["*.txt", "*.md", "*.log", "*.pdf", "*.docx", "*.xlsx", "*.pptx", "*.csv", "*.json", "*.xml",
                      "*.yaml", "*.ini", "*.html", "*.js", "*.py"]

        path_patterns = ",".join(f"'{current_dir}\\{ext}'" for ext in extensions)
        escaped_pattern = user_input.replace("'", "''")

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"Select-String -Path {path_patterns} -Pattern '{escaped_pattern}' -Recurse"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff5-code "):
        user_input = user_input[10:].strip()
        current_dir = Path.cwd().resolve()

        extensions = ["*.py", "*.pyc", "*.pyo", "*.ipynb", "*.r", "*.rmd", "*.jl", "*.m", "*.nb", "*.nbp", "*.sage",
                      "*.scm", "*.ss", "*.clj", "*.cljs", "*.cljc", "*.edn",
                      "*.c", "*.cpp", "*.cc", "*.cxx", "*.h", "*.hpp", "*.hh", "*.hxx", "*.cs", "*.java", "*.kt",
                      "*.kts", "*.scala", "*.go", "*.rs", "*.swift", "*.dart",
                      "*.ts", "*.tsx", "*.js", "*.jsx", "*.mjs", "*.cjs", "*.php", "*.phtml", "*.php3", "*.php4",
                      "*.php5", "*.rb", "*.pl", "*.pm", "*.lua", "*.vb", "*.vbs",
                      "*.asm", "*.s", "*.f", "*.f90", "*.f95", "*.pas", "*.pp", "*.d", "*.nim", "*.ada", "*.adb",
                      "*.ads", "*.lisp", "*.el", "*.cl", "*.ex", "*.exs", "*.erl",
                      "*.hrl", "*.ml", "*.mli", "*.mll", "*.mly", "*.groovy", "*.gvy", "*.gy", "*.gsh", "*.tcl", "*.tk",
                      "*.coffee", "*.sc", "*.rkt", "*.hs", "*.lhs", "*.fs",
                      "*.fsi", "*.fsx", "*.fsscript", "*.n", "*.nqc", "*.v", "*.vh", "*.sv", "*.svh", "*.vhdl", "*.vhd",
                      "*.html", "*.htm", "*.xhtml", "*.css", "*.scss", "*.less", "*.xml", "*.json", "*.yaml", "*.yml",
                      "*.toml", "*.ini", "*.env", "*.cfg", "*.conf",
                      "*.sql", "*.db", "*.sqlite", "*.mdb", "*.accdb", "*.csv", "*.tsv", "*.parquet", "*.avro", "*.orc",
                      "*.hdf5", "*.feather", "*.arrow",
                      "*.sh", "*.bash", "*.zsh", "*.ksh", "*.csh", "*.bat", "*.cmd", "*.ps1", "*.psm1", "*.psd1",
                      "*.scpt", "*.applescript", "*.vbs", "*.wsf",
                      "*.make", "*.mak", "*.cmake", "*.gradle", "*.pom", "*.build", "*.proj", "*.sln", "*.csproj",
                      "*.vcxproj", "*.xcodeproj", "*.ninja",
                      "*.md", "*.markdown", "*.rst", "*.asciidoc", "*.adoc", "*.tex", "*.latex", "*.bib", "*.doc",
                      "*.docx", "*.odt", "*.pdf",
                      "*.properties", "*.settings", "*.prefs", "*.config", "*.cfg", "*.conf", "*.ini", "*.toml",
                      "*.yaml", "*.yml", "*.json",
                      "*.log", "*.out", "*.err", "*.bak", "*.tmp", "*.lock", "*.pid", "*.swp", "*.swo", "*.orig",
                      "*.rej",
                      "*.vue", "*.svelte", "*.astro", "*.elm", "*.purs", "*.res", "*.re", "*.ml", "*.mli", "*.mll",
                      "*.mly", "*.zig", "*.vala", "*.vapi", "*.nim", "*.nimble",
                      "*.ktm", "*.kts", "*.cl", "*.clw", "*.cls", "*.m", "*.mm", "*.ml", "*.mli", "*.mll", "*.mly",
                      "*.fs", "*.fsi", "*.fsx", "*.fsscript",
                      "*.r", "*.rmd", "*.rhtml", "*.rxml", "*.rjs", "*.rpy", "*.rpyc", "*.rbc", "*.rbw", "*.erb",
                      "*.haml", "*.slim", "*.liquid",
                      "*.ejs", "*.hbs", "*.mustache", "*.pug", "*.jade", "*.njk", "*.nunjucks", "*.twig", "*.blade.php",
                      "*.latte", "*.volt", "*.tmpl", "*.tpl",
                      "*.jsp", "*.jspx", "*.asp", "*.aspx", "*.ascx", "*.ashx", "*.asmx", "*.cshtml", "*.vbhtml",
                      "*.cgi", "*.fcgi", "*.pl", "*.pm", "*.t", "*.pod", "*.psgi",
                      "*.ex", "*.exs", "*.eex", "*.leex", "*.heex",
                      "*.erl", "*.hrl", "*.yaws",
                      "*.lisp", "*.el", "*.cl", "*.scm", "*.ss", "*.rkt", "*.rktl", "*.rktd",
                      "*.hs", "*.lhs", "*.purs", "*.agda", "*.lagda", "*.lagda.tex",
                      "*.ml", "*.mli", "*.mll", "*.mly",
                      "*.fs", "*.fsi", "*.fsx", "*.fsscript",
                      "*.d", "*.di",
                      "*.nim", "*.nims", "*.nimble",
                      "*.vala", "*.vapi",
                      "*.zig",
                      "*.v", "*.vh", "*.sv", "*.svh", "*.vhdl", "*.vhd",
                      "*.q", "*.ql", "*.qvs",
                      "*.sas", "*.sas7bdat", "*.sas7bcat", "*.sas7bvew", "*.sast", "*.sastat", "*.sasm", "*.sasmacr",
                      "*.sascfg", "*.sasxpt",
                      "*.spv", "*.spo", "*.sps", "*.sav", "*.zsav", "*.por",
                      "*.dta",
                      "*.do", "*.ado", "*.dta", "*.gph",
                      "*.m", "*.mat", "*.fig", "*.mex", "*.mexw32", "*.mexw64", "*.mexmaci64",
                      "*.ipynb", "*.py", "*.pyc", "*.pyo", "*.pyd", "*.pyw", "*.pyz",
                      "*.r", "*.rdata", "*.rds", "*.rda", "*.rmd", "*.rproj",
                      "*.jl", "*.jld", "*.jld2", "*.bson", "*.feather", "*.parquet",
                      "*.csv", "*.tsv", "*.xls", "*.xlsx", "*.ods",
                      "*.json", "*.jsonl", "*.ndjson", "*.yaml", "*.yml", "*.toml", "*.ini", "*.cfg", "*.conf",
                      "*.xml", "*.xsd", "*.xsl", "*.xslt", "*.dtd",
                      "*.sql", "*.sqlite", "*.db", "*.dbf", "*.mdb", "*.accdb",
                      "*.hdf5", "*.h5", "*.nc", "*.cdf", "*.grib", "*.grb", "*.grb2",
                      "*.npz", "*.npy", "*.mat", "*.rda", "*.rds", "*.feather", "*.parquet",
                      "*.log", "*.out", "*.err", "*.txt", "*.md", "*.rst", "*.adoc", "*.asciidoc",
                      "*.tex", "*.bib", "*.cls", "*.sty", "*.dtx", "*.ins",
                      "*.pdf", "*.ps", "*.eps", "*.svg", "*.png", "*.jpg", "*.jpeg", "*.gif", "*.bmp", "*.tiff",
                      "*.mp3", "*.wav", "*.flac", "*.ogg", "*.m4a", "*.aac", "*.wma",
                      "*.mp4", "*.mkv", "*.avi", "*.mov", "*.wmv", "*.flv", "*.webm",
                      "*.zip", "*.tar", "*.gz", "*.bz2", "*.xz", "*.7z", "*.rar", "*.iso", "*.dmg",
                      "*.exe", "*.msi", "*.apk", "*.app", "*.deb", "*.rpm", "*.bin", "*.run", "*.sh", "*.bat", "*.cmd",
                      "*.ps1",
                      "*.dll", "*.so", "*.dylib", "*.a", "*.lib", "*.o", "*.obj",
                      "*.jar", "*.war", "*.ear", "*.class", "*.dex", "*.apk", "*.aar",
                      "*.xpi", "*.crx", "*.nex", "*.appx", "*.appxbundle", "*.msix", "*.msixbundle",
                      "*.vbox", "*.vbox-prev", "*.vdi", "*.vmdk", "*.vhd", "*.vhdx", "*.qcow", "*.qcow2", "*.img",
                      "*.ovf", "*.ova", "*.iso", "*.img", "*.dmg",
                      "*.pem", "*.crt", "*.cer", "*.key", "*.csr", "*.pfx", "*.p12", "*.der", "*.jks", "*.keystore",
                      "*.asc", "*.sig", "*.gpg", "*.pgp",
                      "*.log", "*.bak", "*.old", "*.tmp", "*.swp", "*.swo", "*.lock", "*.pid",
                      "*.torrent", "*.nzb", "*.magnet",
                      "*.ics", "*.vcf", "*.vcs", "*.ical", "*.icalendar",
                      "*.eml", "*.msg", "*.mbox", "*.pst", "*.ost",
                      "*.srt", "*.sub", "*.ass", "*.ssa", "*.vtt",
                      "*.cue", "*.bin", "*.iso", "*.nrg", "*.mds", "*.mdf", "*.ccd", "*.img", "*.toast",
                      "*.cue", "*.ape", "*.flac", "*.wv", "*.tta", "*.tak", "*.alac", "*.m4a",
                      "*.sfv", "*.md5", "*.sha1", "*.sha256", "*.sha512",
                      "*.torrent", "*.nzb", "*.magnet",
                      "*.ics", "*.vcf", "*.vcs", "*.ical", "*.icalendar",
                      "*.eml", "*.msg", "*.mbox", "*.pst", "*.ost",
                      "*.srt", "*.sub", "*.ass", "*.ssa", "*.vtt",
                      "*.cue", "*.bin", "*.iso", "*.nrg", "*.mds", "*.mdf", "*.ccd", "*.img", "*.toast",
                      "*.cue", "*.ape", "*.flac", "*.wv", "*.tta", "*.tak", "*.al"]

        path_patterns = ",".join(f"'{current_dir}\\{ext}'" for ext in extensions)
        escaped_pattern = user_input.replace("'", "''")

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"Select-String -Path {path_patterns} -Pattern '{escaped_pattern}' -Recurse"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff-word-code-fast "):
        user_input = user_input[19:].strip()
        current_dir = Path.cwd().resolve()

        extensions = ["*.py", "*.pyc", "*.pyo", "*.ipynb", "*.r", "*.rmd", "*.jl", "*.m", "*.nb", "*.nbp", "*.sage",
                      "*.scm", "*.ss", "*.clj", "*.cljs", "*.cljc", "*.edn",
                      "*.c", "*.cpp", "*.cc", "*.cxx", "*.h", "*.hpp", "*.hh", "*.hxx", "*.cs", "*.java", "*.kt",
                      "*.kts", "*.scala", "*.go", "*.rs", "*.swift", "*.dart",
                      "*.ts", "*.tsx", "*.js", "*.jsx", "*.mjs", "*.cjs", "*.php", "*.phtml", "*.php3", "*.php4",
                      "*.php5", "*.rb", "*.pl", "*.pm", "*.lua", "*.vb", "*.vbs",
                      "*.asm", "*.s", "*.f", "*.f90", "*.f95", "*.pas", "*.pp", "*.d", "*.nim", "*.ada", "*.adb",
                      "*.ads", "*.lisp", "*.el", "*.cl", "*.ex", "*.exs", "*.erl",
                      "*.hrl", "*.ml", "*.mli", "*.mll", "*.mly", "*.groovy", "*.gvy", "*.gy", "*.gsh", "*.tcl", "*.tk",
                      "*.coffee", "*.sc", "*.rkt", "*.hs", "*.lhs", "*.fs",
                      "*.fsi", "*.fsx", "*.fsscript", "*.n", "*.nqc", "*.v", "*.vh", "*.sv", "*.svh", "*.vhdl", "*.vhd",
                      "*.html", "*.htm", "*.xhtml", "*.css", "*.scss", "*.less", "*.xml", "*.json", "*.yaml", "*.yml",
                      "*.toml", "*.ini", "*.env", "*.cfg", "*.conf",
                      "*.sql", "*.db", "*.sqlite", "*.mdb", "*.accdb", "*.csv", "*.tsv", "*.parquet", "*.avro", "*.orc",
                      "*.hdf5", "*.feather", "*.arrow",
                      "*.sh", "*.bash", "*.zsh", "*.ksh", "*.csh", "*.bat", "*.cmd", "*.ps1", "*.psm1", "*.psd1",
                      "*.scpt", "*.applescript", "*.vbs", "*.wsf",
                      "*.make", "*.mak", "*.cmake", "*.gradle", "*.pom", "*.build", "*.proj", "*.sln", "*.csproj",
                      "*.vcxproj", "*.xcodeproj", "*.ninja",
                      "*.md", "*.markdown", "*.rst", "*.asciidoc", "*.adoc", "*.tex", "*.latex", "*.bib", "*.doc",
                      "*.docx", "*.odt", "*.pdf",
                      "*.properties", "*.settings", "*.prefs", "*.config", "*.cfg", "*.conf", "*.ini", "*.toml",
                      "*.yaml", "*.yml", "*.json",
                      "*.log", "*.out", "*.err", "*.bak", "*.tmp", "*.lock", "*.pid", "*.swp", "*.swo", "*.orig",
                      "*.rej",
                      "*.vue", "*.svelte", "*.astro", "*.elm", "*.purs", "*.res", "*.re", "*.ml", "*.mli", "*.mll",
                      "*.mly", "*.zig", "*.vala", "*.vapi", "*.nim", "*.nimble",
                      "*.ktm", "*.kts", "*.cl", "*.clw", "*.cls", "*.m", "*.mm", "*.ml", "*.mli", "*.mll", "*.mly",
                      "*.fs", "*.fsi", "*.fsx", "*.fsscript",
                      "*.r", "*.rmd", "*.rhtml", "*.rxml", "*.rjs", "*.rpy", "*.rpyc", "*.rbc", "*.rbw", "*.erb",
                      "*.haml", "*.slim", "*.liquid",
                      "*.ejs", "*.hbs", "*.mustache", "*.pug", "*.jade", "*.njk", "*.nunjucks", "*.twig", "*.blade.php",
                      "*.latte", "*.volt", "*.tmpl", "*.tpl",
                      "*.jsp", "*.jspx", "*.asp", "*.aspx", "*.ascx", "*.ashx", "*.asmx", "*.cshtml", "*.vbhtml",
                      "*.cgi", "*.fcgi", "*.pl", "*.pm", "*.t", "*.pod", "*.psgi",
                      "*.ex", "*.exs", "*.eex", "*.leex", "*.heex",
                      "*.erl", "*.hrl", "*.yaws",
                      "*.lisp", "*.el", "*.cl", "*.scm", "*.ss", "*.rkt", "*.rktl", "*.rktd",
                      "*.hs", "*.lhs", "*.purs", "*.agda", "*.lagda", "*.lagda.tex",
                      "*.ml", "*.mli", "*.mll", "*.mly",
                      "*.fs", "*.fsi", "*.fsx", "*.fsscript",
                      "*.d", "*.di",
                      "*.nim", "*.nims", "*.nimble",
                      "*.vala", "*.vapi",
                      "*.zig",
                      "*.v", "*.vh", "*.sv", "*.svh", "*.vhdl", "*.vhd",
                      "*.q", "*.ql", "*.qvs",
                      "*.sas", "*.sas7bdat", "*.sas7bcat", "*.sas7bvew", "*.sast", "*.sastat", "*.sasm", "*.sasmacr",
                      "*.sascfg", "*.sasxpt",
                      "*.spv", "*.spo", "*.sps", "*.sav", "*.zsav", "*.por",
                      "*.dta",
                      "*.do", "*.ado", "*.dta", "*.gph",
                      "*.m", "*.mat", "*.fig", "*.mex", "*.mexw32", "*.mexw64", "*.mexmaci64",
                      "*.ipynb", "*.py", "*.pyc", "*.pyo", "*.pyd", "*.pyw", "*.pyz",
                      "*.r", "*.rdata", "*.rds", "*.rda", "*.rmd", "*.rproj",
                      "*.jl", "*.jld", "*.jld2", "*.bson", "*.feather", "*.parquet",
                      "*.csv", "*.tsv", "*.xls", "*.xlsx", "*.ods",
                      "*.json", "*.jsonl", "*.ndjson", "*.yaml", "*.yml", "*.toml", "*.ini", "*.cfg", "*.conf",
                      "*.xml", "*.xsd", "*.xsl", "*.xslt", "*.dtd",
                      "*.sql", "*.sqlite", "*.db", "*.dbf", "*.mdb", "*.accdb",
                      "*.hdf5", "*.h5", "*.nc", "*.cdf", "*.grib", "*.grb", "*.grb2",
                      "*.npz", "*.npy", "*.mat", "*.rda", "*.rds", "*.feather", "*.parquet",
                      "*.log", "*.out", "*.err", "*.txt", "*.md", "*.rst", "*.adoc", "*.asciidoc",
                      "*.tex", "*.bib", "*.cls", "*.sty", "*.dtx", "*.ins",
                      "*.pdf", "*.ps", "*.eps", "*.svg", "*.png", "*.jpg", "*.jpeg", "*.gif", "*.bmp", "*.tiff",
                      "*.mp3", "*.wav", "*.flac", "*.ogg", "*.m4a", "*.aac", "*.wma",
                      "*.mp4", "*.mkv", "*.avi", "*.mov", "*.wmv", "*.flv", "*.webm",
                      "*.zip", "*.tar", "*.gz", "*.bz2", "*.xz", "*.7z", "*.rar", "*.iso", "*.dmg",
                      "*.exe", "*.msi", "*.apk", "*.app", "*.deb", "*.rpm", "*.bin", "*.run", "*.sh", "*.bat", "*.cmd",
                      "*.ps1",
                      "*.dll", "*.so", "*.dylib", "*.a", "*.lib", "*.o", "*.obj",
                      "*.jar", "*.war", "*.ear", "*.class", "*.dex", "*.apk", "*.aar",
                      "*.xpi", "*.crx", "*.nex", "*.appx", "*.appxbundle", "*.msix", "*.msixbundle",
                      "*.vbox", "*.vbox-prev", "*.vdi", "*.vmdk", "*.vhd", "*.vhdx", "*.qcow", "*.qcow2", "*.img",
                      "*.ovf", "*.ova", "*.iso", "*.img", "*.dmg",
                      "*.pem", "*.crt", "*.cer", "*.key", "*.csr", "*.pfx", "*.p12", "*.der", "*.jks", "*.keystore",
                      "*.asc", "*.sig", "*.gpg", "*.pgp",
                      "*.log", "*.bak", "*.old", "*.tmp", "*.swp", "*.swo", "*.lock", "*.pid",
                      "*.torrent", "*.nzb", "*.magnet",
                      "*.ics", "*.vcf", "*.vcs", "*.ical", "*.icalendar",
                      "*.eml", "*.msg", "*.mbox", "*.pst", "*.ost",
                      "*.srt", "*.sub", "*.ass", "*.ssa", "*.vtt",
                      "*.cue", "*.bin", "*.iso", "*.nrg", "*.mds", "*.mdf", "*.ccd", "*.img", "*.toast",
                      "*.cue", "*.ape", "*.flac", "*.wv", "*.tta", "*.tak", "*.alac", "*.m4a",
                      "*.sfv", "*.md5", "*.sha1", "*.sha256", "*.sha512",
                      "*.torrent", "*.nzb", "*.magnet",
                      "*.ics", "*.vcf", "*.vcs", "*.ical", "*.icalendar",
                      "*.eml", "*.msg", "*.mbox", "*.pst", "*.ost",
                      "*.srt", "*.sub", "*.ass", "*.ssa", "*.vtt",
                      "*.cue", "*.bin", "*.iso", "*.nrg", "*.mds", "*.mdf", "*.ccd", "*.img", "*.toast",
                      "*.cue", "*.ape", "*.flac", "*.wv", "*.tta", "*.tak", "*.al"]

        path_patterns = ",".join(f"'{current_dir}\\{ext}'" for ext in extensions)
        escaped_pattern = user_input.replace("'", "''")

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"Select-String -Path {path_patterns} -Pattern '{escaped_pattern}' -Recurse"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff5-config "):
        user_input = user_input[12:].strip()
        current_dir = Path.cwd().resolve()

        extensions = [
            "*.ini", "*.conf", "*.cfg", "*.cnf", "*.cf", "*.config", "*.yaml", "*.yml", "*.toml", "*.json",
            "*.xml", "*.properties", "*.plist", "*.desktop", "*.rc",
            "*.service", "*.target", "*.mount", "*.socket", "*.timer", "*.override", "*.env", "*.editorconfig",
            "*.htaccess", "*.dsconfig", "*.dsc", "*.pro", "*.reg", "*.sys", "*.hocon", "*.cson",
            "*.xsd", "*.xsl", "*.xslt", "*.dtd", "*.xproj", "*.xaml", "*.xmi", "*.xpl", "*.xproc", "*.xquery",
            "*.xq", "*.xql", "*.xqm", "*.xqy", "*.xs", "*.xslt", "*.xsl", "*.xojo_code", "*.xojo_menu",
            "*.xojo_report", "*.xojo_script", "*.xojo_toolbar", "*.xojo_window", "*.xtend", "*.yang"
        ]
        path_patterns = ",".join(f"'{current_dir}\\{ext}'" for ext in extensions)
        escaped_pattern = user_input.replace("'", "''")

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"Select-String -Path {path_patterns} -Pattern '{escaped_pattern}' -Recurse"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff-word-config-fast "):
        user_input = user_input[21:].strip()
        current_dir = Path.cwd().resolve()

        extensions = [
            "*.ini", "*.conf", "*.cfg", "*.cnf", "*.cf", "*.config", "*.yaml", "*.yml", "*.toml", "*.json",
            "*.xml", "*.properties", "*.plist", "*.desktop", "*.rc",
            "*.service", "*.target", "*.mount", "*.socket", "*.timer", "*.override", "*.env", "*.editorconfig",
            "*.htaccess", "*.dsconfig", "*.dsc", "*.pro", "*.reg", "*.sys", "*.hocon", "*.cson",
            "*.xsd", "*.xsl", "*.xslt", "*.dtd", "*.xproj", "*.xaml", "*.xmi", "*.xpl", "*.xproc", "*.xquery",
            "*.xq", "*.xql", "*.xqm", "*.xqy", "*.xs", "*.xslt", "*.xsl", "*.xojo_code", "*.xojo_menu",
            "*.xojo_report", "*.xojo_script", "*.xojo_toolbar", "*.xojo_window", "*.xtend", "*.yang"
        ]
        path_patterns = ",".join(f"'{current_dir}\\{ext}'" for ext in extensions)
        escaped_pattern = user_input.replace("'", "''")

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"Select-String -Path {path_patterns} -Pattern '{escaped_pattern}' -Recurse"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff5-scripts "):
        user_input = user_input[13:].strip()
        current_dir = Path.cwd().resolve()

        extensions = [
            "*.ahk", "*.applescript", "*.asp", "*.aspx", "*.awk", "*.bat", "*.bash", "*.btm", "*.cgi", "*.clj",
            "*.cljs", "*.cljc", "*.cmd", "*.csh", "*.dart",
            "*.edn", "*.el", "*.erb", "*.ex", "*.exs", "*.fish", "*.fs", "*.fsx", "*.fsi", "*.gsh", "*.groovy", "*.gvy",
            "*.gy", "*.jl", "*.js",
            "*.jse", "*.jsx", "*.ksh", "*.kt", "*.kts", "*.lisp", "*.lua", "*.mak", "*.make", "*.m", "*.mli", "*.mll",
            "*.mly", "*.mjs", "*.ml",
            "*.mm", "*.ncl", "*.nsi", "*.nsh", "*.nut", "*.pl", "*.pm", "*.ps1", "*.ps1xml", "*.psd1", "*.psm1",
            "*.psrc", "*.pssc", "*.py", "*.pyc",
            "*.pyo", "*.pyw", "*.r", "*.raku", "*.rakumod", "*.rakutest", "*.rb", "*.rkt", "*.rktd", "*.rktl", "*.rmd",
            "*.rex", "*.rexx", "*.run", "*.scpt",
            "*.scptd", "*.sh", "*.sps", "*.spt", "*.svm", "*.t", "*.tcsh", "*.tcl", "*.ts", "*.tsx", "*.vim", "*.vbs",
            "*.vbe", "*.wsf", "*.command",
            "*.coffee", "*.gradle", "*.scm"
        ]
        path_patterns = ",".join(f"'{current_dir}\\{ext}'" for ext in extensions)
        escaped_pattern = user_input.replace("'", "''")

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"Select-String -Path {path_patterns} -Pattern '{escaped_pattern}' -Recurse"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.startswith("pff-word-scripts-fast "):
        user_input = user_input[22:].strip()
        current_dir = Path.cwd().resolve()

        extensions = [
            "*.ahk", "*.applescript", "*.asp", "*.aspx", "*.awk", "*.bat", "*.bash", "*.btm", "*.cgi", "*.clj",
            "*.cljs", "*.cljc", "*.cmd", "*.csh", "*.dart",
            "*.edn", "*.el", "*.erb", "*.ex", "*.exs", "*.fish", "*.fs", "*.fsx", "*.fsi", "*.gsh", "*.groovy", "*.gvy",
            "*.gy", "*.jl", "*.js",
            "*.jse", "*.jsx", "*.ksh", "*.kt", "*.kts", "*.lisp", "*.lua", "*.mak", "*.make", "*.m", "*.mli", "*.mll",
            "*.mly", "*.mjs", "*.ml",
            "*.mm", "*.ncl", "*.nsi", "*.nsh", "*.nut", "*.pl", "*.pm", "*.ps1", "*.ps1xml", "*.psd1", "*.psm1",
            "*.psrc", "*.pssc", "*.py", "*.pyc",
            "*.pyo", "*.pyw", "*.r", "*.raku", "*.rakumod", "*.rakutest", "*.rb", "*.rkt", "*.rktd", "*.rktl", "*.rmd",
            "*.rex", "*.rexx", "*.run", "*.scpt",
            "*.scptd", "*.sh", "*.sps", "*.spt", "*.svm", "*.t", "*.tcsh", "*.tcl", "*.ts", "*.tsx", "*.vim", "*.vbs",
            "*.vbe", "*.wsf", "*.command",
            "*.coffee", "*.gradle", "*.scm"
        ]
        path_patterns = ",".join(f"'{current_dir}\\{ext}'" for ext in extensions)
        escaped_pattern = user_input.replace("'", "''")

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f"Select-String -Path {path_patterns} -Pattern '{escaped_pattern}' -Recurse"

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir} -> {user_input}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.lower() == "pff7":
        current_dir = Path.cwd().resolve()

        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

        command = f'Get-ChildItem -Path "{current_dir}" -Recurse | Where-Object {{ -not $_.PSIsContainer }}'

        process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        try:
            print(f"[{timestamp()}] [INFO] Search: {current_dir}")
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing pcf command: {e}")
        return True

    if user_input.lower() == "whoami":
        print(user_name)
        return True

    if user_input.lower() == "hostname":
        print(socket.gethostname())
        return True

    if user_input.lower() == "ip":
        try:
            hostname = socket.gethostname()
            ip_address = socket.gethostbyname(hostname)
            print(f"{main_color}IP Address{reset}: {ip_address}")
        except:
            print(f"[{timestamp()}] [ERROR] Could not retrieve IP address")
        return True

    if user_input.lower() == "os":
        print(f"{main_color}OS{reset}: {platform.system()} {platform.release()}")
        return True

    if user_input.lower() == "time":
        print(f"{timestamp()}")
        return True

    if user_input.lower() == "date":
        print(f"{timestamp()}")
        return True

    if user_input.lower() == "weather easy":
        get_weather()
        return True

    if user_input.startswith("open "):
        # Extrahiere und parse den Zielpfad / die URL
        try:
            parts = shlex.split(user_input, posix=not sys.platform.startswith("win"))
            if len(parts) < 2:
                print(f"[{timestamp()}] [ERROR] No destination specified.")
                return False
            else:
                target = parts[1]
                target_expanded = os.path.expandvars(os.path.expanduser(target))

                # URL erkennen
                if target_expanded.startswith(('http://', 'https://', 'ftp://')):
                    try:
                        webbrowser.open(target_expanded)
                        print(f"[{timestamp()}] [PASS] URL opened: {target_expanded}")
                        return True
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] URL could not be opened: {e}")
                        return False
                else:
                    # Prüfe Existenz im Dateisystem
                    if not os.path.exists(target_expanded):
                        print(f"[{timestamp()}] [ERROR] Not found: {target_expanded}")
                        return False
                    else:
                        try:
                            if sys.platform.startswith("win"):
                                os.startfile(target_expanded)
                            elif sys.platform.startswith("darwin"):
                                subprocess.Popen(["open", target_expanded])
                            else:
                                subprocess.Popen(["xdg-open", target_expanded])

                            print(f"[{timestamp()}] [PASS] Open: {target_expanded}")
                            return True
                        except Exception as e:
                            print(f"[{timestamp()}] [ERROR] Open failed: {e}")
                            return False
        except ValueError as e:
            print(f"[{timestamp()}] [ERROR] Parse error: {e}")
            return False

    if user_input.lower().startswith("3dslicer "):
        # Datei relativ zum aktuellen Verzeichnis interpretieren
        current_dir = Path.cwd().resolve()
        file_input = user_input[9:].strip()
        file_path = (current_dir / file_input).resolve()

        if not file_input:
            print(f"[{timestamp()}] [FAIL] No file specified for 3D Slicer.")
            return True
        elif not file_path.exists():
            print(f"[{timestamp()}] [FAIL] File not found: {file_path}")
            return True
        else:
            start_menu = os.path.join(
                os.environ["APPDATA"],
                r"Microsoft\Windows\Start Menu\Programs"
            )
            slicer_links = glob.glob(
                os.path.join(start_menu, "**", "Slicer *.lnk"),
                recursive=True
            )

            if not slicer_links:
                print(f"[{timestamp()}] [FAIL] 3D Slicer shortcut not found.")
                return True
            else:
                shell = win32com.client.Dispatch("WScript.Shell")
                slicer_exe = shell.CreateShortcut(slicer_links[0]).Targetpath

                if not os.path.exists(slicer_exe):
                    print(f"[{timestamp()}] [FAIL] Resolved Slicer executable not found: {slicer_exe}")
                    return True
                else:
                    try:
                        subprocess.Popen([slicer_exe, str(file_path)], shell=False)
                        print(f"[{timestamp()}] [PASS] File opened in 3D Slicer: {file_path}")
                        return True
                    except Exception as e:
                        print(f"[{timestamp()}] [FAIL] Could not open file in 3D Slicer: {e}")
                        return True

    if user_input.lower().startswith("p3ds "):
        # Datei relativ zum aktuellen Verzeichnis interpretieren
        current_dir = Path.cwd().resolve()
        file_input = user_input[5:].strip()
        file_path = (current_dir / file_input).resolve()

        if not file_input:
            print(f"[{timestamp()}] [FAIL] No file specified for 3D Slicer.")
            return True
        elif not file_path.exists():
            print(f"[{timestamp()}] [FAIL] File not found: {file_path}")
            return True
        else:
            start_menu = os.path.join(
                os.environ["APPDATA"],
                r"Microsoft\Windows\Start Menu\Programs"
            )
            slicer_links = glob.glob(
                os.path.join(start_menu, "**", "Slicer *.lnk"),
                recursive=True
            )

            if not slicer_links:
                print(f"[{timestamp()}] [FAIL] 3D Slicer shortcut not found.")
                return True
            else:
                shell = win32com.client.Dispatch("WScript.Shell")
                slicer_exe = shell.CreateShortcut(slicer_links[0]).Targetpath

                if not os.path.exists(slicer_exe):
                    print(f"[{timestamp()}] [FAIL] Resolved Slicer executable not found: {slicer_exe}")
                    return True
                else:
                    try:
                        subprocess.Popen([slicer_exe, str(file_path)], shell=False)
                        print(f"[{timestamp()}] [PASS] File opened in 3D Slicer: {file_path}")
                        return True
                    except Exception as e:
                        print(f"[{timestamp()}] [FAIL] Could not open file in 3D Slicer: {e}")
                        return True

    if user_input.lower() == "fortune":
        fortunes = [
            "You will code something amazing today!",
            "Trust your debugging skills!",
            "Error 404: Worries not found!",
            "Take a coffee break ☕️",
            "One commit a day keeps the bugs away!"
        ]
        print(random.choice(fortunes))
        return True

    if user_input.lower() == "history":
        handle_history_command()
        return True

    if user_input.lower() == "phi":
        handle_history_command()
        return True

    if user_input.startswith("search "):
        try:
            # Teilen Sie die Eingabe in Befehl, Dateiname und Schlüsselwort auf
            parts = user_input.split(maxsplit=2)
            if len(parts) < 3:
                print(f"[{timestamp()}] [INFO] Usage: search <filename> <keyword>")
                return True

            _, filename, keyword = parts

            # Öffnen Sie die Datei mit UTF-8-Kodierung
            with open(filename, "r", encoding="utf-8") as file:
                lines = file.readlines()

            # Suchen Sie in jeder Zeile nach dem Schlüsselwort, ohne Berücksichtigung der Groß- und Kleinschreibung
            matches = []
            for i, line in enumerate(lines, start=1):
                if keyword.lower() in line.lower():
                    matches.append(f"Line {i}: {line.rstrip()}")

            # Ausgabe der Ergebnisse oder einer entsprechenden Meldung, wenn keine Übereinstimmungen gefunden werden
            if matches:
                print("\n".join(matches))
            else:
                print(f"[{timestamp()}] [ERROR] No matches found.")

        except FileNotFoundError:
            print(f"[{timestamp()}] [ERROR] File not found: {filename}")
        except PermissionError:
            print(f"[{timestamp()}] [ERROR] No permission to read: {filename}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error during search: {str(e)}")
        return True

    if user_input.startswith("psf "):
        try:
            # Teilen Sie die Eingabe in Befehl, Dateiname und Schlüsselwort auf
            parts = user_input.split(maxsplit=2)
            if len(parts) < 3:
                print(f"[{timestamp()}] [INFO] Usage: search <filename> <keyword>")
                return True

            _, filename, keyword = parts

            # Öffnen Sie die Datei mit UTF-8-Kodierung
            with open(filename, "r", encoding="utf-8") as file:
                lines = file.readlines()

            # Suchen Sie in jeder Zeile nach dem Schlüsselwort, ohne Berücksichtigung der Groß- und Kleinschreibung
            matches = []
            for i, line in enumerate(lines, start=1):
                if keyword.lower() in line.lower():
                    matches.append(f"Line {i}: {line.rstrip()}")

            # Ausgabe der Ergebnisse oder einer entsprechenden Meldung, wenn keine Übereinstimmungen gefunden werden
            if matches:
                print("\n".join(matches))
            else:
                print(f"[{timestamp()}] [ERROR] No matches found.")

        except FileNotFoundError:
            print(f"[{timestamp()}] [ERROR] File not found: {filename}")
        except PermissionError:
            print(f"[{timestamp()}] [ERROR] No permission to read: {filename}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error during search: {str(e)}")
        return True

    # Erstellen Sie einen Zip-Ordner (optimiert für Windows)
    if user_input.startswith("zip "):
        try:
            # Befehl und Ordner aus der Eingabe extrahieren
            parts = user_input.split(maxsplit=1)
            if len(parts) < 2:
                print(f"[{timestamp()}] [INFO] Usage: zip <folder>")
                return True

            _, folder = parts
            # Normalisieren Sie den Pfad, besonders nützlich unter Windows
            folder_path = os.path.normpath(folder)

            # Überprüfen Sie, ob der Ordner vorhanden ist
            if not os.path.isdir(folder_path):
                print(f"{red}Error: Folder does not exist{reset}: {folder_path}")
                return True

            # Erstellen Sie das Archiv. Der Archivname entspricht dem Ordnernamen ohne Erweiterung.
            shutil.make_archive(folder_path, 'zip', folder_path)
            print(f"{green}Folder successfully zipped!{reset}")

        except FileNotFoundError:
            print(f"[{timestamp()}] [ERROR] Folder not found: {folder_path}")
        except PermissionError:
            print(f"[{timestamp()}] [ERROR] No permission to access the folder: {folder_path}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] while zipping the folder: {str(e)}")
        return True

    if user_input.startswith("pz "):
        try:
            # Befehl und Ordner aus der Eingabe extrahieren
            parts = user_input.split(maxsplit=1)
            if len(parts) < 2:
                print(f"[{timestamp()}] [INFO] Usage: zip <folder>")
                return True

            _, folder = parts
            # Normalisieren Sie den Pfad, besonders nützlich unter Windows
            folder_path = os.path.normpath(folder)

            # Überprüfen Sie, ob der Ordner vorhanden ist
            if not os.path.isdir(folder_path):
                print(f"{red}Error: Folder does not exist{reset}: {folder_path}")
                return True

            # Erstellen Sie das Archiv. Der Archivname entspricht dem Ordnernamen ohne Erweiterung.
            shutil.make_archive(folder_path, 'zip', folder_path)
            print(f"{green}Folder successfully zipped!{reset}")

        except FileNotFoundError:
            print(f"[{timestamp()}] [ERROR] Folder not found: {folder_path}")
        except PermissionError:
            print(f"[{timestamp()}] [ERROR] No permission to access the folder: {folder_path}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] while zipping the folder: {str(e)}")
        return True

    # Entpacken Sie ein Archiv (optimiert für Windows mit erweiterten Prüfungen)
    if user_input.startswith("unzip "):
        try:
            # Extrahieren Sie den Befehl und die ZIP-Datei aus der Eingabe
            parts = user_input.split(maxsplit=1)
            if len(parts) < 2:
                print(f"[{timestamp()}] [INFO] Usage: unzip <zip_file_path>")
                return True

            _, zip_path = parts
            # Normalisieren Sie den Pfad, besonders nützlich unter Windows
            zip_path = os.path.normpath(zip_path)

            # Überprüfen Sie, ob die Zip-Datei vorhanden ist und eine Datei ist
            if not os.path.isfile(zip_path):
                print(f"[{timestamp()}] [ERROR] File does not exist: {zip_path}")
                return True

            # Zielverzeichnis anhand des Dateinamens ohne Erweiterung ermitteln
            extract_dir = os.path.splitext(zip_path)[0]

            # Öffnen und entpacken Sie das Zip-Archiv
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(extract_dir)

            print(f"{green}Archive successfully extracted to:{reset} {extract_dir}")

        except zipfile.BadZipFile:
            print(f"[{timestamp()}] [ERROR] Invalid zip archive: {zip_path}")
        except PermissionError:
            print(f"[{timestamp()}] [ERROR] No permission to access the file: {zip_path}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error while extracting:{reset} {str(e)}")
        return True


    if user_input.startswith("puz "):
        try:
            # Extrahieren Sie den Befehl und die ZIP-Datei aus der Eingabe
            parts = user_input.split(maxsplit=1)
            if len(parts) < 2:
                print(f"[{timestamp()}] [INFO] Usage: unzip <zip_file_path>")
                return True

            _, zip_path = parts
            # Normalisieren Sie den Pfad, besonders nützlich unter Windows
            zip_path = os.path.normpath(zip_path)

            # Überprüfen Sie, ob die Zip-Datei vorhanden ist und eine Datei ist
            if not os.path.isfile(zip_path):
                print(f"[{timestamp()}] [ERROR] File does not exist: {zip_path}")
                return True

            # Zielverzeichnis anhand des Dateinamens ohne Erweiterung ermitteln
            extract_dir = os.path.splitext(zip_path)[0]

            # Öffnen und entpacken Sie das Zip-Archiv
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(extract_dir)

            print(f"{green}Archive successfully extracted to:{reset} {extract_dir}")

        except zipfile.BadZipFile:
            print(f"[{timestamp()}] [ERROR] Invalid zip archive: {zip_path}")
        except PermissionError:
            print(f"[{timestamp()}] [ERROR] No permission to access the file: {zip_path}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error while extracting:{reset} {str(e)}")
        return True

    # RAM- und CPU-Status
    if user_input.lower() == "sysinfo":
        print(f"{main_color}CPU Usage{reset}: {psutil.cpu_percent()}%")
        print(f"{main_color}RAM Usage{reset}: {psutil.virtual_memory().percent}%")
        return True

    # Inhalt der Zwischenablage festlegen (verbessert durch erweiterte Validierung und Fehlerbehandlung)
    if user_input.startswith("clip set "):
        try:
            # Extrahieren Sie den zu kopierenden Text und entfernen Sie führende und nachfolgende Leerzeichen
            text = user_input[len("clip set "):].strip()
            if not text:
                print(f"[{timestamp()}] [INFO] Usage: clip set <text>")
                return True

            # Text in die Zwischenablage kopieren
            pyperclip.copy(text)
            print(f"{green}Text successfully copied to clipboard!{reset}")
        except ImportError:
            print(
                f"[{timestamp()}] [ERROR] pyperclip module is not installed. Please install it with 'pip install pyperclip'")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error while copying to clipboard{reset}: {str(e)}")
        return True

    # Zwischenablage lesen
    if user_input.lower() == "clip get":
        print(pyperclip.paste())
        return True

    if user_input.lower().startswith("ping "):
        # Ziel extrahieren und validieren
        target = user_input.split(maxsplit=1)[1].strip()
        if not re.fullmatch(r"[A-Za-z0-9\.-]+", target):
            logging.error("Invalid destination: %r", target)
            return True

        # OS-gerechte Anzahl-Flag
        count_flag = "-n" if subprocess.os.name == "nt" else "-c"
        cmd = ["ping", count_flag, "4", target]

        try:
            # Konsolen-Codepage ermitteln (nur unter Windows relevant)
            if subprocess.os.name == "nt":
                cp = ctypes.windll.kernel32.GetConsoleOutputCP()
                encoding = f"cp{cp}"
            else:
                encoding = "utf-8"

            # Subprozess starten, Ausgabe als Bytes
            proc = subprocess.run(
                cmd,
                capture_output=True,
                timeout=10
            )

            # Jetzt selbst decodieren mit der passenden Codepage
            stdout = proc.stdout.decode(encoding, errors="replace")
            stderr = proc.stderr.decode(encoding, errors="replace")
        except subprocess.TimeoutExpired:
            logging.error("The ping command took too long and was aborted.")
        except Exception as e:
            logging.error("Error when running ping: %s", e)
        else:
            # Ausgabe und Exit-Code loggen
            if stdout:
                logging.info("Ping output:\n%s", stdout.strip())
            if stderr:
                logging.warning("Ping stderr:\n%s", stderr.strip())
            if proc.returncode != 0:
                logging.warning("Ping failed (Exit-Code %d).", proc.returncode)
        return True

    if user_input.lower().startswith("pping "):
        # Ziel extrahieren und validieren
        target = user_input.split(maxsplit=1)[1].strip()
        if not re.fullmatch(r"[A-Za-z0-9\.-]+", target):
            logging.error("Invalid destination: %r", target)
            return True

        # OS-gerechte Anzahl-Flag
        count_flag = "-n" if subprocess.os.name == "nt" else "-c"
        cmd = ["ping", count_flag, "4", target]

        try:
            # Konsolen-Codepage ermitteln (nur unter Windows relevant)
            if subprocess.os.name == "nt":
                cp = ctypes.windll.kernel32.GetConsoleOutputCP()
                encoding = f"cp{cp}"
            else:
                encoding = "utf-8"

            # Subprozess starten, Ausgabe als Bytes
            proc = subprocess.run(
                cmd,
                capture_output=True,
                timeout=10
            )

            # Jetzt selbst decodieren mit der passenden Codepage
            stdout = proc.stdout.decode(encoding, errors="replace")
            stderr = proc.stderr.decode(encoding, errors="replace")
        except subprocess.TimeoutExpired:
            logging.error("The ping command took too long and was aborted.")
        except Exception as e:
            logging.error("Error when running ping: %s", e)
        else:
            # Ausgabe und Exit-Code loggen
            if stdout:
                logging.info("Ping output:\n%s", stdout.strip())
            if stderr:
                logging.warning("Ping stderr:\n%s", stderr.strip())
            if proc.returncode != 0:
                logging.warning("Ping failed (Exit-Code %d).", proc.returncode)
        return True

    # Papierkorb leeren
    if user_input.lower() == "emptytrash":
        try:
            ctypes.windll.shell32.SHEmptyRecycleBinW(None, None, 0x00000001)
            print(f"[{timestamp()}] [PASS] Recycle Bin emptied!")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error emptying trash: {str(e)}")
        return True

    if user_input.lower() == "theme":
        print("alternative", "aptscience", "arc_dark", "aurelia", "ayu_mirage", "blue", "blueglass", "cyberlife",
              "dark", "dracula",
              "fallout_pipboy", "glass", "glassmain", "green", "greenglass", "gruvbox_dark", "hackerman", "light",
              "main", "material_dark",
              "mavis_1", "mavis_3", "mavis_4", "mint", "monokai", "nord", "one_dark", "p_term", "red", "redglass",
              "solarized_dark", "spiderman",
              "tokyo_night", "ubuntu", "ubuntuglass", "violetglass", "yellowglass")
        return True

    if user_input.lower() == "pin":
        print("main/main-1", "main-3", "main-4", "main-5", "main-6", "main-7", "main-8", "main-9", "main-10", "main-11",
              "main-12", "main-13", "main-14",
              "main-15", "main-16", "main-17", "main-18", "main-19", "main-20", "main-21", "main-22", "main-23",
              "main-24", "main-25", "main-26", "main-27",
              "main-28", "main-29", "main-30", "main-31", "main-32", "main-33", "main-34", "main-35", "evil/evil-1",
              "evil-2", "evil-3", "evil-4", "evil-5", "adv/adv-1", "adv-2", "adv-3", "adv-4", "adv-5",
              "stable/stable-1", "stable-2", "stable-3", "stable-4", "stable-5", "cool/cool-1", "cool-2", "cool-3",
              "cool-4", "cool-5", "cool-6", "cool-7",
              "cool-8", "cool-9", "cool-10", "cool-11", "cool-12", "cool-13", "cool-14", "cool-15", "cool-16",
              "cool-17", "cool-18", "cool-19", "cool-20",
              "cool-21", "cool-22", "cool-23")
        return True

    if user_input.startswith("launch "):
        command_str = user_input[len("launch "):].strip()

        # Leere Eingabe abfangen
        if not command_str:
            logging.error("[ERROR] No program specified after 'launch'.")
            return False  # Frühzeitige Rückgabe, falls kein Programmname angegeben wurde

        try:
            # Platform-spezifische Befehlsausführung
            if sys.platform == "win32":
                # Auf Windows: Verwende 'start' im Shell-Modus
                safe_cmd = f'start "" {shlex.quote(command_str)}'
                subprocess.Popen(safe_cmd, shell=True)
            else:
                # Für Unix/macOS: Parsen des Programms und der Argumente direkt
                args = shlex.split(command_str)
                subprocess.Popen(args)

            logging.info("[INFO] Program launched: %s", command_str)
            return True  # Erfolgreiche Ausführung, Rückgabe True

        except FileNotFoundError:
            logging.error("[ERROR] Program not found: %s", command_str)
        except Exception as e:
            logging.exception("[ERROR] Error launching %s: %s", command_str, str(e))

        return False

    if user_input.startswith("pr-app "):
        user_input = user_input[7:].strip()
        command_str = user_input[len("launch "):].strip()

        # Leere Eingabe abfangen
        if not command_str:
            logging.error("[ERROR] No program specified after 'launch'.")
            return False  # Frühzeitige Rückgabe, falls kein Programmname angegeben wurde

        try:
            # Platform-spezifische Befehlsausführung
            if sys.platform == "win32":
                # Auf Windows: Verwende 'start' im Shell-Modus
                safe_cmd = f'start "" {shlex.quote(command_str)}'
                subprocess.Popen(safe_cmd, shell=True)
            else:
                # Für Unix/macOS: Parsen des Programms und der Argumente direkt
                args = shlex.split(command_str)
                subprocess.Popen(args)

            logging.info("[INFO] Program launched: %s", command_str)
            return True  # Erfolgreiche Ausführung, Rückgabe True

        except FileNotFoundError:
            logging.error("[ERROR] Program not found: %s", command_str)
        except Exception as e:
            logging.exception("[ERROR] Error launching %s: %s", command_str, str(e))

        return False

    if user_input.startswith("run-app "):
        user_input = user_input[8:].strip()
        command_str = user_input[len("launch "):].strip()

        # Leere Eingabe abfangen
        if not command_str:
            logging.error("[ERROR] No program specified after 'launch'.")
            return False  # Frühzeitige Rückgabe, falls kein Programmname angegeben wurde

        try:
            # Platform-spezifische Befehlsausführung
            if sys.platform == "win32":
                # Auf Windows: Verwende 'start' im Shell-Modus
                safe_cmd = f'start "" {shlex.quote(command_str)}'
                subprocess.Popen(safe_cmd, shell=True)
            else:
                # Für Unix/macOS: Parsen des Programms und der Argumente direkt
                args = shlex.split(command_str)
                subprocess.Popen(args)

            logging.info("[INFO] Program launched: %s", command_str)
            return True  # Erfolgreiche Ausführung, Rückgabe True

        except FileNotFoundError:
            logging.error("[ERROR] Program not found: %s", command_str)
        except Exception as e:
            logging.exception("[ERROR] Error launching %s: %s", command_str, str(e))

        return False

    if user_input.startswith("pr-file "):
        user_input = user_input[8:].strip()
        # Extrahiere und parse den Zielpfad / die URL
        try:
            parts = shlex.split(user_input, posix=not sys.platform.startswith("win"))
            if len(parts) < 2:
                print(f"[{timestamp()}] [ERROR] No destination specified.")
                return False
            else:
                target = parts[1]
                target_expanded = os.path.expandvars(os.path.expanduser(target))

                # URL erkennen
                if target_expanded.startswith(('http://', 'https://', 'ftp://')):
                    try:
                        webbrowser.open(target_expanded)
                        print(f"[{timestamp()}] [PASS] URL opened: {target_expanded}")
                        return True
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] URL could not be opened: {e}")
                        return False
                else:
                    # Prüfe Existenz im Dateisystem
                    if not os.path.exists(target_expanded):
                        print(f"[{timestamp()}] [ERROR] Not found: {target_expanded}")
                        return False
                    else:
                        try:
                            if sys.platform.startswith("win"):
                                os.startfile(target_expanded)
                            elif sys.platform.startswith("darwin"):
                                subprocess.Popen(["open", target_expanded])
                            else:
                                subprocess.Popen(["xdg-open", target_expanded])

                            print(f"[{timestamp()}] [PASS] Open: {target_expanded}")
                            return True
                        except Exception as e:
                            print(f"[{timestamp()}] [ERROR] Open failed: {e}")
                            return False
        except ValueError as e:
            print(f"[{timestamp()}] [ERROR] Parse error: {e}")
            return False

    # Speedtest
    if user_input.lower() == "speedtest":
        try:
            # Ladebalken während der Speedtest läuft
            loading_bar("Running speedtest", 5)

            # Speedtest-Instanz
            st = speedtest.Speedtest()

            # Download- und Upload-Geschwindigkeiten in Mbit/s
            download = st.download() / 1_000_000  # Konvertieren von Bits in Mbit/s
            upload = st.upload() / 1_000_000  # Konvertieren von Bits in Mbit/s

            # Ping abrufen (Latenz)
            ping = st.results.ping

            # Drucken Sie die Ergebnisse in einem coolen Format aus
            print(f"{main_color}Download{reset}: {download:.2f} Mbps")
            print(f"{main_color}Upload{reset}: {upload:.2f} Mbps")
            print(f"{main_color}Ping{reset}: {ping} ms")

            return True

        except Exception as e:
            # Wenn etwas schief geht, zeigen Sie den Fehler
            print(f"[{timestamp()}] [ERROR] Whoops, something went wrong with the speedtest: {e}")
            return False

    if user_input == "setting":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:", shell=True, check=False)

    if user_input == "workplace":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:workplace", shell=True, check=False)

    if user_input == "emailandaccounts":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:emailandaccounts", shell=True, check=False)

    if user_input == "otherusers":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:otherusers", shell=True, check=False)

    if user_input == "assignedaccess":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:assignedaccess", shell=True, check=False)

    if user_input == "signinoptions":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:signinoptions", shell=True, check=False)

    if user_input == "sync":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:sync", shell=True, check=False)

    if user_input == "yourinfo":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:yourinfo", shell=True, check=False)

    if user_input == "hello-face":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:signinoptions-launchfaceenrollment", shell=True, check=False)

    if user_input == "hello-fingerprint":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:signinoptions-launchfingerprintenrollment", shell=True, check=False)

    if user_input == "appsfeatures":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:appsfeatures", shell=True, check=False)

    if user_input == "appsfeatures-app":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:appsfeatures-app", shell=True, check=False)

    if user_input == "appsforwebsites":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:appsforwebsites", shell=True, check=False)

    if user_input == "defaultapps":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:defaultapps", shell=True, check=False)

    if user_input == "optionalfeatures":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:optionalfeatures", shell=True, check=False)

    if user_input == "maps":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:maps", shell=True, check=False)

    if user_input == "startupapps":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:startupapps", shell=True, check=False)

    if user_input == "videoplayback":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:videoplayback", shell=True, check=False)

    if user_input == "autoplay":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:autoplay", shell=True, check=False)

    if user_input == "bluetooth":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:bluetooth", shell=True, check=False)

    if user_input == "camera":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:camera", shell=True, check=False)

    if user_input == "mousetouchpad":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:mousetouchpad", shell=True, check=False)

    if user_input == "pen":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:pen", shell=True, check=False)

    if user_input == "printers":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:printers", shell=True, check=False)

    if user_input == "usb":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:usb", shell=True, check=False)

    if user_input == "display":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:display", shell=True, check=False)

    if user_input == "sound":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:sound", shell=True, check=False)

    if user_input == "notifications":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:notifications", shell=True, check=False)

    if user_input == "power":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:powersleep", shell=True, check=False)

    if user_input == "storage":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:storage", shell=True, check=False)

    if user_input == "multitasking":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:multitasking", shell=True, check=False)

    if user_input == "network-status":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:network-status", shell=True, check=False)

    if user_input == "wifi":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:network-wifi", shell=True, check=False)

    if user_input == "ethernet":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:network-ethernet", shell=True, check=False)

    if user_input == "vpn":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:network-vpn", shell=True, check=False)

    if user_input == "datausage":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:datausage", shell=True, check=False)

    if user_input == "privacy-microphone":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-microphone", shell=True, check=False)

    if user_input == "privacy-webcam":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-webcam", shell=True, check=False)

    if user_input == "privacy-location":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-location", shell=True, check=False)

    if user_input == "privacy-notifications":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-notifications", shell=True, check=False)

    if user_input == "windowsupdate":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:windowsupdate", shell=True, check=False)

    if user_input == "backup":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:backup", shell=True, check=False)

    if user_input == "recovery":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:recovery", shell=True, check=False)

    if user_input == "activation":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:activation", shell=True, check=False)

    if user_input == "fordevelopers":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:developers", shell=True, check=False)

    if user_input == "airplanemode":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:airplanemode", shell=True, check=False)

    if user_input == "cellular":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:cellular", shell=True, check=False)

    if user_input == "cloudstorage":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:cloudstorage", shell=True, check=False)

    if user_input == "language":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:language", shell=True, check=False)

    if user_input == "location":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:location", shell=True, check=False)

    if user_input == "lock":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:lock", shell=True, check=False)

    if user_input == "nfctransactions":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:nfctransactions", shell=True, check=False)

    if user_input == "proximity":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-proximity", shell=True, check=False)

    if user_input == "mobilehotspot":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:network-mobilehotspot", shell=True, check=False)

    if user_input == "proxy":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:network-proxy", shell=True, check=False)

    if user_input == "defender":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:windowsdefender", shell=True, check=False)

    if user_input == "privacy-contacts":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-contacts", shell=True, check=False)

    if user_input == "privacy-calendar":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-calendar", shell=True, check=False)

    if user_input == "privacy-callhistory":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-callhistory", shell=True, check=True)

    if user_input == "family":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:family", shell=True, check=False)

    if user_input == "gaming-gamebar":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:gaming-gamebar", shell=True, check=False)

    if user_input == "mixedreality-portal":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:mixedreality-portal", shell=True, check=False)

    if user_input == "easeofaccess":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:easeofaccess", shell=True, check=False)

    if user_input == "easeofaccess-narrator":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:easeofaccess-narrator", shell=True, check=False)

    if user_input == "easeofaccess-magnifier":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:easeofaccess-magnifier", shell=True, check=False)

    if user_input == "easeofaccess-closedcaptioning":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:easeofaccess-closedcaptioning", shell=True, check=False)

    if user_input == "easeofaccess-highcontrast":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:easeofaccess-highcontrast", shell=True, check=False)

    if user_input == "easeofaccess-speechrecognition":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:easeofaccess-speechrecognition", shell=True, check=False)

    if user_input == "easeofaccess-keyboard":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:easeofaccess-keyboard", shell=True, check=False)

    if user_input == "easeofaccess-mousepointer":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:easeofaccess-mousepointer", shell=True, check=False)

    if user_input == "easeofaccess-touch":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:easeofaccess-touch", shell=True, check=False)

    if user_input == "wirelessdisplay":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings-connectabledevices:devicediscovery", shell=True, check=False)

    if user_input == "project":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:project", shell=True, check=False)

    if user_input == "tethering":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:network-tethering", shell=True, check=False)

    if user_input == "storagesense":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:storagesense", shell=True, check=False)

    if user_input == "batterysaver":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:batterysaver-settings", shell=True, check=False)

    if user_input == "autorotate":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:screenrotation", shell=True, check=False)

    if user_input == "dateandtime":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:dateandtime", shell=True, check=False)

    if user_input == "region":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:region", shell=True, check=False)

    if user_input == "speech":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:regionlanguage-speech", shell=True, check=False)

    if user_input == "typing":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:typing", shell=True, check=False)

    if user_input == "troubleshoot":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:troubleshoot", shell=True, check=False)

    if user_input == "recommendedtroubleshoot":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:troubleshoot-recommended", shell=True, check=False)

    if user_input == "windowsinsider":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:windowsinsider", shell=True, check=False)

    if user_input == "gaming-broadcasting":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:gaming-broadcasting", shell=True, check=False)

    if user_input == "gaming-gamedvr":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:gaming-gamedvr", shell=True, check=False)

    if user_input == "gaming-xboxnetworking":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:gaming-xboxnetworking", shell=True, check=False)

    if user_input == "mixedreality-settings":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:mixedreality-portal", shell=True, check=False)

    if user_input == "display-advanced":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:display-advanced", shell=True, check=False)

    if user_input == "defaultbrowsersettings":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:defaultbrowsersettings", shell=True, check=False)

    if user_input == "maps-downloadmaps":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:maps-downloadmaps", shell=True, check=False)

    if user_input == "sound-devices":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:sound-devices", shell=True, check=False)

    if user_input == "devices-touch":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:devices-touch", shell=True, check=False)

    if user_input == "devices-touchpad":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:devices-touchpad", shell=True, check=False)

    if user_input == "devicestyping-hwkbtextsuggestions":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:devicestyping-hwkbtextsuggestions", shell=True, check=False)

    if user_input == "privacy-feedback":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-feedback", shell=True, check=False)

    if user_input == "privacy-diagnostics":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-diagnostics", shell=True, check=False)

    if user_input == "cortana":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:cortana", shell=True, check=False)

    if user_input == "cortana-permissions":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:cortana-permissions", shell=True, check=False)

    if user_input == "cortana-windowssearch":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:cortana-windowssearch", shell=True, check=False)

    if user_input == "cortana-moredetails":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:cortana-moredetails", shell=True, check=False)

    if user_input == "controlcenter":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:controlcenter", shell=True, check=False)

    if user_input == "mobile-devices":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:mobile-devices", shell=True, check=False)

    if user_input == "fonts":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:fonts", shell=True, check=False)

    if user_input == "wheel":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:wheel", shell=True, check=False)

    if user_input == "appsfeatures-app?PFN=<YourAppPFN>":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:appsfeatures-app?PFN=YourAppPFN", shell=True, check=False)

    if user_input == "backup-deprecated":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:backup", shell=True, check=False)

    if user_input == "provisioning":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:provisioning", shell=True, check=False)

    if user_input == "about":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:about", shell=True, check=False)

    if user_input == "uninstallupdates":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:uninstallupdates", shell=True, check=False)

    if user_input == "manage-restartapps":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:appsforwebsites", shell=True, check=False)

    if user_input == "startsettings":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:personalization-start", shell=True, check=False)

    if user_input == "taskbar":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:personalization-taskbar", shell=True, check=False)

    if user_input == "themes":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:themes", shell=True, check=False)

    if user_input == "colors":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:colors", shell=True, check=False)

    if user_input == "lockscreen":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:personalization-lockscreen", shell=True, check=False)

    if user_input == "background":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:personalization-background", shell=True, check=False)

    if user_input == "volume":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:apps-volume", shell=True, check=False)

    if user_input == "defaultbrowsersettings":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:defaultbrowsersettings", shell=True, check=False)

    if user_input == "firewall":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:windowsdefender-firewall", shell=True, check=False)

    if user_input == "securitycenter":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:windowsdefender-securitycenter", shell=True, check=False)

    if user_input == "surfacehub":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:surfacehub", shell=True, check=False)

    if user_input == "windowsanywhere":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:windowsanywhere", shell=True, check=False)

    if user_input == "privacy-accountinfo":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-accountinfo", shell=True, check=False)

    if user_input == "privacy-calendars":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-calendar", shell=True, check=False)

    if user_input == "privacy-radios":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-radios", shell=True, check=False)

    if user_input == "privacy-multimedia":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-media", shell=True, check=False)

    if user_input == "privacy-feedback":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-feedback", shell=True, check=False)

    if user_input == "regionlanguage":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:regionlanguage", shell=True, check=False)

    if user_input == "speechtyping":
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run("start ms-settings:privacy-speechtyping", shell=True, check=False)

    # Prozessliste
    if user_input.lower() == "ps":
        for proc in psutil.process_iter(['pid', 'name']):
            print(f"PID {proc.info['pid']}: {proc.info['name']}")
        return True

    if user_input.lower() == "ps-2":
        command = "powershell ps"

        process = run_command(command, shell=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing ls command: {e}")
        return True
    
    if user_input.lower() == "ps-3":
        command = "wsl ps"

        process = run_command(command, shell=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing ls command: {e}")
        return True

    if user_input.lower() == "ps-4":
        command = ["pwsh", "-Command", "ps"]

        process = run_command(command, shell=True)

        try:
            process.wait()
        except KeyboardInterrupt:
            print(f"[{timestamp()}] [INFO] Cancellation by user.")
        except subprocess.CalledProcessError as e:
            print(f"[{timestamp()}] [ERROR] executing ls command: {e}")
        return True

    if user_input.startswith("kill "):
        try:
            _, pid_str = user_input.split(maxsplit=1)
            pid = int(pid_str)
            process = psutil.Process(pid)

            process.terminate()  # Graceful termination
            gone, alive = psutil.wait_procs([process], timeout=3)

            if alive:
                # Falls Prozess nicht terminiert hat, sofort killen
                for p in alive:
                    p.kill()
                gone, alive = psutil.wait_procs(alive, timeout=3)

            if not alive:
                print(f"[{timestamp()}] [INFO] Process {pid} has been terminated.")
            else:
                print(f"[{timestamp()}] [WARNING] Process {pid} could not be killed.")

        except ValueError:
            print(f"[{timestamp()}] [ERROR] Invalid PID: '{pid_str}' is not a valid number.")
        except psutil.NoSuchProcess:
            print(f"[{timestamp()}] [ERROR] No process with PID {pid} found.")
        except psutil.AccessDenied:
            print(f"[{timestamp()}] [ERROR] Permission denied: Unable to terminate process {pid}.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Unexpected error while terminating process: {str(e)}")
        return True

    # Datei herunterladen
    if user_input.startswith("download "):

        try:
            # URL aus Eingabe extrahieren
            _, url = user_input.split(maxsplit=1)
            file_name = Path(url).name

            # Download mit Fortschrittsfeedback
            loading_bar(f"Downloading {file_name}", 4)
            response = requests.get(url, stream=True, timeout=10)
            response.raise_for_status()

            # Write content in chunks
            with open(file_name, "wb") as file:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        file.write(chunk)

            print(f"[{timestamp()}] [INFO] Downloaded {file_name}")
        except requests.HTTPError as http_err:
            print(f"[{timestamp()}] [ERROR] HTTP error during download: {http_err}")
        except requests.RequestException as req_err:
            print(f"[{timestamp()}] [ERROR] Request error during download: {req_err}")
        except Exception as err:
            print(f"[{timestamp()}] [ERROR] Unexpected error: {err}")
        return True

    # CPU Temperatur
    if user_input.lower() == "cputemp":
        """
        Returns the current CPU temperature in °C, or None if it cannot be determined.
        """
        try:
            # PowerShell command to query CPU temperature
            command = [
                "powershell.exe",
                "-Command",
                "(Get-WmiObject MSAcpi_ThermalZoneTemperature -Namespace 'root/wmi').CurrentTemperature / 10 - 273.15"
            ]

            # Execute the PowerShell command and capture the output
            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            stdout, stderr = process.communicate()

            # Error handling
            if process.returncode != 0:
                print(f"[{timestamp()}] [ERROR] Error retrieving CPU temperature: {stderr}")
                return None

            # Process the output and return the temperature in °C
            try:
                temperature = float(stdout.strip())
                return temperature
            except ValueError:
                print(f"[{timestamp()}] [ERROR] Invalid output when retrieving CPU temperature.")
                return None

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {e}")
            return None

    # Chuck Norris Joke
    if user_input.lower() == "chucknorris":
        try:
            joke = requests.get("https://api.chucknorris.io/jokes/random").json()['value']
            print(f"{main_color}Chuck Norris says{reset}: {joke}")
        except:
            print(f"[{timestamp()}] [ERROR] Couldn't fetch Chuck Norris joke!")
        return True

    # Theme Wechsel
    if user_input.startswith("theme "):
        switch_theme(user_input)
        return True

    if user_input.startswith("pcctheme "):
        user_input = user_input[9:].strip()
        create_custom_theme(user_input)
        return True

    # Temp Dateien löschen
    if user_input.lower() == "cleantemp":
        temp = os.getenv('TEMP') or os.getenv('TMP')  # Falls TEMP nicht gesetzt ist
        if not temp or not os.path.isdir(temp):
            print(f"[{timestamp()}] [ERROR] Temporary directory not found.")
            return True

        # Sicherheitscheck: nur löschen, wenn Pfad eindeutig TEMP-Verzeichnis ist
        # z.B. Vermeide versehentliches Löschen von Wurzelverzeichnissen
        if temp in ("C:\\", "C:\\Windows", "C:\\Windows\\System32", "/"):
            print(f"[{timestamp()}] [ERROR] Unsafe temporary directory path: {temp}. Abgebrochen.")
            return True

        try:
            # Alle Dateien und Ordner im TEMP löschen
            for entry in os.listdir(temp):
                path = os.path.join(temp, entry)
                try:
                    if os.path.isfile(path) or os.path.islink(path):
                        os.unlink(path)
                    elif os.path.isdir(path):
                        shutil.rmtree(path)
                except Exception as e:
                    print(f"[{timestamp()}] [WARNING] Fehler beim Löschen von {path}: {e}")

            print(f"[{timestamp()}] [INFO] Temporary files cleaned!")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Fehler beim Bereinigen des TEMP-Ordners: {e}")
        return True

    # Directory Baumansicht
    if user_input.lower() == "tree":
        def print_tree(startpath, prefix=""):
            for item in os.listdir(startpath):
                path = os.path.join(startpath, item)
                print(prefix + "|-- " + item)
                if os.path.isdir(path):
                    print_tree(path, prefix + "|   ")

        print_tree(os.getcwd())
        return True

    # Python REPL starten
    if user_input.strip().lower() == "py":
        import code as code_module

        load_dotenv()

        APP_NAME = os.getenv("APP_NAME", "p-terminal/pp-term").replace("\\", "/")
        USER_NAME = os.getenv("USER_NAME", os.getlogin())
        STATE_FILE = Path(f"C:/Users/{USER_NAME}/{APP_NAME}/current_env.json")

        print(f"[{timestamp()}] [INFO] Initializing Python REPL startup sequence...")
        print(f"[{timestamp()}] [INFO] Using STATE_FILE at: {STATE_FILE}")

        try:
            active = find_active_env()
            if active is None:
                raise ValueError("Active environment is None")
            print(f"[{timestamp()}] [INFO] Active environment successfully located.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Failed to find active environment: {e}")
            traceback.print_exc()
        else:
            print(f"[{timestamp()}] [INFO] Launching interactive Python REPL.")
            print(f"[{timestamp()}] [INFO] Type 'exit()' or press Ctrl-D to quit.")

            try:
                if isinstance(active, dict):
                    local_ns = active
                else:
                    try:
                        local_ns = vars(active)
                    except TypeError:
                        print(f"[{timestamp()}] [WARNING] Could not extract vars() from active object; using empty namespace.")
                        local_ns = {}

                local_ns['STATE_FILE'] = STATE_FILE

                code_module.interact(local=local_ns)

            except SystemExit:
                print(f"[{timestamp()}] [INFO] Exiting REPL via SystemExit.")
            except Exception as e:
                print(f"[{timestamp()}] [ERROR] Unhandled exception during REPL session: {e}")
                traceback.print_exc()
            finally:
                print(f"[{timestamp()}] [INFO] Python REPL session terminated.")

        return True

    # Python REPL starten
    if user_input.strip().lower() == "ppy":
        user_input = "py"
        import code as code_module

        load_dotenv()

        APP_NAME = os.getenv("APP_NAME", "p-terminal/pp-term").replace("\\", "/")
        USER_NAME = os.getenv("USER_NAME", os.getlogin())
        STATE_FILE = Path(f"C:/Users/{USER_NAME}/{APP_NAME}/current_env.json")

        print(f"[{timestamp()}] [INFO] Initializing Python REPL startup sequence...")
        print(f"[{timestamp()}] [INFO] Using STATE_FILE at: {STATE_FILE}")

        try:
            active = find_active_env()
            if active is None:
                raise ValueError("Active environment is None")
            print(f"[{timestamp()}] [INFO] Active environment successfully located.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Failed to find active environment: {e}")
            traceback.print_exc()
        else:
            print(f"[{timestamp()}] [INFO] Launching interactive Python REPL.")
            print(f"[{timestamp()}] [INFO] Type 'exit()' or press Ctrl-D to quit.")

            try:
                if isinstance(active, dict):
                    local_ns = active
                else:
                    try:
                        local_ns = vars(active)
                    except TypeError:
                        print(f"[{timestamp()}] [WARNING] Could not extract vars() from active object; using empty namespace.")
                        local_ns = {}

                local_ns['STATE_FILE'] = STATE_FILE

                code_module.interact(local=local_ns)

            except SystemExit:
                print(f"[{timestamp()}] [INFO] Exiting REPL via SystemExit.")
            except Exception as e:
                print(f"[{timestamp()}] [ERROR] Unhandled exception during REPL session: {e}")
                traceback.print_exc()
            finally:
                print(f"[{timestamp()}] [INFO] Python REPL session terminated.")

        return True

    if user_input.startswith("pb "):
        # Remove "pb " and strip any surrounding whitespace
        user_input = user_input[3:].strip()

        # Check if the input is not empty
        if not user_input:
            print(f"[{timestamp()}] [INFO] Please provide a valid URL after 'pb '.")
            return

        # Create the full URL
        url = f"https://{user_input}"

        # Try to open the URL in the browser
        try:
            webbrowser.open(url)
            print(f"[{timestamp()}] [INFO] The page is now opening: {url}")
            return True

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Error opening the URL: {e}")
            return True

    languages = {
        "afrikaans": "af",
        "albanian": "sq",
        "amharic": "am",
        "arabic": "ar",
        "armenian": "hy",
        "assamese": "as",
        "aymara": "ay",
        "azerbaijani": "az",
        "bambara": "bm",
        "basque": "eu",
        "belarusian": "be",
        "bengali": "bn",
        "bhojpuri": "bho",
        "bosnian": "bs",
        "bulgarian": "bg",
        "catalan": "ca",
        "cebuano": "ceb",
        "chichewa": "ny",
        "chinese (simplified)": "zh-CN",
        "chinese (traditional)": "zh-TW",
        "corsican": "co",
        "croatian": "hr",
        "czech": "cs",
        "danish": "da",
        "dhivehi": "dv",
        "dogri": "doi",
        "dutch": "nl",
        "english": "en",
        "esperanto": "eo",
        "estonian": "et",
        "ewe": "ee",
        "filipino": "tl",
        "finnish": "fi",
        "french": "fr",
        "frisian": "fy",
        "galician": "gl",
        "georgian": "ka",
        "german": "de",
        "greek": "el",
        "guarani": "gn",
        "gujarati": "gu",
        "haitian creole": "ht",
        "hausa": "ha",
        "hawaiian": "haw",
        "hebrew": "iw",
        "hindi": "hi",
        "hmong": "hmn",
        "hungarian": "hu",
        "icelandic": "is",
        "igbo": "ig",
        "ilocano": "ilo",
        "indonesian": "id",
        "irish": "ga",
        "italian": "it",
        "japanese": "ja",
        "javanese": "jw",
        "kannada": "kn",
        "kazakh": "kk",
        "khmer": "km",
        "kinyarwanda": "rw",
        "konkani": "gom",
        "korean": "ko",
        "krio": "kri",
        "kurdish (kurmanji)": "ku",
        "kurdish (sorani)": "ckb",
        "kyrgyz": "ky",
        "lao": "lo",
        "latin": "la",
        "latvian": "lv",
        "lingala": "ln",
        "lithuanian": "lt",
        "luganda": "lg",
        "luxembourgish": "lb",
        "macedonian": "mk",
        "maithili": "mai",
        "malagasy": "mg",
        "malay": "ms",
        "malayalam": "ml",
        "maltese": "mt",
        "maori": "mi",
        "marathi": "mr",
        "meiteilon (manipuri)": "mni-Mtei",
        "mizo": "lus",
        "mongolian": "mn",
        "myanmar": "my",
        "nepali": "ne",
        "norwegian": "no",
        "odia (oriya)": "or",
        "oromo": "om",
        "pashto": "ps",
        "persian": "fa",
        "polish": "pl",
        "portuguese": "pt",
        "punjabi": "pa",
        "quechua": "qu",
        "romanian": "ro",
        "russian": "ru",
        "samoan": "sm",
        "sanskrit": "sa",
        "scots gaelic": "gd",
        "sepedi": "nso",
        "serbian": "sr",
        "sesotho": "st",
        "shona": "sn",
        "sindhi": "sd",
        "sinhala": "si",
        "slovak": "sk",
        "slovenian": "sl",
        "somali": "so",
        "spanish": "es",
        "sundanese": "su",
        "swahili": "sw",
        "swedish": "sv",
        "tajik": "tg",
        "tamil": "ta",
        "tatar": "tt",
        "telugu": "te",
        "thai": "th",
        "tigrinya": "ti",
        "tsonga": "ts",
        "turkish": "tr",
        "turkmen": "tk",
        "twi": "ak",
        "ukrainian": "uk",
        "urdu": "ur",
        "uyghur": "ug",
        "uzbek": "uz",
        "vietnamese": "vi",
        "welsh": "cy",
        "xhosa": "xh",
        "yiddish": "yi",
        "yoruba": "yo",
        "zulu": "zu"
    }

    if user_input.startswith("pt "):
        payload = user_input[3:].strip()  # Entfernt das Präfix 'pb ' -> "german->english hallo"

        if ' ' in payload and '->' in payload:
            lang_part, text = payload.split(' ', 1)  # Split "german->english" und den Text
            if '->' in lang_part:
                source_str, target_str = lang_part.split('->')  # Split "german" und "english"
                source = source_str.lower()
                target = target_str.lower()

                # Überprüfen, ob die angegebenen Sprachen in der Liste enthalten sind
                if source in languages and target in languages:
                    try:
                        # Übersetzung durchführen
                        result = GoogleTranslator(
                            source=languages[source],
                            target=languages[target]
                        ).translate(text)

                        print(f"Translation ({source} -> {target}): {result}")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Error during translation: {e}")
                else:
                    print(f"[{timestamp()}] [ERROR] Language not supported.")
            else:
                print(f"[{timestamp()}] [ERROR] Invalid language format (e.g., german->english).")
        else:
            print(f"[{timestamp()}] [ERROR] Invalid command. Correct format: pb <source>-><target> <text>")

        return True

    if user_input.startswith("po "):
        user_input = user_input[3:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        command = ["ollama"] + user_input.split()
        subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, text=True)

        return True

    if user_input.startswith("pp-po "):
        user_input = user_input[6:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        command = f"ollama {user_input}"

        subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True,
                                   text=True)

        return True

    if user_input.lower() == "po-run":
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        return True

    if user_input.startswith("IQ "):
        cmd = user_input[3:].strip()
        ret = run_quantum_command(cmd, shell=False, force_quantum=None, verbose=True, dry_run=False, logfile='quantum_runner.log')
        print(f"[{timestamp()}] [OUTPUT] Return code: {ret}")
        return True

    if user_input.startswith("IQ-QFT"):
        parts = user_input.split()
        if len(parts) != 2:
            print("[{timestamp()}] [INFO] Usage: IQ-QFT <n_qubits>")
            return True
        else:
            try:
                n = int(parts[1])
                if n <= 0:
                    raise ValueError(f"[{timestamp()}] [INFO] n_qubits must be greater than 0")
                    return True
            except ValueError as ve:
                print(f"[{timestamp()}] [ERROR] {ve}")
                return True
            else:
                logging.info(f"[INFO] Starting IQ-QFT with {n} qubits")

                # build QFT circuit
                qubits = cirq.LineQubit.range(n)
                circuit = cirq.Circuit()
                for target in range(n):
                    for control in range(target):
                        # apply controlled-phase rotation
                        angle = 1 / 2 ** (target - control)
                        circuit.append(cirq.CZ(qubits[control], qubits[target]) ** angle)
                    # apply Hadamard gate
                    circuit.append(cirq.H(qubits[target]))

                # add measurement for all qubits
                circuit.append(cirq.measure(*qubits, key='m'))
                logging.info(f"[{timestamp()}] [INFO] Constructed circuit:\n{circuit}")

                # run simulation
                simulator = cirq.Simulator()
                try:
                    result = simulator.run(circuit, repetitions=1)
                    logging.info(f"[INFO] Simulation result: {result}")
                    return True
                except Exception:
                    logging.exception(f"[ERROR] Error during simulation")
                    return True
                finally:
                    print(f"[{timestamp()}] [END IQ-QFT]")
                    return True

    if user_input.startswith("IQ-GHZ"):
        # IQ-GHZ <n_qubits>: create a GHZ state on n qubits
        parts = user_input.split()
        if len(parts) != 2 or not parts[1].isdigit():
            print(f"[{timestamp()}] [INFO] Usage: IQ-GHZ <n_qubits>")
            return True
        else:
            n = int(parts[1])
            if n < 2:
                print(f"[{timestamp()}] [ERROR] n_qubits must be >= 2")
                return True
            else:
                logging.info(f"Starting IQ-GHZ with {n} qubits")
                qubits = cirq.LineQubit.range(n)
                circuit = cirq.Circuit()
                circuit.append(cirq.H(qubits[0]))  # prepare first qubit
                for q in qubits[1:]:
                    circuit.append(cirq.CNOT(qubits[0], q))  # entangle rest
                circuit.append(cirq.measure(*qubits, key='m'))  # measure all
                run_circuit(circuit)
                return True

    if user_input.startswith("IQ-GROVER"):
        # IQ-GROVER <n_qubits> <target_index>: simple Grover search
        parts = user_input.split()
        if len(parts) != 3 or not (parts[1].isdigit() and parts[2].isdigit()):
            print(f"[{timestamp()}] [INFO] Usage: IQ‑GROVER <n_qubits> <target_index>")
            return True
        else:
            n, target = map(int, parts[1:])
            if target < 0 or target >= 2 ** n:
                print(f"[{timestamp()}] [ERROR] target_index out of range")
                return True
            else:
                logging.info(f"[INFO] Starting IQ‑GROVER with {n} qubits, target={target}")
                qubits = cirq.LineQubit.range(n)
                circuit = cirq.Circuit()

                # 1) Prepare uniform superposition
                circuit.append(cirq.H.on_each(*qubits))

                # 2) Phase oracle: flip phase of |target⟩
                bits = format(target, f'0{n}b')
                for i, b in enumerate(reversed(bits)):
                    if b == '0':
                        circuit.append(cirq.X(qubits[i]))
                circuit.append(cirq.Z.on(qubits[-1]).controlled_by(*qubits[:-1]))
                for i, b in enumerate(reversed(bits)):
                    if b == '0':
                        circuit.append(cirq.X(qubits[i]))

                # 3) Diffusion operator
                circuit.append(cirq.H.on_each(*qubits))
                circuit.append(cirq.X.on_each(*qubits))
                circuit.append(cirq.Z.on(qubits[-1]).controlled_by(*qubits[:-1]))
                circuit.append(cirq.X.on_each(*qubits))
                circuit.append(cirq.H.on_each(*qubits))

                # 4) Measurement
                circuit.append(cirq.measure(*qubits, key='m'))

                # Run with 10 repetitions
                run_circuit(circuit, repetitions=10)
                return True

    if user_input.startswith("IQ-PHASE_EST"):
        # IQ-PHASE_EST <target_qubits> <precision_bits>: quantum phase estimation
        parts = user_input.split()
        if len(parts) != 3 or not (parts[1].isdigit() and parts[2].isdigit()):
            print(f"[{timestamp()}] [INFO] Usage: IQ-PHASE_EST <target_qubits> <precision_bits>")
            return True
        else:
            target_qubits, prec = map(int, parts[1:])
            logging.info(f"[INFO] Starting IQ-PHASE_EST with target_qubits={target_qubits}, precision={prec}")
            control = cirq.LineQubit.range(prec)
            target = cirq.LineQubit.range(prec, prec + target_qubits)
            circuit = cirq.Circuit()
            # prepare control register and controlled-U^2^j
            for j, q in enumerate(control):
                circuit.append(cirq.H(q))
                for _ in range(2 ** j):
                    circuit.append(cirq.CZ(q, target[0]))

            # inverse QFT on control register
            def inv_qft(qubits):
                inv = cirq.Circuit()
                m = len(qubits)
                for i in range(m - 1, -1, -1):
                    inv.append(cirq.H(qubits[i]))
                    for j in range(i):
                        inv.append(cirq.CZ(qubits[j], qubits[i]) ** (-1 / 2 ** (i - j)))
                return inv

            circuit += inv_qft(control)
            circuit.append(cirq.measure(*control, key='phase'))  # measure phase bits
            run_circuit(circuit)
            return True

    if user_input.startswith("IQ-BELL"):
        # IQ-BELL: create and measure a Bell pair
        logging.info("[INFO] Starting IQ-BELL on 2 qubits")
        q0, q1 = cirq.LineQubit.range(2)
        circuit = cirq.Circuit(
            cirq.H(q0),  # Hadamard on first qubit
            cirq.CNOT(q0, q1),  # entangle pair
            cirq.measure(q0, q1, key='m')  # measure both
        )
        run_circuit(circuit, repetitions=5)
        return True

    if user_input.startswith("IQ-QAOA"):
        # IQ-QAOA <n_qubits> <p_layers>: p-layer QAOA for Max-Cut on a ring graph
        parts = user_input.split()
        if len(parts) != 3 or not (parts[1].isdigit() and parts[2].isdigit()):
            print(f"[{timestamp()}] [INFO] Usage: IQ-QAOA <n_qubits> <p_layers>")
            return True
        else:
            n, p = map(int, parts[1:])
            logging.info(f"[INFO] Starting IQ-QAOA with {n} qubits, {p} layers")
            qubits = cirq.LineQubit.range(n)
            edges = [(qubits[i], qubits[(i + 1) % n]) for i in range(n)]
            gamma = onp.linspace(0.1, onp.pi, p)
            beta = onp.linspace(0.1, onp.pi / 2, p)
            circuit = cirq.Circuit()
            # initialize in |+>^n
            circuit.append(cirq.H.on_each(*qubits))
            # alternating problem and mixer Hamiltonians
            for layer in range(p):
                for u, v in edges:
                    circuit.append((cirq.Z(u) * cirq.Z(v)) ** gamma[layer])
                circuit.append([cirq.X(q) ** beta[layer] for q in qubits])
            circuit.append(cirq.measure(*qubits, key='m'))
            run_circuit(circuit, repetitions=100)
            return True

    if user_input.startswith("IQ-VQE"):
        # IQ-VQE <n_qubits> <ansatz_depth>: variational quantum eigensolver for H2 Hamiltonian
        parts = user_input.split()
        if len(parts) != 3 or not (parts[1].isdigit() and parts[2].isdigit()):
            print(f"[{timestamp()}] [INFO] Usage: IQ-VQE <n_qubits> <ansatz_depth>")
            return True
        else:
            n, depth = map(int, parts[1:])
            logging.info(f"[INFO] Starting IQ-VQE with {n} qubits, depth={depth}")
            qubits = cirq.LineQubit.range(n)

            # hardware-efficient ansatz
            def ansatz(params):
                c = cirq.Circuit()
                idx = 0
                for _ in range(depth):
                    for q in qubits:
                        c.append(cirq.rx(params[idx])(q))
                        idx += 1
                    for i in range(n - 1):
                        c.append(cirq.CNOT(qubits[i], qubits[i + 1]))
                return c

            # H2 Hamiltonian terms
            ops = [
                (-1.05, cirq.Z(qubits[0]) * cirq.Z(qubits[1])),
                (0.39, cirq.X(qubits[0])),
                (0.39, cirq.X(qubits[1]))
            ]

            def energy(params):
                circuit = ansatz(params)
                sim = cirq.Simulator()
                vals = sim.simulate_expectation_values(circuit, [op for _, op in ops])
                return sum(coeff * val for (coeff, _), val in zip(ops, vals))

            init = onp.random.rand(n * depth)
            res = opt.minimize(energy, init, method='COBYLA')
            print(f"[{timestamp()}] [VQE ENERGY] {res.fun}")
            return True

    if user_input.startswith("IQ-TELEPORT"):
        # IQ-TELEPORT: teleport state from qubit 0 to qubit 2
        logging.info("[INFO] Starting IQ-TELEPORT")
        q0, q1, q2 = cirq.LineQubit.range(3)
        circuit = cirq.Circuit(
            cirq.H(q1),  # create Bell pair on q1,q2
            cirq.CNOT(q1, q2),
            cirq.H(q0),  # prepare unknown state on q0
            cirq.CNOT(q0, q1),  # Bell measurement
            cirq.H(q0),
            cirq.measure(q0, q1, key='m'),
            cirq.X(q2).controlled_by(q1),  # corrective rotations
            cirq.Z(q2).controlled_by(q0),
            cirq.measure(q2, key='teleported')
        )
        run_circuit(circuit)
        return True

    if user_input.startswith("IQ-ERROR_CORR"):
        # IQ-ERROR_CORR <bitflip|phaseflip>: simple 3-qubit error correction
        parts = user_input.split()
        if len(parts) != 2 or parts[1].lower() not in ("bitflip", "phaseflip"):
            print(f"[{timestamp()}] [INFO] Usage: IQ-ERROR_CORR <bitflip|phaseflip>")
        else:
            code = parts[1].lower()
            logging.info(f"[INFO] Starting IQ-ERROR_CORR with {code} code")
            q = cirq.LineQubit.range(3)
            c = cirq.Circuit()
            # encoding
            if code == "bitflip":
                c.append([cirq.CNOT(q[0], q[1]), cirq.CNOT(q[0], q[2])])
            else:
                c.append([cirq.H(qi) for qi in q])
                c.append([cirq.CNOT(q[0], q[1]), cirq.CNOT(q[0], q[2])])
                c.append([cirq.H(qi) for qi in q])
            # introduce error on q1
            c.append(cirq.X(q[1]))
            # syndrome measurement
            c.append([cirq.CNOT(q[0], q[1]), cirq.CNOT(q[0], q[2]), cirq.measure(q[1], q[2], key='s')])
            # correction
            c.append(cirq.X(q[0]).controlled_by(q[2]))
            run_circuit(c)
            return True

    if user_input.startswith("IQ-AMPL_EST"):
        # IQ-AMPL_EST <n_qubits> <target_angle>: simple amplitude estimation
        parts = user_input.split()
        if len(parts) != 3 or not parts[1].isdigit():
            print(f"[{timestamp()}] [INFO] Usage: IQ-AMPL_EST <n_qubits> <target_angle>")
            return True
        else:
            n = int(parts[1])
            theta = float(parts[2])
            logging.info(f"[INFO] Starting IQ-AMPL_EST with {n} qubits, theta={theta}")
            q = cirq.LineQubit.range(n + 1)
            c = cirq.Circuit()
            # state preparation
            c.append(cirq.ry(2 * theta)(q[-1]))
            # single-step Grover operator
            c.append(cirq.Z(q[-1]))
            c.append(cirq.ry(-2 * theta)(q[-1]))
            c.append(cirq.measure(q[-1], key='m'))
            run_circuit(c, repetitions=10)
            return True

    if user_input.startswith("IQ-TOMO"):
        # IQ-TOMO <n_qubits> <shots>: state tomography on n qubits
        parts = user_input.split()
        if len(parts) != 3 or not (parts[1].isdigit() and parts[2].isdigit()):
            print(f"[{timestamp()}] [INFO] Usage: IQ-TOMO <n_qubits> <shots>")
            return True
        else:
            n, shots = map(int, parts[1:])
            logging.info(f"[INFO] Starting IQ-TOMO with {n} qubits, {shots} shots")
            qubits = cirq.LineQubit.range(n)
            circuits = []
            # measure in all Pauli bases
            for basis in itertools.product(['X', 'Y', 'Z'], repeat=n):
                c = cirq.Circuit()
                for q, b in zip(qubits, basis):
                    if b == 'X':
                        c.append(cirq.H(q))
                    elif b == 'Y':
                        c.append(cirq.rx(onp.pi / 2)(q))
                c.append(cirq.measure(*qubits, key='m'))
                circuits.append((basis, c))
            sim = cirq.Simulator()
            for basis, c in circuits:
                res = sim.run(c, repetitions=shots)
                print(f"{basis}: {res.histogram(key='m')}")
            return True

    if user_input.startswith("IQ-SIMON"):
        # IQ-SIMON <n_qubits> <secret_bitstring>: Simon’s algorithm to find a hidden bitstring
        parts = user_input.split()
        if len(parts) != 3 or not parts[1].isdigit() or not all(c in "01" for c in parts[2]):
            print(f"[{timestamp()}] [INFO] Usage: IQ-SIMON <n_qubits> <secret_bitstring>")
            return True
        else:
            n = int(parts[1])
            s = parts[2]
            if len(s) != n:
                print(f"[{timestamp()}] [ERROR] secret_bitstring length must equal n_qubits")
                return True
            else:
                logging.info(f"[INFO] Starting IQ-SIMON with {n} qubits, secret={s}")
                in_qubits = cirq.LineQubit.range(n)
                out_qubits = cirq.LineQubit.range(n, 2 * n)
                circuit = cirq.Circuit()
                # prepare input register in superposition
                circuit.append(cirq.H.on_each(*in_qubits))
                # oracle f(x) = x ⊕ s
                for i, bit in enumerate(s):
                    if bit == '1':
                        circuit.append(cirq.CNOT(in_qubits[i], out_qubits[i]))
                # measure output and then apply H to input
                circuit.append(cirq.measure(*out_qubits, key='out'))
                circuit.append(cirq.H.on_each(*in_qubits))
                circuit.append(cirq.measure(*in_qubits, key='in'))
                run_circuit(circuit, repetitions=2 * n)
                return True

    if user_input.startswith("IQ-SHOR"):
        # IQ-SHOR <N>: Shor’s algorithm for factoring a small integer N
        parts = user_input.split()
        if len(parts) != 2 or not parts[1].isdigit():
            print(f"[{timestamp()}] [INFO] Usage: IQ-SHOR <N>")
            return True
        else:
            N = int(parts[1])
            logging.info(f"[INFO] Starting IQ-SHOR to factor N={N}")
            # pick random a coprime to N
            a = onp.random.randint(2, N)
            while math.gcd(a, N) != 1:
                a = onp.random.randint(2, N)
            t = math.ceil(math.log2(N)) * 2
            n = math.ceil(math.log2(N))
            count = cirq.LineQubit.range(t)
            work = cirq.LineQubit.range(t, t + n)
            circuit = cirq.Circuit()
            # prepare counting register
            circuit.append(cirq.H.on_each(*count))
            # controlled multiplication placeholder
            for j, q in enumerate(count):
                circuit.append(cirq.CZ(q, work[j % n]) ** (a ** (2 ** j) % N))
            # inverse QFT
            circuit.append(cirq.inverse(cirq.qft(*count, without_reverse=True)))
            circuit.append(cirq.measure(*count, key='m'))
            run_circuit(circuit)
            return True

    if user_input.startswith("IQ-HHL"):
        # IQ-HHL <theta>: HHL algorithm solving Ax=b with A = Rz(theta)
        parts = user_input.split()
        if len(parts) != 2:
            print(f"[{timestamp()}] [INFO] Usage: IQ-HHL <theta>")
            return True
        else:
            theta = float(parts[1])
            logging.info(f"[INFO] Starting IQ-HHL with theta={theta}")
            anc, x, b = cirq.LineQubit.range(3)
            circuit = cirq.Circuit()
            # prepare |b> = |1>
            circuit.append(cirq.X(b))
            # phase estimation on A = Rz(theta)
            circuit.append([cirq.H(anc),
                            cirq.CZ(anc, x) ** (theta / onp.pi),
                            cirq.H(anc)])
            # controlled rotation
            angle = 2 * onp.arccos(1 / onp.sqrt(2))
            circuit.append(cirq.Ry(angle)(x).controlled_by(anc))
            # uncompute phase estimation
            circuit.append([cirq.H(anc),
                            cirq.CZ(anc, x) ** (-theta / onp.pi),
                            cirq.H(anc)])
            circuit.append(cirq.measure(x, key='solution'))
            run_circuit(circuit, repetitions=5)
            return True

    if user_input.startswith("IQ-QSVM"):
        # IQ-QSVM <n_qubits> <shots>: quantum SVM demo with Bloch‐sphere encoding
        parts = user_input.split()
        if len(parts) != 3 or not parts[1].isdigit() or not parts[2].isdigit():
            print(f"[{timestamp()}] [INFO] Usage: IQ-QSVM <n_qubits> <shots>")
            return True
        else:
            n, shots = map(int, parts[1:])
            logging.info(f"[INFO] Starting IQ-QSVM with {n} qubits, {shots} shots")
            qubits = cirq.LineQubit.range(n)
            circuit = cirq.Circuit()
            data = [onp.pi / 4, onp.pi / 2, 3 * onp.pi / 4]
            for angle in data:
                for i, q in enumerate(qubits):
                    circuit.append(cirq.rx(angle * (i + 1))(q))
                circuit.append(cirq.measure(*qubits, key='m'))
            run_circuit(circuit, repetitions=shots)
            return True

    if user_input.startswith("IQ-DJ"):
        # IQ-DJ <n_qubits> <bitstring>: Deutsch–Jozsa algorithm
        parts = user_input.split()
        if len(parts) != 3 or not parts[1].isdigit() or not all(c in "01" for c in parts[2]):
            print(f"[{timestamp()}] [INFO] Usage: IQ-DJ <n_qubits> <bitstring>")
            return True
        else:
            n = int(parts[1])
            s = parts[2]
            if len(s) != n:
                print(f"[{timestamp()}] [ERROR] bitstring length must equal n_qubits")
                return True
            else:
                logging.info(f"[INFO] Starting IQ-DJ with {n} qubits, s={s}")
                qs = cirq.LineQubit.range(n + 1)
                circuit = cirq.Circuit()
                circuit.append(cirq.X(qs[-1]))  # prepare |0…0,1>
                circuit.append(cirq.H.on_each(*qs))
                # oracle f_s(x) = s·x mod 2
                for i, bit in enumerate(s):
                    if bit == '1':
                        circuit.append(cirq.CNOT(qs[i], qs[-1]))
                circuit.append(cirq.H.on_each(*qs[:-1]))
                circuit.append(cirq.measure(*qs[:-1], key='result'))
                run_circuit(circuit)
                return True

    if user_input.startswith("IQ-BV"):
        # IQ-BV <n_qubits> <bitstring>: Bernstein–Vazirani algorithm
        parts = user_input.split()
        if len(parts) != 3 or not parts[1].isdigit() or not all(c in "01" for c in parts[2]):
            print(f"[{timestamp()}] [INFO] Usage: IQ-BV <n_qubits> <bitstring>")
            return True
        else:
            n = int(parts[1])
            s = parts[2]
            if len(s) != n:
                print(f"[{timestamp()}] [ERROR] bitstring length must equal n_qubits")
                return True
            else:
                logging.info(f"[INFO] Starting IQ-BV with {n} qubits, s={s}")
                qs = cirq.LineQubit.range(n + 1)
                circuit = cirq.Circuit()
                circuit.append(cirq.X(qs[-1]))
                circuit.append(cirq.H.on_each(*qs))
                for i, bit in enumerate(s):
                    if bit == '1':
                        circuit.append(cirq.CNOT(qs[i], qs[-1]))
                circuit.append(cirq.H.on_each(*qs[:-1]))
                circuit.append(cirq.measure(*qs[:-1], key='s'))
                run_circuit(circuit)
                return True

    if user_input.startswith("IQ-QC"):
        # IQ-QC <n_qubits> <target_index>: quantum counting (Grover + phase estimation)
        parts = user_input.split()
        if len(parts) != 3 or not parts[1].isdigit() or not parts[2].isdigit():
            print(f"[{timestamp()}] [INFO] Usage: IQ-QC <n_qubits> <target_index>")
            return True
        else:
            n, target = map(int, parts[1:])
            logging.info(f"[INFO] Starting IQ-QC with {n} qubits, target={target}")
            print(f"[{timestamp()}] [INFO] Quantum counting not implemented; please supply custom circuit.")
            return True

    if user_input.startswith("IQ-QWALK"):
        # IQ-QWALK <n_positions> <n_steps>: discrete quantum walk on a line
        parts = user_input.split()
        if len(parts) != 3 or not parts[1].isdigit() or not parts[2].isdigit():
            print(f"[{timestamp()}] [INFO] Usage: IQ-QWALK <n_positions> <n_steps>")
            return True
        else:
            m, steps = map(int, parts[1:])
            logging.info(f"[INFO] Starting IQ-QWALK with {m} positions, {steps} steps")
            positions = cirq.GridQubit.rect(1, m)
            coin = cirq.NamedQubit("coin")
            circuit = cirq.Circuit()
            circuit.append(cirq.H(coin))
            for _ in range(steps):
                circuit.append(cirq.CNOT(coin, positions[0]))  # placeholder shift
                circuit.append(cirq.H(coin))
            circuit.append(cirq.measure(coin, *positions, key='pos'))
            run_circuit(circuit, repetitions=10)
            return True

    if user_input.startswith("IQ-PCA"):
        # IQ-PCA <n_qubits> <shots>: quantum PCA via covariance measurements
        parts = user_input.split()
        if len(parts) != 3 or not parts[1].isdigit() or not parts[2].isdigit():
            print(f"[{timestamp()}] [INFO] Usage: IQ-PCA <n_qubits> <shots>")
            return True
        else:
            n, shots = map(int, parts[1:])
            logging.info(f"[INFO] Starting IQ-PCA with {n} qubits, {shots} shots")
            qs = cirq.LineQubit.range(n)
            circuit = cirq.Circuit()
            circuit.append(cirq.H.on_each(*qs))
            for i, q in enumerate(qs):
                circuit.append(cirq.measure(q, key=f'm{i}'))
            run_circuit(circuit, repetitions=shots)
            return True

    if user_input.startswith("IQ-QKERNEL"):
        # IQ-QKERNEL <n_qubits> <shots>: quantum kernel matrix demonstration
        parts = user_input.split()
        if len(parts) != 3 or not parts[1].isdigit() or not parts[2].isdigit():
            print(f"[{timestamp()}] [INFO] Usage: IQ-QKERNEL <n_qubits> <shots>")
            return True
        else:
            n, shots = map(int, parts[1:])
            logging.info(f"[INFO] Starting IQ-QKERNEL with {n} qubits, {shots} shots")
            qs = cirq.LineQubit.range(n)
            data = [[0.1 * i for i in range(n)], [0.2 * i for i in range(n)]]
            circuit = cirq.Circuit()
            for vec in data:
                for angle, q in zip(vec, qs):
                    circuit.append(cirq.rz(angle)(q))
                circuit.append(cirq.measure(*qs, key='k'))
            run_circuit(circuit, repetitions=shots)
            return True

    # IQ-AI-TORCH
    if user_input.startswith("IQ-AI-TORCH "):
        import torch.nn as nn
        import torch.optim as optim
        from torchvision import datasets, transforms
        from torch.utils.data import DataLoader

        # Argument-Parsing
        raw = user_input[len("IQ-AI-TORCH "):].strip().split()
        opts = {}
        positionals = raw

        # Positionals: hidden_size, batch_size, epochs, [model_name]
        try:
            hidden_size = int(positionals[0])
            batch_size  = int(positionals[1])
            epochs      = int(positionals[2])
            model_name  = positionals[3] if len(positionals) > 3 else "model.pth"
            if hidden_size <= 0 or batch_size <= 0 or epochs <= 0:
                raise ValueError("All numeric parameters must be > 0.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Invalid parameters: {e}")
            print("Usage: IQ-AI-TORCH <hidden_size> <batch_size> <epochs> [model_name.pth]")
            return True

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] [INFO] Start IQ-AI-TORCH with hidden={hidden_size}, batch={batch_size}, epochs={epochs}")

        # Load .env if exists
        USERNAME = os.getlogin()
        env_path = fr"C:\Users\{USERNAME}\p-terminal\pp-term\.env"
        if os.path.isfile(env_path):
            with open(env_path, "r") as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("#") or "=" not in line:
                        continue
                    key, val = line.split("=", 1)
                    os.environ[key] = val
            logging.info(f"[{timestamp()}] [INFO] .env loaded from {env_path}")
        else:
            logging.warning(f"[{timestamp()}] [INFO] .env not found: {env_path}")

        # Define network
        class SimpleNet(nn.Module):
            def __init__(self, hidden):
                super().__init__()
                self.fc1  = nn.Linear(28*28, hidden)
                self.relu = nn.ReLU()
                self.fc2  = nn.Linear(hidden, 10)
            def forward(self, x):
                x = x.view(-1, 28*28)
                x = self.relu(self.fc1(x))
                return self.fc2(x)

        device    = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        model     = SimpleNet(hidden_size).to(device)
        optimizer = optim.Adam(model.parameters(), lr=1e-3)
        criterion = nn.CrossEntropyLoss()

        # Data loaders
        transform    = transforms.Compose([
            transforms.ToTensor(),
            transforms.Normalize((0.1307,), (0.3081,))
        ])
        train_set    = datasets.MNIST('.', train=True,  download=True, transform=transform)
        test_set     = datasets.MNIST('.', train=False, download=True, transform=transform)
        train_loader = DataLoader(train_set, batch_size=batch_size, shuffle=True)
        test_loader  = DataLoader(test_set,  batch_size=batch_size, shuffle=False)
        logging.info(f"[{timestamp()}] [INFO] Data loaded")

        # Training
        model.train()
        for epoch in range(1, epochs+1):
            total_loss = 0.0
            for data, target in train_loader:
                data, target = data.to(device), target.to(device)
                optimizer.zero_grad()
                output = model(data)
                loss   = criterion(output, target)
                loss.backward()
                optimizer.step()
                total_loss += loss.item()
            logging.info(f"[{timestamp()}] [INFO] Epoch {epoch}/{epochs} Loss={total_loss/len(train_loader):.4f}")

        # Evaluation
        model.eval()
        correct = total = 0
        with torch.no_grad():
            for data, target in test_loader:
                data, target = data.to(device), target.to(device)
                output = model(data)
                pred   = output.argmax(dim=1)
                correct += (pred == target).sum().item()
                total   += target.size(0)
        accuracy = correct/total*100
        logging.info(f"[{timestamp()}] [INFO] Accuracy: {accuracy:.2f}%")

        # Save model
        torch.save(model.state_dict(), model_name)
        logging.info(f"[{timestamp()}] [INFO] Model saved as {model_name}")

        print(f"[{timestamp()}] [END] IQ-AI-TORCH pipeline completed")
        return True

    if user_input.startswith("IQ-AI-TORCH2 "):
        import torch
        import torch.nn as nn
        import torch.optim as optim
        from torchvision import datasets, transforms
        from torch.utils.data import DataLoader

        raw = user_input[len("IQ-AI-TORCH2 "):].split()
        def usage2(): print("Usage: IQ-AI-TORCH2 <batch> <epochs> <lr> [hidden] [checkpoint]"); return True
        try:
            batch_size=int(raw[0]); epochs=int(raw[1]); lr=float(raw[2])
            hidden=int(raw[3]) if len(raw)>3 else 128
            ckpt=raw[4] if len(raw)>4 else "checkpoint.pth"
        except:
            return usage2()

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] [INFO] Start IQ-AI-TORCH2 batch={batch_size} epochs={epochs} lr={lr} hidden={hidden}")

        # Load .env
        env_path=os.path.expanduser("~/.env")
        if os.path.isfile(env_path):
            load_dotenv(env_path)

        # Model
        class CIFARNet(nn.Module):
            def __init__(self,h): super().__init__(); self.features=nn.Sequential(
                nn.Conv2d(3,32,3,padding=1),nn.ReLU(True),nn.MaxPool2d(2),
                nn.Conv2d(32,64,3,padding=1),nn.ReLU(True),nn.MaxPool2d(2)
            ); self.classifier=nn.Sequential(nn.Flatten(),nn.Linear(64*8*8,h),nn.ReLU(True),nn.Dropout(0.5),nn.Linear(h,10))
            def forward(self,x): return self.classifier(self.features(x))

        device=torch.device("cuda" if torch.cuda.is_available() else "cpu")
        model=CIFARNet(hidden).to(device)
        opt=optim.SGD(model.parameters(), lr=lr, momentum=0.9)
        sched=optim.lr_scheduler.StepLR(opt,step_size=10,gamma=0.1)
        loss_fn=nn.CrossEntropyLoss()

        tf_train=transforms.Compose([transforms.RandomHorizontalFlip(),transforms.ToTensor(),transforms.Normalize((0.4914,0.4822,0.4465),(0.2470,0.2435,0.2616))])
        tf_test =transforms.Compose([transforms.ToTensor(),transforms.Normalize((0.4914,0.4822,0.4465),(0.2470,0.2435,0.2616))])
        train=DataLoader(datasets.CIFAR10('.',True,True,tf_train),batch_size=batch_size,shuffle=True,num_workers=4)
        test =DataLoader(datasets.CIFAR10('.',False,True,tf_test),batch_size=batch_size,shuffle=False,num_workers=4)
        logging.info(f"[{timestamp()}] [INFO] Data ready")

        history={"loss":[],"acc":[]}
        for ep in range(1,epochs+1):
            model.train(); run_loss=0
            for i,(x,y) in enumerate(train,1):
                x,y=x.to(device),y.to(device)
                opt.zero_grad(); out=model(x); l=loss_fn(out,y); l.backward(); opt.step(); run_loss+=l.item()
                if i%100==0: logging.info(f"[{timestamp()}] [E{ep}] Batch{i} loss={run_loss/i:.4f}")
            avg=run_loss/len(train)
            model.eval(); corr=tot=0
            with torch.no_grad():
                for x,y in test: x,y=x.to(device),y.to(device); preds=model(x).argmax(1); corr+=(preds==y).sum().item(); tot+=y.size(0)
            acc=corr/tot*100
            sched.step(); history["loss"].append(avg); history["acc"].append(acc)
            logging.info(f"[{timestamp()}] [E{ep}] Loss={avg:.4f} Acc={acc:.2f}%")
            if ep%5==0 or ep==epochs: torch.save({"epoch":ep,"model":model.state_dict(),"opt":opt.state_dict(),"sched":sched.state_dict(),"history":history}, ckpt)

        final=f"cifar_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pth"
        torch.save(model.state_dict(), final)
        with open("history.json","w") as f: json.dump(history,f,indent=2)
        logging.info(f"[{timestamp()}] [END] IQ-AI-TORCH2 done, saved {final}")
        return True

    # Pipeline 3: IQ-AI-TORCH3
    if user_input.startswith("IQ-AI-TORCH3 "):
        import torch
        import torch.nn as nn
        import torch.optim as optim
        from torchvision import datasets, transforms
        from torch.utils.data import DataLoader

        raw = user_input[len("IQ-AI-TORCH3 "):].split()
        def usage3(): print("Usage: IQ-AI-TORCH3 <batch> <epochs> <lr> <wd> [arch] [ckpt]"); return True
        try:
            batch_size=int(raw[0]); epochs=int(raw[1]); lr=float(raw[2]); wd=float(raw[3])
            arch=raw[4] if len(raw)>4 else "resnet18"
            ckpt=raw[5] if len(raw)>5 else "checkpoint2.pth"
        except:
            return usage3()

        import torchvision.models as models
        from torch.optim.lr_scheduler import CosineAnnealingLR
        from torch.cuda.amp import GradScaler, autocast
        from torch.utils.tensorboard import SummaryWriter

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        tb=SummaryWriter(log_dir="runs/torch3_"+datetime.now().strftime('%Y%m%d_%H%M%S'))
        logging.info(f"[{timestamp()}] [INFO] Start IQ-AI-TORCH3 batch={batch_size} epochs={epochs} lr={lr} wd={wd} arch={arch}")

        env_path=os.path.expanduser("~/.env")
        if os.path.isfile(env_path):
            load_dotenv(env_path)

        device=torch.device("cuda" if torch.cuda.is_available() else "cpu")
        model=getattr(models,arch)(pretrained=False,num_classes=10).to(device)
        opt=optim.AdamW(model.parameters(),lr=lr,weight_decay=wd)
        sched=CosineAnnealingLR(opt,T_max=epochs,eta_min=1e-6)
        scaler=GradScaler(); loss_fn=nn.CrossEntropyLoss()

        tr=transforms.Compose([transforms.RandomCrop(32,padding=4),transforms.RandomHorizontalFlip(),transforms.ColorJitter(0.4,0.4,0.4,0.1),transforms.ToTensor(),transforms.Normalize((0.5071,0.4867,0.4408),(0.2675,0.2565,0.2761))])
        te=transforms.Compose([transforms.ToTensor(),transforms.Normalize((0.5071,0.4867,0.4408),(0.2675,0.2565,0.2761))])
        train=DataLoader(datasets.CIFAR100('.',True,True,tr),batch_size=batch_size,shuffle=True,num_workers=8,pin_memory=True)
        test =DataLoader(datasets.CIFAR100('.',False,True,te),batch_size=batch_size,shuffle=False,num_workers=8,pin_memory=True)
        history={"best_acc":0.0}

        for ep in range(1,epochs+1):
            model.train(); rl=0
            for i,(x,y) in enumerate(train,1):
                x,y=x.to(device),y.to(device)
                opt.zero_grad()
                with autocast(): out=model(x); l=loss_fn(out,y)
                scaler.scale(l).backward(); scaler.step(opt); scaler.update(); rl+=l.item()
                if i%200==0: logging.info(f"[{timestamp()}] [E{ep}] Batch{i} loss={rl/i:.4f}")
            avg=rl/len(train); tb.add_scalar("Train/Loss",avg,ep)

            model.eval(); corr=tot=0
            with torch.no_grad():
                for x,y in test: x,y=x.to(device),y.to(device); preds=model(x).argmax(1); corr+=(preds==y).sum().item(); tot+=y.size(0)
            acc=corr/tot*100; tb.add_scalar("Val/Acc",acc,ep)
            logging.info(f"[{timestamp()}] [E{ep}] Val Acc={acc:.2f}%")

            sched.step()
            if acc>history["best_acc"] or ep==epochs:
                history["best_acc"]=acc
                torch.save({"epoch":ep,"model":model.state_dict(),"opt":opt.state_dict(),"sched":sched.state_dict(),"scaler":scaler.state_dict(),"best_acc":acc}, ckpt)

        final=f"c100_{arch}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pth"
        torch.save(model.state_dict(), final)
        with open("history_iq2.json","w") as f: json.dump(history,f,indent=2)
        tb.close()
        logging.info(f"[{timestamp()}] [END] IQ-AI-TORCH3 done, final model: {final}")
        return True

    # Pipeline 4: IQ-AI-TORCH4
    if user_input.startswith("IQ-AI-TORCH4 "):
        import torch
        import torch.nn as nn
        import torch.optim as optim
        from torch.optim.lr_scheduler import ReduceLROnPlateau
        from torchvision import datasets, transforms
        from torch.utils.data import DataLoader

        def print_usage():
            print("Usage: IQ-AI-TORCH4 <batch> <epochs> <lr> <patience> [hidden] [checkpoint]")
            return True

        # Parse args
        raw = user_input[len("IQ-AI-TORCH4 "):].split()
        try:
            batch_size = int(raw[0])
            epochs     = int(raw[1])
            lr         = float(raw[2])
            patience   = int(raw[3])
            hidden     = int(raw[4]) if len(raw)>4 else 128
            ckpt_path  = raw[5] if len(raw)>5 else "checkpoint4.pth"
            if batch_size<=0 or epochs<=0 or lr<=0 or patience<0 or hidden<=0:
                raise ValueError("Invalid numeric parameters.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {e}")
            return print_usage()

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] Start IQ-AI-TORCH4: batch={batch_size}, epochs={epochs}, lr={lr}, patience={patience}, hidden={hidden}")

        # Network
        class SimpleNet4(nn.Module):
            def __init__(self, h):
                super().__init__()
                self.net = nn.Sequential(
                    nn.Flatten(),
                    nn.Linear(28*28, h),
                    nn.ReLU(True),
                    nn.Linear(h, 10)
                )
            def forward(self, x):
                return self.net(x)

        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        model  = SimpleNet4(hidden).to(device)
        optimizer = optim.Adam(model.parameters(), lr=lr)
        scheduler = ReduceLROnPlateau(optimizer, mode='min', patience=patience, factor=0.5)
        criterion = nn.CrossEntropyLoss()

        # Data
        transform = transforms.Compose([
            transforms.ToTensor(),
            transforms.Normalize((0.5,), (0.5,))
        ])
        train_loader = DataLoader(datasets.FashionMNIST('.', True, True, transform), batch_size=batch_size, shuffle=True)
        valid_loader = DataLoader(datasets.FashionMNIST('.', False, True, transform), batch_size=batch_size, shuffle=False)
        logging.info(f"[{timestamp()}] FashionMNIST data loaded")

        best_loss = float('inf')
        for epoch in range(1, epochs+1):
            # Training
            model.train()
            train_loss = 0
            for x, y in train_loader:
                x, y = x.to(device), y.to(device)
                optimizer.zero_grad()
                out = model(x)
                loss = criterion(out, y)
                loss.backward()
                optimizer.step()
                train_loss += loss.item()
            avg_train = train_loss / len(train_loader)

            # Validation
            model.eval()
            val_loss = 0; correct = total = 0
            with torch.no_grad():
                for x, y in valid_loader:
                    x, y = x.to(device), y.to(device)
                    out = model(x)
                    loss = criterion(out, y)
                    val_loss += loss.item()
                    preds = out.argmax(dim=1)
                    correct += (preds == y).sum().item()
                    total += y.size(0)
            avg_val = val_loss / len(valid_loader)
            acc = correct/total*100
            logging.info(f"[{timestamp()}] Epoch {epoch}/{epochs} TrainLoss={avg_train:.4f}, ValLoss={avg_val:.4f}, Acc={acc:.2f}%")

            # Scheduler
            scheduler.step(avg_val)
            if avg_val < best_loss:
                best_loss = avg_val
                torch.save(model.state_dict(), ckpt_path)
                logging.info(f"[{timestamp()}] Checkpoint saved: {ckpt_path}")

        # Finish
        final_model = f"fashion_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pth"
        torch.save(model.state_dict(), final_model)
        logging.info(f"[{timestamp()}] IQ-AI-TORCH4 completed, final model: {final_model}")
        return True

    # Pipeline 5: IQ-AI-TORCH5
    if user_input.startswith("IQ-AI-TORCH5 "):
        import torch
        import torch.nn as nn
        import torch.optim as optim
        from torch.optim.lr_scheduler import OneCycleLR
        from torchvision import datasets, transforms, models
        from torch.utils.data import DataLoader

        def print_usage():
            print("Usage: IQ-AI-TORCH5 <batch> <epochs> <max_lr> <pct_start> [arch] [checkpoint]")
            return True

        raw = user_input[len("IQ-AI-TORCH5 "):].split()
        try:
            batch_size = int(raw[0])
            epochs     = int(raw[1])
            max_lr     = float(raw[2])
            pct_start  = float(raw[3])
            arch       = raw[4] if len(raw)>4 else "resnet18"
            ckpt_path  = raw[5] if len(raw)>5 else "checkpoint5.pth"
            if batch_size<=0 or epochs<=0 or max_lr<=0 or not (0<pct_start<1):
                raise ValueError("Invalid numeric parameters.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {e}")
            return print_usage()

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] Start IQ-AI-TORCH5: batch={batch_size}, epochs={epochs}, max_lr={max_lr}, pct_start={pct_start}, arch={arch}")

        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        model  = getattr(models, arch)(pretrained=False, num_classes=100).to(device)

        optimizer = optim.SGD(model.parameters(), lr=max_lr, momentum=0.9)
        scheduler = OneCycleLR(optimizer, max_lr=max_lr, total_steps=epochs*(50000//batch_size), pct_start=pct_start)
        criterion = nn.CrossEntropyLoss()

        transform_train = transforms.Compose([
            transforms.RandomCrop(32, padding=4), transforms.RandomHorizontalFlip(),
            transforms.ToTensor(), transforms.Normalize((0.5071,0.4867,0.4408),(0.2675,0.2565,0.2761))
        ])
        transform_test = transforms.Compose([
            transforms.ToTensor(), transforms.Normalize((0.5071,0.4867,0.4408),(0.2675,0.2565,0.2761))
        ])
        train_loader = DataLoader(datasets.CIFAR100('.', True, True, transform_train), batch_size=batch_size, shuffle=True, num_workers=4, pin_memory=True)
        test_loader  = DataLoader(datasets.CIFAR100('.', False, True, transform_test), batch_size=batch_size, shuffle=False, num_workers=4, pin_memory=True)
        logging.info(f"[{timestamp()}] CIFAR-100 data loaded")

        best_acc = 0.0
        for epoch in range(1, epochs+1):
            model.train()
            run_loss=0
            for data, target in train_loader:
                data, target = data.to(device), target.to(device)
                optimizer.zero_grad()
                out = model(data)
                loss=criterion(out, target)
                loss.backward(); optimizer.step(); scheduler.step(); run_loss+=loss.item()
            avg_loss = run_loss/len(train_loader)

            model.eval(); corr=tot=0
            with torch.no_grad():
                for data, target in test_loader:
                    data, target = data.to(device), target.to(device)
                    preds = model(data).argmax(dim=1)
                    corr += (preds==target).sum().item(); tot += target.size(0)
            acc = corr/tot*100
            logging.info(f"[{timestamp()}] Epoch {epoch}/{epochs} Loss={avg_loss:.4f}, Acc={acc:.2f}%")

            if acc>best_acc:
                best_acc=acc
                torch.save(model.state_dict(), ckpt_path)
                logging.info(f"[{timestamp()}] Checkpoint saved: {ckpt_path} (acc={best_acc:.2f}%)")

        final_model = f"c100_{arch}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pth"
        torch.save(model.state_dict(), final_model)
        logging.info(f"[{timestamp()}] IQ-AI-TORCH5 completed, final model: {final_model}")
        return True

    # Pipeline TF1: IQ-AI-TF
    if user_input.startswith("IQ-AI-TF "):
        import tensorflow as tf
        from tensorflow.keras import layers, models
        from tensorflow.keras.datasets import mnist

        def print_usage():
            print("Usage: IQ-AI-TF <hidden> <batch> <epochs> [model_name.h5]")
            return True

        raw = user_input[len("IQ-AI-TF "):].split()
        try:
            hidden_size = int(raw[0])
            batch_size  = int(raw[1])
            epochs      = int(raw[2])
            model_name  = raw[3] if len(raw)>3 else "model_tf.h5"
            if hidden_size<=0 or batch_size<=0 or epochs<=0:
                raise ValueError("Parameters must be >0")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {e}")
            return print_usage()

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] Start IQ-AI-TF hidden={hidden_size}, batch={batch_size}, epochs={epochs}")

        # Load MNIST
        (x_train,y_train),(x_test,y_test) = mnist.load_data()
        x_train = x_train.reshape(-1,28*28)/255.0
        x_test  = x_test.reshape(-1,28*28)/255.0
        logging.info(f"[{timestamp()}] MNIST loaded")

        # Model
        model = models.Sequential([
            layers.Input(shape=(28*28,)),
            layers.Dense(hidden_size, activation='relu'),
            layers.Dense(10, activation='softmax')
        ])
        model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
        logging.info(f"[{timestamp()}] Model compiled")

        # Training
        model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=0,
                  callbacks=[tf.keras.callbacks.LambdaCallback(on_epoch_end=lambda ep, logs: logging.info(
                      f"[{timestamp()}] Epoch {ep+1}/{epochs} Loss={logs['loss']:.4f} Val_Loss={logs['val_loss']:.4f}"))],
                  validation_split=0.1)

        # Evaluation
        loss, acc = model.evaluate(x_test, y_test, batch_size=batch_size, verbose=0)
        logging.info(f"[{timestamp()}] Test Loss={loss:.4f} Accuracy={acc*100:.2f}%")

        # Save
        model.save(model_name)
        logging.info(f"[{timestamp()}] Model saved: {model_name}")
        print(f"[{timestamp()}] IQ-AI-TF completed")
        return True

    # Pipeline TF2: IQ-AI-TF2
    if user_input.startswith("IQ-AI-TF2 "):
        import tensorflow as tf
        from tensorflow.keras import layers, models, callbacks
        from tensorflow.keras.datasets import cifar10

        def print_usage2():
            print("Usage: IQ-AI-TF2 <batch> <epochs> <lr> <patience> [model.h5]")
            return True

        raw = user_input[len("IQ-AI-TF2 "):].split()
        try:
            batch_size    = int(raw[0])
            epochs        = int(raw[1])
            learning_rate = float(raw[2])
            patience      = int(raw[3])
            model_name    = raw[4] if len(raw)>4 else "model_tf2.h5"
            if batch_size<=0 or epochs<=0 or learning_rate<=0 or patience<0:
                raise ValueError("Parameters invalid")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {e}")
            return print_usage2()

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] Start IQ-AI-TF2 batch={batch_size}, epochs={epochs}, lr={learning_rate}, patience={patience}")

        # Load CIFAR-10
        (x_train,y_train),(x_test,y_test) = cifar10.load_data()
        x_train, x_test = x_train/255.0, x_test/255.0
        logging.info(f"[{timestamp()}] CIFAR-10 loaded")

        # Model
        model = models.Sequential([
            layers.Input(shape=(32,32,3)),
            layers.Conv2D(32,3,activation='relu'), layers.MaxPooling2D(),
            layers.Conv2D(64,3,activation='relu'), layers.MaxPooling2D(),
            layers.Flatten(), layers.Dense(128, activation='relu'), layers.Dropout(0.5),
            layers.Dense(10, activation='softmax')
        ])
        model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate),
                      loss='sparse_categorical_crossentropy', metrics=['accuracy'])
        logging.info(f"[{timestamp()}] Model compiled")

        cb = [callbacks.EarlyStopping(patience=patience, restore_best_weights=True),
              callbacks.ReduceLROnPlateau(patience=patience//2)]
        logcb = callbacks.LambdaCallback(on_epoch_end=lambda ep, logs: logging.info(
            f"[{timestamp()}] Epoch {ep+1}/{epochs} Loss={logs['loss']:.4f} Val_Loss={logs['val_loss']:.4f} "
            f"Acc={logs['accuracy']*100:.2f}% Val_Acc={logs['val_accuracy']*100:.2f}%"))

        # Training
        model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, validation_split=0.2,
                  callbacks=cb+[logcb], verbose=0)

        # Evaluation
        loss, acc = model.evaluate(x_test, y_test, batch_size=batch_size, verbose=0)
        logging.info(f"[{timestamp()}] Test Loss={loss:.4f} Accuracy={acc*100:.2f}%")

        # Save
        model.save(model_name)
        logging.info(f"[{timestamp()}] Model saved: {model_name}")
        print(f"[{timestamp()}] IQ-AI-TF2 completed")
        return True

    # Pipeline TF3: IQ-AI-TF3
    if user_input.startswith("IQ-AI-TF3 "):
        import tensorflow as tf
        from tensorflow.keras import layers, models, callbacks
        from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint
        from tensorflow.keras.datasets import fashion_mnist

        def print_usage_tf3():
            print("Usage: IQ-AI-TF3 <batch_size> <epochs> <learning_rate> <dropout> [model_name.h5]")
            return True

        raw = user_input[len("IQ-AI-TF3 "):].split()
        try:
            batch_size    = int(raw[0])
            epochs        = int(raw[1])
            learning_rate = float(raw[2])
            dropout_rate  = float(raw[3])
            model_name    = raw[4] if len(raw)>4 else "model_tf3.h5"
            if batch_size<=0 or epochs<=0 or learning_rate<=0 or not (0<=dropout_rate<1):
                raise ValueError("Invalid numeric parameters.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {e}")
            return print_usage_tf3()

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] Start IQ-AI-TF3 batch={batch_size}, epochs={epochs}, lr={learning_rate}, dropout={dropout_rate}")

        # Load Fashion MNIST
        (x_train, y_train), (x_test, y_test) = fashion_mnist.load_data()
        x_train = x_train.reshape(-1,28,28,1)/255.0
        x_test  = x_test.reshape(-1,28,28,1)/255.0
        logging.info(f"[{timestamp()}] FashionMNIST loaded and normalized")

        # Model definition
        model = models.Sequential([
            layers.Input(shape=(28,28,1)),
            layers.Conv2D(32,3,activation='relu'), layers.MaxPooling2D(),
            layers.Conv2D(64,3,activation='relu'), layers.MaxPooling2D(),
            layers.Flatten(), layers.Dense(128,activation='relu'),
            layers.Dropout(dropout_rate), layers.Dense(10,activation='softmax')
        ])
        model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate),
                      loss='sparse_categorical_crossentropy', metrics=['accuracy'])
        logging.info(f"[{timestamp()}] Model compiled")

        # Callbacks
        cb_list = [
            ModelCheckpoint(model_name, save_best_only=True),
            EarlyStopping(patience=3, restore_best_weights=True)
        ]
        log_cb = callbacks.LambdaCallback(
            on_epoch_end=lambda ep,logs: logging.info(
                f"[{timestamp()}] Epoch {ep+1}/{epochs} "
                f"Loss={logs['loss']:.4f} ValLoss={logs['val_loss']:.4f} "
                f"Acc={logs['accuracy']*100:.2f}% ValAcc={logs['val_accuracy']*100:.2f}%"
            )
        )

        # Training
        model.fit(x_train, y_train,
                  batch_size=batch_size, epochs=epochs,
                  validation_split=0.2,
                  callbacks=cb_list+[log_cb], verbose=0)

        # Evaluation
        loss, acc = model.evaluate(x_test, y_test, batch_size=batch_size, verbose=0)
        logging.info(f"[{timestamp()}] Test Loss={loss:.4f} Accuracy={acc*100:.2f}%")

        print(f"[{timestamp()}] IQ-AI-TF3 completed, best model saved as {model_name}")
        return True

    # Pipeline JAX: IQ-AI-JAX
    if user_input.startswith("IQ-AI-JAX "):
        import jax
        import jax.numpy as jnp
        from jax import random, grad, jit
        from tensorflow.keras.datasets import mnist

        def print_usage_jax():
            print("Usage: IQ-AI-JAX <hidden_size> <batch_size> <epochs> [model_name.npz]")
            return True

        raw = user_input[len("IQ-AI-JAX "):].split()
        try:
            hidden_size = int(raw[0])
            batch_size  = int(raw[1])
            epochs      = int(raw[2])
            model_name  = raw[3] if len(raw)>3 else "model_jax.npz"
            if hidden_size<=0 or batch_size<=0 or epochs<=0:
                raise ValueError("Invalid numeric parameters.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {e}")
            return print_usage_jax()

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] Start IQ-AI-JAX hidden={hidden_size}, batch={batch_size}, epochs={epochs}")

        # Load MNIST
        (x_train,y_train),(x_test,y_test) = mnist.load_data()
        x_train = x_train.reshape(-1,28*28)/255.0
        x_test  = x_test.reshape(-1,28*28)/255.0
        num_train = x_train.shape[0]
        steps_per_epoch = num_train//batch_size
        key = random.PRNGKey(0)
        logging.info(f"[{timestamp()}] MNIST loaded and preprocessed")

        # Initialize params
        def init_params(k):
            k1,k2 = random.split(k)
            W1 = random.normal(k1,(28*28,hidden_size))*jnp.sqrt(2/(28*28))
            b1 = jnp.zeros(hidden_size)
            W2 = random.normal(k2,(hidden_size,10))*jnp.sqrt(2/hidden_size)
            b2 = jnp.zeros(10)
            return {'W1':W1,'b1':b1,'W2':W2,'b2':b2}
        params = init_params(key)

        # Forward and loss
        def forward(p,x):
            h = jnp.dot(x,p['W1'])+p['b1']; h=jnp.maximum(h,0)
            return jnp.dot(h,p['W2'])+p['b2']
        def loss_fn(p,x,y):
            logits = forward(p,x)
            one_hot = jax.nn.one_hot(y,10)
            return -jnp.mean(jnp.sum(one_hot*jax.nn.log_softmax(logits),axis=-1))
        grad_fn = jit(grad(loss_fn))

        # Update
        lr=1e-3
        def update(p,g): return {k:p[k]-lr*g[k] for k in p}

        # Training
        for epoch in range(1,epochs+1):
            perm = random.permutation(key,num_train)
            for i in range(steps_per_epoch):
                idx = perm[i*batch_size:(i+1)*batch_size]
                grads = grad_fn(params,x_train[idx],y_train[idx])
                params = update(params,grads)
            train_loss = loss_fn(params,x_train[:10000],y_train[:10000])
            logging.info(f"[{timestamp()}] Epoch {epoch}/{epochs} Loss={train_loss:.4f}")

        # Evaluation
        def accuracy(p,x,y): return jnp.mean(jnp.argmax(forward(p,x),axis=-1)==y)
        test_acc = accuracy(params,x_test,y_test)*100
        logging.info(f"[{timestamp()}] Test Accuracy={test_acc:.2f}%")

        # Save
        onp.savez(model_name, **{k:onp.array(v) for k,v in params.items()})
        logging.info(f"Model saved as {model_name}")
        print(f"[{timestamp()}] IQ-AI-JAX pipeline completed")
        return True

    # Pipeline JAX2: IQ-AI-JAX2
    if user_input.startswith("IQ-AI-JAX2 "):
        import jax
        import jax.numpy as jnp
        from jax import random, grad, jit

        def print_usage_jax2():
            print("Usage: IQ-AI-JAX2 <returns_csv> <learning_rate> <epochs> [output_weights.npy]")
            return True

        raw = user_input[len("IQ-AI-JAX2 "):].split()
        try:
            returns_csv   = raw[0]
            learning_rate = float(raw[1])
            epochs        = int(raw[2])
            out_file      = raw[3] if len(raw)>3 else "weights_jax2.npy"
            if learning_rate <= 0 or epochs <= 0:
                raise ValueError("Learning rate and epochs must be > 0.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {e}")
            return print_usage_jax2()

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] Start IQ-AI-JAX2 returns_csv={returns_csv}, lr={learning_rate}, epochs={epochs}")

        # Load returns data
        try:
            data = onp.loadtxt(returns_csv, delimiter=",", skiprows=1)
            mu = jnp.mean(data, axis=0)
            cov = jnp.cov(data, rowvar=False)
            n_assets = mu.shape[0]
            logging.info(f"[{timestamp()}] Loaded returns for {n_assets} assets")
        except Exception as e:
            logging.error(f"[{timestamp()}] Error loading data: {e}")
            return True

        key = random.PRNGKey(0)
        weights_raw = random.normal(key, (n_assets,))
        risk_free = float(os.environ.get("RISK_FREE_RATE", 0.01))

        def sharpe_loss(w_raw):
            w = jax.nn.softmax(w_raw)
            ret = jnp.dot(mu, w) - risk_free
            vol = jnp.sqrt(w @ cov @ w)
            return - (ret / vol)

        grad_fn = jit(grad(sharpe_loss))

        for epoch in range(1, epochs+1):
            grads = grad_fn(weights_raw)
            weights_raw = weights_raw - learning_rate * grads
            if epoch % max(1, epochs//10) == 0 or epoch == 1:
                loss = sharpe_loss(weights_raw)
                logging.info(f"[{timestamp()}] Epoch {epoch}/{epochs} Loss(negSharpe)={loss:.6f}")

        weights = onp.array(jax.nn.softmax(weights_raw))
        sharpe_ratio = - float(sharpe_loss(weights_raw))
        logging.info(f"[{timestamp()}] Final Sharpe ratio={sharpe_ratio:.4f}")

        onp.save(out_file, weights)
        logging.info(f"[{timestamp()}] Weights saved to {out_file}")
        print(f"[{timestamp()}] IQ-AI-JAX2 completed – Sharpe={sharpe_ratio:.4f}")
        return True

    # Pipeline JAX3: IQ-AI-JAX3
    if user_input.startswith("IQ-AI-JAX3 "):
        import jax
        import jax.numpy as jnp
        from jax import random, jit, vmap

        def print_usage_jax3():
            print("Usage: IQ-AI-JAX3 <data_csv> <n_clusters> <max_iter> [output_centroids.npy]")
            return True

        raw = user_input[len("IQ-AI-JAX3 "):].split()
        try:
            data_csv   = raw[0]
            n_clusters = int(raw[1])
            max_iter   = int(raw[2])
            out_file   = raw[3] if len(raw)>3 else "centroids_jax3.npy"
            if n_clusters <= 0 or max_iter <= 0:
                raise ValueError("n_clusters and max_iter must be > 0.")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {e}")
            return print_usage_jax3()

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] Start IQ-AI-JAX3 data_csv={data_csv}, clusters={n_clusters}, max_iter={max_iter}")

        try:
            data = onp.loadtxt(data_csv, delimiter=",", skiprows=1)
            logging.info(f"Loaded data: {data.shape[0]} samples, {data.shape[1]} features")
        except Exception as e:
            logging.error(f"Error loading data: {e}")
            return True

        key = random.PRNGKey(0)
        centroids = random.permutation(key, data)[:n_clusters]

        def assign_clusters(pts, cents):
            d = jnp.linalg.norm(pts[:,None,:] - cents[None,:,:], axis=-1)
            return jnp.argmin(d, axis=1)

        @jit
        def update_centroids(pts, cents):
            labels = assign_clusters(pts, cents)
            def centroid_fn(i):
                mask = labels == i
                return jnp.where(mask.sum()>0, jnp.mean(pts[mask], axis=0), cents[i])
            return vmap(centroid_fn)(jnp.arange(n_clusters))

        for i in range(1, max_iter+1):
            new_c = update_centroids(jnp.array(data), centroids)
            shift = jnp.max(jnp.linalg.norm(new_c - centroids, axis=1))
            centroids = new_c
            logging.info(f"Epoch {i}/{max_iter} max shift={shift:.6f}")
            if shift < 1e-6:
                logging.info(f"Converged after {i} iterations")
                break

        onp.save(out_file, onp.array(centroids))
        logging.info(f"Centroids saved to {out_file}")
        print(f"[{timestamp()}] IQ-AI-JAX3 K-Means completed")
        return True

    if user_input.startswith("IQ-FINANCE-MATPLOTLIB "):
        import matplotlib.pyplot as plt
        # Remove the command prefix and split arguments
        args_str = user_input[len("IQ-FINANCE-MATPLOTLIB "):].strip()
        args = args_str.split()

        # Validate minimum number of args
        if len(args) < 3:
            print("Usage:")
            print("  IQ-FINANCE-MATPLOTLIB <CSV_PATH> <DATE_COLUMN> <VALUE_COLUMN> [OUTPUT_IMAGE_NAME]")
            return True

        csv_path = args[0]
        date_column = args[1]
        value_column = args[2]
        output_image = args[3] if len(args) > 3 else "finance_plot.png"

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] [INFO] Starting IQ-FINANCE-matplotlib")
        logging.info(f"[{timestamp()}] [INFO] Loading file: {csv_path}")

        # Check file existence
        if not os.path.isfile(csv_path):
            print(f"[{timestamp()}] [ERROR] CSV file not found: {csv_path}")
            return True

        # Load and process data
        try:
            df = pd.read_csv(csv_path)
            df[date_column] = pd.to_datetime(df[date_column], errors='coerce')
            df = df.dropna(subset=[date_column, value_column])
            df.sort_values(by=date_column, inplace=True)
            logging.info(f"[{timestamp()}] [INFO] CSV data loaded successfully")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Failed to load CSV file: {e}")
            return True

        # Create and save plot
        try:
            plt.figure(figsize=(12, 6))
            plt.plot(df[date_column], df[value_column], marker='o', linestyle='-')
            plt.title(f"Financial Data: {value_column} over Time")
            plt.xlabel("Date")
            plt.ylabel(value_column)
            plt.grid(True)
            plt.tight_layout()
            plt.savefig(output_image)
            logging.info(f"[{timestamp()}] [INFO] Plot saved as {output_image}")
            plt.show()
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Failed to generate plot: {e}")
            return True

        print(f"[{timestamp()}] [END] IQ-FINANCE-matplotlib completed")
        return True

    if user_input.startswith("IQ-FINANCE-MATPLOTLIB-AD "):
        import yfinance as yf
        import matplotlib.pyplot as plt
        import seaborn as sns

        args_str = user_input[len("IQ-FINANCE-MATPLOTLIB-AD "):].strip()
        args = args_str.split()

        if len(args) < 2:
            print("Usage: IQ-FINANCE-MATPLOTLIB-AD <MODE> <PARAMETERS...>")
            return True

        mode = args[0].lower()
        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] [INFO] Starting mode '{mode}'")

        try:
            if mode == "csv":
                csv_path, date_col, val_col = args[1], args[2], args[3]
                output_image = args[4] if len(args) > 4 else "csv_plot.png"
                df = pd.read_csv(csv_path)
                df[date_col] = pd.to_datetime(df[date_col], errors='coerce')
                df.dropna(subset=[date_col, val_col], inplace=True)
                plt.figure(figsize=(12, 6))
                plt.plot(df[date_col], df[val_col])
                plt.title(f"{val_col} over Time")
                plt.xlabel("Date")
                plt.ylabel(val_col)
                plt.tight_layout()
                plt.savefig(output_image)
                plt.show()

            elif mode == "yf":
                tickers, start, end, metric = args[1].split(","), args[2], args[3], args[4]
                output = args[5] if len(args) > 5 else "yf_plot.png"
                data = yf.download(tickers, start=start, end=end)
                plt.figure(figsize=(14, 7))
                for t in tickers:
                    plt.plot(data[t][metric] if len(tickers) > 1 else data[metric], label=t)
                plt.legend()
                plt.title(f"{metric} from {start} to {end}")
                plt.tight_layout()
                plt.savefig(output)
                plt.show()

            elif mode == "yf-ma":
                ticker, start, end, metric, window = args[1], args[2], args[3], args[4], int(args[5])
                df = yf.download(ticker, start=start, end=end)
                df["MA"] = df[metric].rolling(window=window).mean()
                plt.figure(figsize=(12, 6))
                plt.plot(df[metric], label=metric)
                plt.plot(df["MA"], label=f"{window}-day MA")
                plt.title(f"{ticker} {metric} with {window}-day Moving Average")
                plt.legend()
                plt.tight_layout()
                plt.show()

            elif mode == "yf-vol":
                ticker, start, end, metric, window = args[1], args[2], args[3], args[4], int(args[5])
                df = yf.download(ticker, start=start, end=end)
                df["Volatility"] = df[metric].rolling(window=window).std()
                plt.figure(figsize=(12, 6))
                plt.plot(df["Volatility"], label="Rolling Std Dev")
                plt.title(f"{ticker} Rolling Volatility ({window} days)")
                plt.tight_layout()
                plt.show()

            elif mode == "yf-compare":
                tickers, start, end = args[1].split(","), args[2], args[3]
                df = yf.download(tickers, start=start, end=end)["Close"]
                df = df / df.iloc[0]  # Normalize
                df.plot(figsize=(14, 7), title="Normalized Price Comparison")
                plt.tight_layout()
                plt.show()

            elif mode == "yf-bar":
                ticker, start, end, metric = args[1], args[2], args[3], args[4]
                df = yf.download(ticker, start=start, end=end)
                plt.figure(figsize=(12, 6))
                plt.bar(df.index, df[metric])
                plt.title(f"{ticker} {metric} as Bar Chart")
                plt.tight_layout()
                plt.show()

            elif mode == "yf-corr":
                tickers, start, end = args[1].split(","), args[2], args[3]
                df = yf.download(tickers, start=start, end=end)["Close"]
                corr = df.corr()
                plt.figure(figsize=(10, 8))
                sns.heatmap(corr, annot=True, cmap="coolwarm", fmt=".2f")
                plt.title("Correlation Matrix of Closing Prices")
                plt.tight_layout()
                plt.show()

            else:
                print(f"[{timestamp()}] [ERROR] Unknown mode '{mode}'")

            print(f"[{timestamp()}] [END] IQ-FINANCE-MATPLOTLIB-AD completed")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Exception occurred: {e}")
        return True

    if user_input.startswith("IQ-FINANCE-MATPLOTLIB-AD2 "):
        import yfinance as yf
        import matplotlib.pyplot as plt

        args_str = user_input[len("IQ-FINANCE-MATPLOTLIB-AD2 "):].strip()
        args = args_str.split()

        if len(args) < 4:
            print("Usage: IQ-FINANCE-MATPLOTLIB-AD2 <OPERATOR> <TICKER> <START_DATE> <END_DATE> [ADDITIONAL_ARGS]")
            return True

        operator = args[0].lower()
        ticker = args[1]
        start_date = args[2]
        end_date = args[3]

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] [INFO] Running operator: {operator}")

        try:
            df = yf.download(ticker, start=start_date, end=end_date)
            close = df["Close"]

            if operator == "returns":
                freq = args[4] if len(args) > 4 else "daily"
                ret = close.pct_change()
                if freq == "monthly":
                    ret = close.resample("M").ffill().pct_change()
                ret.plot(title=f"{ticker} {freq.capitalize()} Returns")
                plt.grid(True)
                plt.tight_layout()
                plt.show()

            elif operator == "logret":
                logret = onp.log(close / close.shift(1))
                logret.plot(title=f"{ticker} Log Returns")
                plt.grid(True)
                plt.tight_layout()
                plt.show()

            elif operator == "sharpe":
                rate = float(args[5]) if len(args) > 5 else 0.01
                daily_ret = close.pct_change().dropna()
                sharpe = ((daily_ret.mean() - rate / 252) / daily_ret.std()) * onp.sqrt(252)
                print(f"Sharpe Ratio ({ticker}): {sharpe:.4f}")

            elif operator == "stats":
                metric = args[4] if len(args) > 4 else "Close"
                series = df[metric]
                print(series.describe())

            elif operator == "diff":
                diff = close.diff()
                diff.plot(title=f"{ticker} Price Differences")
                plt.grid(True)
                plt.tight_layout()
                plt.show()

            elif operator == "rollingmean":
                window = int(args[4]) if len(args) > 4 else 20
                ma = close.rolling(window).mean()
                plt.plot(close, label="Close")
                plt.plot(ma, label=f"{window}-day MA")
                plt.title(f"{ticker} Moving Average")
                plt.legend()
                plt.tight_layout()
                plt.show()

            elif operator == "rollingstd":
                window = int(args[4]) if len(args) > 4 else 14
                std = close.rolling(window).std()
                std.plot(title=f"{ticker} Rolling Volatility ({window}d)")
                plt.tight_layout()
                plt.show()

            elif operator == "drawdown":
                cummax = close.cummax()
                drawdown = (close - cummax) / cummax
                drawdown.plot(title=f"{ticker} Drawdown")
                plt.grid(True)
                plt.tight_layout()
                plt.show()
                print(f"Max Drawdown: {drawdown.min():.2%}")

            elif operator == "cumsum":
                perf = close.pct_change().fillna(0).cumsum()
                perf.plot(title=f"{ticker} Cumulative Return")
                plt.grid(True)
                plt.tight_layout()
                plt.show()

            elif operator == "resample":
                rule = args[4] if len(args) > 4 else "W"
                resampled = close.resample(rule).last()
                resampled.plot(title=f"{ticker} Resampled ({rule})")
                plt.grid(True)
                plt.tight_layout()
                plt.show()

            else:
                print(f"[{timestamp()}] [ERROR] Unknown operator: {operator}")
                return True

            print(f"[{timestamp()}] [END] IQ-FINANCE-MATPLOTLIB-AD2 completed")

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Exception: {e}")
        return True

    if user_input.startswith("IQ-FINANCE-MATPLOTLIB-AD3 "):
        import yfinance as yf
        import matplotlib.pyplot as plt
        import seaborn as sns
        import mplfinance as mpf

        args_str = user_input[len("IQ-FINANCE-MATPLOTLIB-AD3 "):].strip()
        args = args_str.split()

        if len(args) < 4:
            print("Usage: IQ-FINANCE-MATPLOTLIB-AD3 <MODE> <TICKER(S)> <START_DATE> <END_DATE> [MORE]")
            return True

        mode = args[0].lower()
        tickers = args[1].split(",")
        start_date = args[2]
        end_date = args[3]

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] [INFO] Mode selected: {mode}")

        try:
            df = yf.download(tickers, start=start_date, end=end_date)
            if "Close" in df:
                close_data = df["Close"]
            else:
                close_data = df["Adj Close"] if "Adj Close" in df else df.iloc[:, 0]

            if mode == "heatmap":
                corr = close_data.corr()
                plt.figure(figsize=(10, 8))
                sns.heatmap(corr, annot=True, cmap="YlGnBu", fmt=".2f")
                plt.title("Correlation Heatmap")
                plt.tight_layout()
                plt.show()

            elif mode == "histogram":
                ticker = tickers[0]
                metric = args[4] if len(args) > 4 else "returns"
                data = df["Close"][ticker] if isinstance(df["Close"], pd.DataFrame) else df["Close"]
                if metric == "returns":
                    values = data.pct_change().dropna()
                else:
                    values = data.dropna()
                plt.figure(figsize=(10, 6))
                plt.hist(values, bins=50, alpha=0.7, color="skyblue")
                plt.title(f"{ticker} Histogram of {metric}")
                plt.tight_layout()
                plt.show()

            elif mode == "boxplot":
                ticker = tickers[0]
                metric = args[4] if len(args) > 4 else "Close"
                series = df[metric][ticker] if isinstance(df[metric], pd.DataFrame) else df[metric]
                plt.figure(figsize=(6, 8))
                sns.boxplot(y=series.dropna())
                plt.title(f"{ticker} {metric} Boxplot")
                plt.tight_layout()
                plt.show()

            elif mode == "pairplot":
                df_close = df["Close"]
                df_sampled = df_close.resample("W").last().dropna()
                sns.pairplot(df_sampled)
                plt.suptitle("Pairplot of Weekly Closing Prices", y=1.02)
                plt.tight_layout()
                plt.show()

            elif mode == "kdeplot":
                ticker = tickers[0]
                returns = df["Close"][ticker].pct_change().dropna()
                sns.kdeplot(returns, fill=True, color="purple")
                plt.title(f"{ticker} Return Density (KDE)")
                plt.tight_layout()
                plt.show()

            elif mode == "dualaxis":
                ticker = tickers[0]
                metric1 = args[4]
                metric2 = args[5]
                df1 = df[metric1][ticker] if isinstance(df[metric1], pd.DataFrame) else df[metric1]
                df2 = df[metric2][ticker] if isinstance(df[metric2], pd.DataFrame) else df[metric2]

                fig, ax1 = plt.subplots(figsize=(12, 6))
                ax2 = ax1.twinx()
                ax1.plot(df1, color='blue', label=metric1)
                ax2.plot(df2, color='orange', label=metric2)
                ax1.set_ylabel(metric1)
                ax2.set_ylabel(metric2)
                plt.title(f"{ticker}: {metric1} vs {metric2}")
                fig.tight_layout()
                plt.show()

            elif mode == "candlestick":
                ticker = tickers[0]
                df_candle = yf.download(ticker, start=start_date, end=end_date)
                df_candle.index.name = 'Date'
                df_candle = df_candle[["Open", "High", "Low", "Close", "Volume"]]
                mpf.plot(df_candle, type='candle', volume=True, style='yahoo', title=f"{ticker} Candlestick Chart")

            else:
                print(f"[{timestamp()}] [ERROR] Unknown mode: {mode}")
                return True

            print(f"[{timestamp()}] [END] IQ-FINANCE-MATPLOTLIB-AD3 completed")

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Exception occurred: {e}")
        return True

    # IQ-FINANCE-PLOTLY
    if user_input.startswith("IQ-FINANCE-PLOTLY "):
        import plotly.express as px
        # Argument-Parsing
        raw = user_input[len("IQ-FINANCE-PLOTLY "):].strip().split()
        positionals, opts = [], {}
        i = 0
        while i < len(raw):
            tok = raw[i]
            if tok.startswith("--"):
                key = tok.lstrip('-')
                if '=' in key:
                    k, v = key.split('=', 1)
                else:
                    i += 1
                    v = raw[i] if i < len(raw) else True
                    k = key
                opts[k] = v.strip("'\"")
            else:
                positionals.append(tok)
            i += 1

        if len(positionals) < 3:
            print("Usage: IQ-FINANCE-PLOTLY <CSV> <DATE_COLUMN> <VALUE_COLUMN> [--type line|bar] [--title TITLE] [--output FILE]")
            return True

        csv_path, date_col, val_col = positionals[:3]
        chart_type = opts.get('type', 'line')
        title = opts.get('title', f"{val_col} over Time")
        output = opts.get('output', 'chart.html')

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] [INFO] Loading CSV: {csv_path}")

        if not os.path.isfile(csv_path):
            print(f"[{timestamp()}] [ERROR] CSV not found: {csv_path}")
            return True

        try:
            df = pd.read_csv(csv_path)
            df[date_col] = pd.to_datetime(df[date_col], errors='coerce')
            df = df.dropna(subset=[date_col, val_col])
            df.sort_values(by=date_col, inplace=True)
            logging.info(f"[{timestamp()}] [INFO] Data rows: {len(df)}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Load failed: {e}")
            return True

        try:
            fig = px.bar(df, x=date_col, y=val_col, title=title) if chart_type == 'bar' else \
                  px.line(df, x=date_col, y=val_col, title=title, markers=True)
            fig.update_layout(xaxis_title=date_col, yaxis_title=val_col)
            fig.write_html(output, include_plotlyjs='cdn')
            logging.info(f"[{timestamp()}] [INFO] Saved Plotly chart: {output}")

            # HTML im Browser öffnen
            webbrowser.open(f"file://{os.path.abspath(output)}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Chart creation failed: {e}")
            return True

        print(f"[{timestamp()}] [END] IQ-FINANCE-plotly completed")
        return True

    if user_input.startswith("IQ-FINANCE-PLOTLY-AD "):
        import yfinance as yf
        import plotly.graph_objects as go
        import plotly.express as px

        args_str = user_input[len("IQ-FINANCE-PLOTLY-AD "):].strip()
        args = args_str.split()

        if len(args) < 2:
            print("Usage: IQ-FINANCE-PLOTLY-AD <MODE> <PARAMETERS...>")
            return True

        mode = args[0].lower()
        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] [INFO] Starting mode '{mode}'")

        try:
            if mode == "csv":
                csv_path, date_col, val_col = args[1], args[2], args[3]
                output_image = args[4] if len(args) > 4 else "csv_plot.html"
                df = pd.read_csv(csv_path)
                df[date_col] = pd.to_datetime(df[date_col], errors='coerce')
                df.dropna(subset=[date_col, val_col], inplace=True)
                fig = px.line(df, x=date_col, y=val_col, title=f"{val_col} over Time")
                fig.write_html(output_image)
                fig.show()

            elif mode == "yf":
                tickers, start, end, metric = args[1].split(","), args[2], args[3], args[4]
                output = args[5] if len(args) > 5 else "yf_plot.html"
                data = yf.download(tickers, start=start, end=end)
                fig = go.Figure()
                for t in tickers:
                    y = data[t][metric] if len(tickers) > 1 else data[metric]
                    fig.add_trace(go.Scatter(x=data.index, y=y, mode='lines', name=t))
                fig.update_layout(title=f"{metric} from {start} to {end}")
                fig.write_html(output)
                fig.show()

            elif mode == "yf-ma":
                ticker, start, end, metric, window = args[1], args[2], args[3], args[4], int(args[5])
                df = yf.download(ticker, start=start, end=end)
                df["MA"] = df[metric].rolling(window=window).mean()
                fig = go.Figure()
                fig.add_trace(go.Scatter(x=df.index, y=df[metric], mode='lines', name=metric))
                fig.add_trace(go.Scatter(x=df.index, y=df["MA"], mode='lines', name=f"{window}-day MA"))
                fig.update_layout(title=f"{ticker} {metric} with {window}-day Moving Average")
                fig.show()

            elif mode == "yf-vol":
                ticker, start, end, metric, window = args[1], args[2], args[3], args[4], int(args[5])
                df = yf.download(ticker, start=start, end=end)
                df["Volatility"] = df[metric].rolling(window=window).std()
                fig = px.line(df, x=df.index, y="Volatility", title=f"{ticker} Rolling Volatility ({window} days)")
                fig.show()

            elif mode == "yf-compare":
                tickers, start, end = args[1].split(","), args[2], args[3]
                df = yf.download(tickers, start=start, end=end)["Close"]
                df = df / df.iloc[0]  # Normalize
                fig = px.line(df, x=df.index, y=df.columns, title="Normalized Price Comparison")
                fig.show()

            elif mode == "yf-bar":
                ticker, start, end, metric = args[1], args[2], args[3], args[4]
                df = yf.download(ticker, start=start, end=end)
                fig = px.bar(df, x=df.index, y=metric, title=f"{ticker} {metric} as Bar Chart")
                fig.show()

            elif mode == "yf-corr":
                tickers, start, end = args[1].split(","), args[2], args[3]
                df = yf.download(tickers, start=start, end=end)["Close"]
                corr = df.corr().reset_index().melt(id_vars='index')
                fig = px.imshow(df.corr(), text_auto=True, color_continuous_scale="RdBu", zmin=-1, zmax=1,
                                title="Correlation Matrix of Closing Prices")
                fig.show()

            else:
                print(f"[{timestamp()}] [ERROR] Unknown mode '{mode}'")

            print(f"[{timestamp()}] [END] IQ-FINANCE-PLOTLY-AD completed")

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Exception occurred: {e}")
        return True

    if user_input.startswith("IQ-FINANCE-PLOTLY-AD2 "):
        import yfinance as yf
        import plotly.graph_objects as go
        import plotly.express as px

        args_str = user_input[len("IQ-FINANCE-PLOTLY-AD2 "):].strip()
        args = args_str.split()

        if len(args) < 4:
            print("Usage: IQ-FINANCE-PLOTLY-AD2 <OPERATOR> <TICKER> <START_DATE> <END_DATE> [ADDITIONAL_ARGS]")
            return True

        operator = args[0].lower()
        ticker = args[1]
        start_date = args[2]
        end_date = args[3]

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] [INFO] Running operator: {operator}")

        try:
            df = yf.download(ticker, start=start_date, end=end_date)
            close = df["Close"]

            if operator == "returns":
                freq = args[4] if len(args) > 4 else "daily"
                if freq == "monthly":
                    ret = close.resample("M").ffill().pct_change()
                else:
                    ret = close.pct_change()
                fig = px.line(x=ret.index, y=ret.values, labels={"x": "Date", "y": "Returns"},
                            title=f"{ticker} {freq.capitalize()} Returns")
                fig.show()

            elif operator == "logret":
                logret = onp.log(close / close.shift(1))
                fig = px.line(x=logret.index, y=logret.values, labels={"x": "Date", "y": "Log Returns"},
                            title=f"{ticker} Log Returns")
                fig.show()

            elif operator == "sharpe":
                rate = float(args[4]) if len(args) > 4 else 0.01
                daily_ret = close.pct_change().dropna()
                sharpe = ((daily_ret.mean() - rate / 252) / daily_ret.std()) * onp.sqrt(252)
                print(f"Sharpe Ratio ({ticker}): {sharpe:.4f}")

            elif operator == "stats":
                metric = args[4] if len(args) > 4 else "Close"
                series = df[metric]
                print(series.describe())

            elif operator == "diff":
                diff = close.diff()
                fig = px.line(x=diff.index, y=diff.values, labels={"x": "Date", "y": "Price Difference"},
                            title=f"{ticker} Price Differences")
                fig.show()

            elif operator == "rollingmean":
                window = int(args[4]) if len(args) > 4 else 20
                ma = close.rolling(window).mean()
                fig = go.Figure()
                fig.add_trace(go.Scatter(x=close.index, y=close, mode='lines', name="Close"))
                fig.add_trace(go.Scatter(x=ma.index, y=ma, mode='lines', name=f"{window}-day MA"))
                fig.update_layout(title=f"{ticker} Moving Average")
                fig.show()

            elif operator == "rollingstd":
                window = int(args[4]) if len(args) > 4 else 14
                std = close.rolling(window).std()
                fig = px.line(x=std.index, y=std.values, labels={"x": "Date", "y": "Volatility"},
                            title=f"{ticker} Rolling Volatility ({window}d)")
                fig.show()

            elif operator == "drawdown":
                cummax = close.cummax()
                drawdown = (close - cummax) / cummax
                fig = px.area(x=drawdown.index, y=drawdown.values, labels={"x": "Date", "y": "Drawdown"},
                            title=f"{ticker} Drawdown")
                fig.update_yaxes(tickformat=".0%")
                fig.show()
                print(f"Max Drawdown: {drawdown.min():.2%}")

            elif operator == "cumsum":
                perf = close.pct_change().fillna(0).cumsum()
                fig = px.line(x=perf.index, y=perf.values, labels={"x": "Date", "y": "Cumulative Return"},
                            title=f"{ticker} Cumulative Return")
                fig.show()

            elif operator == "resample":
                rule = args[4] if len(args) > 4 else "W"
                resampled = close.resample(rule).last()
                fig = px.line(x=resampled.index, y=resampled.values, labels={"x": "Date", "y": "Resampled Price"},
                            title=f"{ticker} Resampled ({rule})")
                fig.show()

            else:
                print(f"[{timestamp()}] [ERROR] Unknown operator: {operator}")
                return True

            print(f"[{timestamp()}] [END] IQ-FINANCE-PLOTLY-AD2 completed")

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Exception: {e}")
        return True

    if user_input.startswith("IQ-FINANCE-PLOTLY-AD3 "):
        import yfinance as yf
        import plotly.express as px
        import plotly.graph_objects as go

        args_str = user_input[len("IQ-FINANCE-PLOTLY-AD3 "):].strip()
        args = args_str.split()

        if len(args) < 4:
            print("Usage: IQ-FINANCE-PLOTLY-AD3 <MODE> <TICKER(S)> <START_DATE> <END_DATE> [MORE]")
            return True

        mode = args[0].lower()
        tickers = args[1].split(",")
        start_date = args[2]
        end_date = args[3]

        logging.basicConfig(level=logging.INFO, format="%(message)s")
        logging.info(f"[{timestamp()}] [INFO] Mode selected: {mode}")

        try:
            df = yf.download(tickers, start=start_date, end=end_date, group_by="ticker", auto_adjust=False)
            close_data = df["Close"] if "Close" in df else df["Adj Close"]

            if mode == "heatmap":
                corr = close_data.corr()
                fig = px.imshow(corr, text_auto=".2f", color_continuous_scale="YlGnBu",
                                title="Correlation Heatmap")
                fig.update_layout(margin=dict(t=40))
                fig.show()

            elif mode == "histogram":
                ticker = tickers[0]
                metric = args[4] if len(args) > 4 else "returns"
                data = df["Close"][ticker] if isinstance(df["Close"], pd.DataFrame) else df["Close"]
                values = data.pct_change().dropna() if metric == "returns" else data.dropna()
                fig = px.histogram(values, nbins=50, title=f"{ticker} Histogram of {metric}",
                                labels={"value": metric})
                fig.show()

            elif mode == "boxplot":
                ticker = tickers[0]
                metric = args[4] if len(args) > 4 else "Close"
                series = df[metric][ticker] if isinstance(df[metric], pd.DataFrame) else df[metric]
                fig = px.box(y=series.dropna(), title=f"{ticker} {metric} Boxplot",
                            labels={"y": metric})
                fig.show()

            elif mode == "pairplot":
                df_close = df["Close"]
                df_sampled = df_close.resample("W").last().dropna()
                fig = px.scatter_matrix(df_sampled, title="Pairplot of Weekly Closing Prices")
                fig.update_traces(diagonal_visible=True)
                fig.show()

            elif mode == "kdeplot":
                ticker = tickers[0]
                returns = df["Close"][ticker].pct_change().dropna()
                fig = px.histogram(returns, nbins=100, histnorm='probability density', opacity=0.75,
                                marginal="violin", title=f"{ticker} Return Density (KDE)")
                fig.show()

            elif mode == "dualaxis":
                ticker = tickers[0]
                metric1 = args[4]
                metric2 = args[5]
                df1 = df[metric1][ticker] if isinstance(df[metric1], pd.DataFrame) else df[metric1]
                df2 = df[metric2][ticker] if isinstance(df[metric2], pd.DataFrame) else df[metric2]

                fig = go.Figure()
                fig.add_trace(go.Scatter(x=df1.index, y=df1, name=metric1, yaxis="y1"))
                fig.add_trace(go.Scatter(x=df2.index, y=df2, name=metric2, yaxis="y2"))

                fig.update_layout(
                    title=f"{ticker}: {metric1} vs {metric2}",
                    yaxis=dict(title=metric1),
                    yaxis2=dict(title=metric2, overlaying='y', side='right'),
                    legend=dict(x=0, y=1.1, orientation='h')
                )
                fig.show()

            elif mode == "candlestick":
                ticker = tickers[0]
                df_candle = yf.download(ticker, start=start_date, end=end_date)
                fig = go.Figure(data=[go.Candlestick(
                    x=df_candle.index,
                    open=df_candle["Open"],
                    high=df_candle["High"],
                    low=df_candle["Low"],
                    close=df_candle["Close"],
                    increasing_line_color='green',
                    decreasing_line_color='red'
                )])
                fig.update_layout(title=f"{ticker} Candlestick Chart", xaxis_title="Date", yaxis_title="Price")
                fig.show()

            else:
                print(f"[{timestamp()}] [ERROR] Unknown mode: {mode}")
                return True

            print(f"[{timestamp()}] [END] IQ-FINANCE-PLOTLY-AD3 completed")

        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Exception occurred: {e}")
        return True

    # IQ-FINANCE-GRAFANA
    if user_input.startswith("IQ-FINANCE-GRAFANA "):
        raw = user_input[len("IQ-FINANCE-GRAFANA "):].strip().split()
        pos, opts = [], {}
        i = 0
        while i < len(raw):
            t = raw[i]
            if t.startswith("--"):
                key = t.lstrip('-')
                if '=' in key:
                    k, v = key.split('=',1)
                else:
                    i += 1
                    v = raw[i] if i < len(raw) else True
                    k = key
                opts[k] = v.strip("'\"")
            else:
                pos.append(t)
            i += 1

        if len(pos) < 3:
            print("Usage: IQ-FINANCE-GRAFANA <CSV> <DATE_COLUMN> <VALUE_COLUMN> [--folder DIR] [--dashboard NAME]")
            return True

        csv_path, date_col, val_col = pos[:3]
        folder = opts.get('folder', 'grafana-data')
        dashboard = opts.get('dashboard', 'Finance Dashboard')

        os.makedirs(folder, exist_ok=True)
        ds = os.path.join(folder, 'datasource.csv')
        try:
            pd.read_csv(csv_path).to_csv(ds, index=False)
            logging.info(f"[{timestamp()}] [INFO] Datasource at: {ds}")
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Copy failed: {e}")
            return True

        dash = {
            "dashboard": {"title": dashboard, "panels":[{
                "type":"graph","title":val_col,
                "targets":[{"refId":"A","csv":ds,"timeColumn":date_col,"valueColumn":val_col}],
                "xaxis":{"mode":"time"},"yaxes":[{},{}]
            }]},"overwrite":True
        }
        dp = os.path.join(folder,'dashboard.json')
        with open(dp,'w') as f: json.dump(dash,f,indent=2)
        logging.info(f"[{timestamp()}] [INFO] Dashboard JSON: {dp}")

        try:
            subprocess.Popen(['grafana-server','--homepath',folder], shell=False)
            logging.info(f"[{timestamp()}] [INFO] Grafana started")
        except Exception:
            print(f"[{timestamp()}] [INFO] Start grafana-server manually in {folder}")

        print(f"[{timestamp()}] [END] IQ-FINANCE-grafana completed")
        return True

    if user_input.startswith("SIMON-IQ "):
        import nibabel as nib
        from monai.transforms import (
            Compose, LoadImaged, EnsureChannelFirstd, ScaleIntensityd,
            Orientationd, Spacingd, ResizeWithPadOrCropd, ToTensord
        )
        from monai.networks.nets import UNet, SwinUNETR, SegResNet
        from monai.inferers import sliding_window_inference
        from monai.data import DataLoader, Dataset

        # --- Command Parsing ---
        from argparse import ArgumentParser

        # Rebuild args from input string
        try:
            cmd_args = shlex.split(user_input.replace("SIMON-IQ", ""))
        except Exception as e:
            print(f"[PARSE ERROR] Could not parse command: {e}")
            sys.exit(1)

        parser = ArgumentParser(description="SIMON-IQ MONAI Segmentation Pipeline")
        parser.add_argument("--model", type=str, required=True, help="Model name: unet, swinunetr, segresnet")
        parser.add_argument("--image", type=str, required=True, help="Path to NIfTI image")
        parser.add_argument("--output", type=str, default="SIMON-IQ_OUTPUT_SEG.nii.gz", help="Output file path")
        parser.add_argument("--roi", type=int, nargs=3, default=[96, 96, 96], help="ROI size (x y z)")
        parser.add_argument("--spacing", type=float, nargs=3, default=[1.5, 1.5, 2.0], help="Target spacing")
        parser.add_argument("--device", type=str, default="cuda" if torch.cuda.is_available() else "cpu", help="Device: cuda or cpu")

        try:
            args = parser.parse_args(cmd_args)
        except SystemExit:
            print("[ERROR] Invalid SIMON-IQ command. Use --model, --image, etc.")
            sys.exit(1)

        # --- Model Setup ---
        model_name = args.model.lower()
        image_path = args.image
        output_path = args.output
        roi_size = tuple(args.roi)
        spacing = tuple(args.spacing)
        device = torch.device(args.device)

        models = {
            "unet": UNet(
                spatial_dims=3,
                in_channels=1,
                out_channels=2,
                channels=(16, 32, 64, 128, 256),
                strides=(2, 2, 2, 2),
            ),
            "swinunetr": SwinUNETR(
                img_size=roi_size,
                in_channels=1,
                out_channels=2,
                feature_size=48,
                use_checkpoint=False,
            ),
            "segresnet": SegResNet(
                spatial_dims=3,
                in_channels=1,
                out_channels=2,
                init_filters=16,
            ),
        }

        if model_name not in models:
            print(f"[ERROR] Unsupported model '{model_name}'. Choose from: {list(models.keys())}")
            sys.exit(1)
        if not os.path.isfile(image_path):
            print(f"[ERROR] Image not found: {image_path}")
            sys.exit(1)

        model = models[model_name].to(device)
        model.eval()

        # --- Data & Transforms ---
        transforms = Compose([
            LoadImaged(keys=["image"]),
            EnsureChannelFirstd(keys=["image"]),
            ScaleIntensityd(keys=["image"]),
            Orientationd(keys=["image"], axcodes="RAS"),
            Spacingd(keys=["image"], pixdim=spacing, mode="bilinear"),
            ResizeWithPadOrCropd(keys=["image"], spatial_size=roi_size),
            ToTensord(keys=["image"]),
        ])
        dataset = Dataset(data=[{"image": image_path}], transform=transforms)
        loader = DataLoader(dataset, batch_size=1)

        # --- Inference ---
        with torch.no_grad():
            for data in loader:
                input_image = data["image"].to(device)
                output = sliding_window_inference(input_image, roi_size=roi_size, sw_batch_size=1, predictor=model)
                prediction = torch.argmax(output, dim=1).cpu().numpy()[0]

        # --- Save Output ---
        original_affine = nib.load(image_path).affine
        nib.save(nib.Nifti1Image(prediction.astype("uint8"), affine=original_affine), output_path)
        print(f"[SUCCESS] Segmentation complete. Output saved to: {output_path}")

    if user_input.startswith("SIMONLABEL-IQ "):
        from argparse import ArgumentParser
        from monailabel.client.client import MONAILabelClient
        from monailabel.datastore.local import LocalDatastore
        import torch

        # --- Parse command ---
        try:
            cmd = shlex.split(user_input.replace("SIMONLABEL-IQ", ""))
        except Exception as e:
            print(f"[PARSE ERROR] {e}"); sys.exit(1)

        parser = ArgumentParser(description="SIMONLABEL-IQ CLI for MONAI Label (Python client)")
        parser.add_argument("--server", required=True, help="MONAILabel server URL (e.g. http://127.0.0.1:8000)")
        parser.add_argument("--task", default="segmentation", help="Task name: segmentation, deepedit, deepgrow, next_sample, scoring, train, batch_infer")
        parser.add_argument("--image", help="Single image file path or image ID")
        parser.add_argument("--images", nargs="*", help="Multiple image file paths for batch operations")
        parser.add_argument("--model", help="Model name (optional if default)")
        parser.add_argument("--strategy", help="Strategy name for next_sample task")
        parser.add_argument("--method", help="Method name for scoring task")
        parser.add_argument("--train_epochs", type=int, help="Max epochs for train task")
        parser.add_argument("--params", nargs="*", help="Extra key=value parameters for inference/train")
        parser.add_argument("--upload", action="store_true", help="Upload image(s) to datastore before infer")
        parser.add_argument("--download_label", action="store_true", help="Download predicted label to local file")
        parser.add_argument("--download_image", action="store_true", help="Download processed image from server")
        parser.add_argument("--output", default="simonlabel_output.nii.gz", help="Local filename for downloaded label")
        parser.add_argument("--info", action="store_true", help="Fetch server info (models/tasks)")
        args = parser.parse_args(cmd)

        client = MONAILabelClient(args.server)

        if args.info:
            info = client.info()
            print("[SERVER INFO]", json.dumps(info, indent=2))
            sys.exit(0)

        def parse_params(arr):
            return dict(p.split("=",1) for p in arr if "=" in p) if arr else {}

        params = parse_params(args.params)

        image_ids = []
        # upload files if requested
        if args.upload and args.images:
            for fp in args.images:
                resp = client.upload_image(fp)
                iid = resp.get("id") or os.path.basename(fp)
                print(f"[UPLOADED] {fp} -> ID: {iid}")
                image_ids.append(iid)
        elif args.upload and args.image:
            resp = client.upload_image(args.image)
            iid = resp.get("id") or os.path.basename(args.image)
            print(f"[UPLOADED] {args.image} -> ID: {iid}")
            image_ids = [iid]
        else:
            if args.images:
                image_ids = args.images
            elif args.image:
                image_ids = [args.image]
            else:
                print("[ERROR] No image or images provided"); sys.exit(1)

        result = None

        # Choose and execute task
        if args.task == "batch_infer":
            result = client.datastore().batch_infer(task=args.task, images=image_ids, model=args.model, params=params)
        elif args.task == "next_sample":
            result = client.next_sample(args.strategy, params)
        elif args.task == "scoring":
            result = client.scoring(method=args.method, params=params)
        elif args.task == "train":
            train_params = {"train_epochs": args.train_epochs, **params}
            result = client.train_start(args.model, train_params)
        else:
            # default: single-image inference
            result_file, result_body = client.infer(model=args.model, image_id=image_ids[0], params=params)
            result = result_body
            print(f"[INFER] Label file saved temporary: {result_file}")

        print(f"[RESULT] Task={args.task} completed:\n{json.dumps(result, indent=2)}")

        if args.download_label and result.get("label"):
            label_id = result["label"]
            client.datastore().download_label(label_id, tag=result.get("tag",""))
            print(f"[DOWNLOADED] Label for ID {label_id}")

        if args.download_image and result.get("image"):
            img_id = result["image"]
            # requires client logic or REST to download
            print(f"[NOTE] To download processed image ID: {img_id}")

    if user_input.startswith("SIMONDEPLOY-IQ "):
        # MONAI Deploy App SDK imports
        from monai.deploy.core import Application
        from monai.deploy.core import Operator, InputContext, OutputContext, ExecutionContext
        from monai.deploy.core import DataPath, IOType, OperatorSpec
        from monai.deploy.conditions import CountCondition
        from monai.deploy.core.models import ModelFactory, TorchScriptModel, TritonModel

        # --- Parse CLI command from input ---
        try:
            cmd_args = shlex.split(user_input.replace("SIMONDEPLOY-IQ", ""))
        except Exception as e:
            print(f"[PARSE ERROR] {e}"); sys.exit(1)

        parser = argparse.ArgumentParser(description="SIMONDEPLOY‑IQ CLI for MONAI Deploy")
        parser.add_argument("--mode", choices=["develop","package","run"], required=True, help="Mode: develop (local debug), package to MAP, or run a packaged app")
        parser.add_argument("--app_dir", type=str, help="Path to application folder (develop or package)")
        parser.add_argument("--app_yaml", type=str, help="Path to app.yaml configuration file")
        parser.add_argument("--input", nargs="+", help="Input image/file paths, DICOM folder or NIfTI")
        parser.add_argument("--output", type=str, default="output", help="Output directory")
        parser.add_argument("--model_path", type=str, help="TorchScript or ONNX model path (for packaging)")
        parser.add_argument("--use_triton", action="store_true", help="Use Triton remote model server")
        parser.add_argument("--docker_tag", type=str, default="simondeploy_app:latest", help="Docker tag for MAP packaging")
        parser.add_argument("--roi", nargs=3, type=int, help="ROI size if needed")
        parser.add_argument("--spacing", nargs=3, type=float, help="Target spacing")
        args = parser.parse_args(cmd_args)

        # --- Mode: develop (local debug) ---
        if args.mode == "develop":
            # assume app_dir contains an app.py with Application subclass
            sys.path.insert(0, args.app_dir)
            from app import App  # your custom Application
            print("[DEVELOP] Running application in local debug mode")
            App(do_run=True).run()

        # --- Mode: package (create MAP docker using monai‑deploy CLI) ---
        elif args.mode == "package":
            print("[PACKAGE] Packaging application into MAP")
            cmd = [
                "monai-deploy", "package", args.app_dir,
                "-c", args.app_yaml,
                "-t", args.docker_tag
            ]
            if args.model_path:
                cmd += ["--model", args.model_path]
            subprocess.run(cmd, check=True)
            print(f"[PACKAGE] Created MAP image: {args.docker_tag}")

        # --- Mode: run MAP (docker image) ---
        elif args.mode == "run":
            print("[RUN] Executing packaged MAP")
            cmd = [
                "monai-deploy", "run", args.docker_tag,
                "-i", *args.input,
                "-o", args.output
            ]
            subprocess.run(cmd, check=True)
            print(f"[RUN] Output available in directory: {args.output}")

        else:
            print("[ERROR] Invalid mode"); sys.exit(1)

    if user_input.startswith("pa "):
        user_input = user_input[3:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-qwen3:0.6b "):
        user_input = user_input[14:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_qwen0_6(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-qwen3:1.7b "):
        user_input = user_input[14:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_qwen1_7(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-qwen3:4b "):
        user_input = user_input[12:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_qwen4(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-qwen3:8b "):
        user_input = user_input[12:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_qwen8(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-qwen3:14b "):
        user_input = user_input[13:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-qwen3:32b "):
        user_input = user_input[13:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_qwen32(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-qwen3:30b "):
        user_input = user_input[13:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_qwen30(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-qwen3:235b "):
        user_input = user_input[14:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_qwen235(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-llama4:scout "):
        user_input = user_input[16:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_llama4_scout(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-llama4:maverick "):
        user_input = user_input[19:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_llama4_maverick(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-deepseek-r1:1.5b "):
        user_input = user_input[19:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_deepseek_r1_1_5(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-deepseek-r1:7b "):
        user_input = user_input[19:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_deepseek_r1_7(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-deepseek-r1:8b "):
        user_input = user_input[19:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_deepseek_r1_8(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-deepseek-r1:14b "):
        user_input = user_input[19:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_deepseek_r1_14(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-deepseek-r1:32b "):
        user_input = user_input[19:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_deepseek_r1_32(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-deepseek-r1:70b "):
        user_input = user_input[19:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_deepseek_r1_70(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-deepseek-r1:671b "):
        user_input = user_input[19:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_deepseek_r1_671(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-gemma3:1b "):
        user_input = user_input[19:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_gemma3_1(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-gemma3:4b "):
        user_input = user_input[19:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_gemma3_4(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-gemma3:12b "):
        user_input = user_input[19:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_gemma3_12(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-gemma3:27b "):
        user_input = user_input[19:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_gemma3_27(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    if user_input.startswith("pa-devstral "):
        user_input = user_input[19:].strip()
        ollama_installed = check_command_installed("ollama")
        if ollama_installed:
            print(f"[{timestamp()}] [INFO] Ollama is installed.")
        else:
            print(f"[{timestamp()}] [ERROR] Ollama is not installed. Please install it to proceed.")

        start_ollama()
        check_ollama_update()

        response = get_response_from_ollama_devstral(user_input, ollama)

        print(f"{main_color}🤖 AI says{reset}:", end=" ")
        type_out_text(response)

        return True

    return False


# Konstanten
SETTINGS_PATH_THEME = os.path.expandvars(
    r"%LOCALAPPDATA%\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json"
)

IMAGE_DEST_DIR = os.path.expanduser(r'~\AppData\Local\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\images')
BACKUP_SUFFIX = ".bak"
THEMES_PATH = f'C:\\Users\\{os.getlogin()}\\p-terminal\\pp-term\\themes.json'

# C:\Users\julian\AppData\Local\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\RoamingState für Bilder

# Vordefinierte Farbschemata
COLOR_SCHEMES = {
    "dark": {
        "name": "Dark",
        "background": "#0F0F1A",
        "foreground": "#ffffff",
        "black": "#1B1B2F",
        "red": "#E10600",
        "green": "#00FF9F",
        "yellow": "#FFD000",
        "blue": "#1E90FF",
        "purple": "#A200FF",
        "cyan": "#00CFFF",
        "white": "#FFFFFF",
        "brightBlack": "#2C2C3A",
        "brightRed": "#FF2C1F",
        "brightGreen": "#4CFFB0",
        "brightYellow": "#FFE94D",
        "brightBlue": "#1fb1ff",
        "brightPurple": "#E87CFF",
        "brightCyan": "#4DE9FF",
        "brightWhite": "#FAFAFA",
        "cursorColor": "#E10600",
        "selectionBackground": "#0047AB",
    },
    "light": {
        "name": "Light",
        "background": "#FFFFFF",
        "foreground": "#000000",
        "black": "#FFFFFF",
        "red": "#C50F1F",
        "green": "#13A10E",
        "yellow": "#C19C00",
        "blue": "#0037DA",
        "purple": "#881798",
        "cyan": "#3A96DD",
        "white": "#000000",
        "brightBlack": "#0047AB",
        "brightRed": "#E74856",
        "brightGreen": "#16C60C",
        "brightYellow": "#F9F1A5",
        "brightBlue": "#3B78FF",
        "brightPurple": "#B4009E",
        "brightCyan": "#61D6D6",
        "brightWhite": "#FAFAFA",
        "cursorColor": "#E10600",
        "selectionBackground": "#2C2C3A",
    },
    "main": {
        "name": "Dark",
        "background": "#333333",
        "foreground": "#ffffff",
        "black": "#1B1B2F",
        "red": "#E10600",
        "green": "#00FF9F",
        "yellow": "#FFD000",
        "blue": "#1E90FF",
        "purple": "#A200FF",
        "cyan": "#00CFFF",
        "white": "#FFFFFF",
        "brightBlack": "#2C2C3A",
        "brightRed": "#FF2C1F",
        "brightGreen": "#4CFFB0",
        "brightYellow": "#FFE94D",
        "brightBlue": "#1fb1ff",
        "brightPurple": "#E87CFF",
        "brightCyan": "#4DE9FF",
        "brightWhite": "#FAFAFA",
        "cursorColor": "#E10600",
        "selectionBackground": "#0047AB",
    },
    "hackerman": {
        "name": "hackerman",
        "background": "#2E3440",
        "black": "#3B4252",
        "blue": "#81A1C1",
        "brightBlack": "#4C566A",
        "brightBlue": "#81A1C1",
        "brightCyan": "#88C0D0",
        "brightGreen": "#A3BE8C",
        "brightPurple": "#B48EAD",
        "brightRed": "#BF616A",
        "brightWhite": "#E5E9F0",
        "brightYellow": "#EBCB8B",
        "cursorColor": "#FFFFFF",
        "cyan": "#88C0D0",
        "foreground": "#D8DEE9",
        "green": "#A3BE8C",
        "purple": "#B48EAD",
        "red": "#BF616A",
        "selectionBackground": "#FFFFFF",
        "white": "#E5E9F0",
        "yellow": "#EBCB8B"
    },
    "glass": {
        "name": "glass",
        "background": "#333333",
        "foreground": "#ffffff",
        "black": "#1B1B2F",
        "red": "#E10600",
        "green": "#00FF9F",
        "yellow": "#FFD000",
        "blue": "#1E90FF",
        "purple": "#A200FF",
        "cyan": "#00CFFF",
        "white": "#FFFFFF",
        "brightBlack": "#2C2C3A",
        "brightRed": "#FF2C1F",
        "brightGreen": "#4CFFB0",
        "brightYellow": "#FFE94D",
        "brightBlue": "#1fb1ff",
        "brightPurple": "#E87CFF",
        "brightCyan": "#4DE9FF",
        "brightWhite": "#FAFAFA",
        "cursorColor": "#E10600",
        "selectionBackground": "#0047AB",
    },
    "glassmain": {
        "name": "glassmain",
        "background": "#333333",
        "foreground": "#ffffff",
        "black": "#1B1B2F",
        "red": "#E10600",
        "green": "#00FF9F",
        "yellow": "#FFD000",
        "blue": "#1E90FF",
        "purple": "#A200FF",
        "cyan": "#00CFFF",
        "white": "#FFFFFF",
        "brightBlack": "#2C2C3A",
        "brightRed": "#FF2C1F",
        "brightGreen": "#4CFFB0",
        "brightYellow": "#FFE94D",
        "brightBlue": "#1fb1ff",
        "brightPurple": "#E87CFF",
        "brightCyan": "#4DE9FF",
        "brightWhite": "#FAFAFA",
        "cursorColor": "#E10600",
        "selectionBackground": "#0047AB",
    },
    "aptscience": {
        "name": "aptscience",
        "background": "#0C0C0C",
        "foreground": "#F2F2F2",
        "black": "#0C0C0C",
        "red": "#C50F1F",
        "green": "#13A10E",
        "yellow": "#C19C00",
        "blue": "#0037DA",
        "purple": "#881798",
        "cyan": "#3A96DD",
        "white": "#CCCCCC",
        "brightBlack": "#767676",
        "brightRed": "#E74856",
        "brightGreen": "#16C60C",
        "brightYellow": "#F9F1A5",
        "brightBlue": "#3B78FF",
        "brightPurple": "#B4009E",
        "brightCyan": "#61D6D6",
        "brightWhite": "#F2F2F2"
    },
    "cyberlife": {
        "name": "Cyberlife",
        "background": "#0C0C0C",
        "foreground": "#F2F2F2",
        "black": "#0C0C0C",
        "red": "#C50F1F",
        "green": "#13A10E",
        "yellow": "#C19C00",
        "blue": "#0037DA",
        "purple": "#881798",
        "cyan": "#3A96DD",
        "white": "#CCCCCC",
        "brightBlack": "#767676",
        "brightRed": "#E74856",
        "brightGreen": "#16C60C",
        "brightYellow": "#F9F1A5",
        "brightBlue": "#3B78FF",
        "brightPurple": "#B4009E",
        "brightCyan": "#61D6D6",
        "brightWhite": "#F2F2F2"
    },
    "ubuntu": {
        "name": "Ubuntu",
        "background": "#300A24",
        "foreground": "#F2F2F2",
        "black": "#300A24",
        "red": "#CE5C00",
        "green": "#8ABEB7",
        "yellow": "#F0C674",
        "blue": "#81A2BE",
        "purple": "#B294BB",
        "cyan": "#8ABEB7",
        "white": "#EEEEEC",
        "brightBlack": "#1E161B",
        "brightRed": "#FF6E67",
        "brightGreen": "#5FEBA6",
        "brightYellow": "#F4BF75",
        "brightBlue": "#8AB8FE",
        "brightPurple": "#D7A0FF",
        "brightCyan": "#BDF5F2",
        "brightWhite": "#FFFFFF",
        "cursorColor": "#000000"
    },
    "ubuntuglass": {
        "name": "ubuntuglass",
        "background": "#300A24",
        "foreground": "#F2F2F2",
        "black": "#300A24",
        "red": "#CE5C00",
        "green": "#8ABEB7",
        "yellow": "#F0C674",
        "blue": "#81A2BE",
        "purple": "#B294BB",
        "cyan": "#8ABEB7",
        "white": "#EEEEEC",
        "brightBlack": "#1E161B",
        "brightRed": "#FF6E67",
        "brightGreen": "#5FEBA6",
        "brightYellow": "#F4BF75",
        "brightBlue": "#8AB8FE",
        "brightPurple": "#D7A0FF",
        "brightCyan": "#BDF5F2",
        "brightWhite": "#FFFFFF",
        "cursorColor": "#000000"
    },
    "violetglass": {
        "name": "violetglass",
        "background": "#300A24",
        "foreground": "#ffffff",
        "black": "#1B1B2F",
        "red": "#E10600",
        "green": "#00FF9F",
        "yellow": "#FFD000",
        "blue": "#1E90FF",
        "purple": "#A200FF",
        "cyan": "#00CFFF",
        "white": "#FFFFFF",
        "brightBlack": "#2C2C3A",
        "brightRed": "#FF2C1F",
        "brightGreen": "#4CFFB0",
        "brightYellow": "#FFE94D",
        "brightBlue": "#1fb1ff",
        "brightPurple": "#E87CFF",
        "brightCyan": "#4DE9FF",
        "brightWhite": "#FAFAFA",
        "cursorColor": "#E10600",
        "selectionBackground": "#0047AB",
    },
    "yellowglass": {
        "name": "yellowglass",
        "background": "#FFD54F",
        "foreground": "#ffffff",
        "black": "#1B1B2F",
        "red": "#E10600",
        "green": "#00FF9F",
        "yellow": "#FFD000",
        "blue": "#1E90FF",
        "purple": "#A200FF",
        "cyan": "#00CFFF",
        "white": "#FFFFFF",
        "brightBlack": "#2C2C3A",
        "brightRed": "#FF2C1F",
        "brightGreen": "#4CFFB0",
        "brightYellow": "#FFE94D",
        "brightBlue": "#1fb1ff",
        "brightPurple": "#E87CFF",
        "brightCyan": "#4DE9FF",
        "brightWhite": "#FAFAFA",
        "cursorColor": "#E10600",
        "selectionBackground": "#0047AB",
    },
    "blueglass": {
        "name": "blueglass",
        "background": "#003366",
        "foreground": "#ffffff",
        "black": "#1B1B2F",
        "red": "#E10600",
        "green": "#00FF9F",
        "yellow": "#FFD000",
        "blue": "#1E90FF",
        "purple": "#A200FF",
        "cyan": "#00CFFF",
        "white": "#FFFFFF",
        "brightBlack": "#2C2C3A",
        "brightRed": "#FF2C1F",
        "brightGreen": "#4CFFB0",
        "brightYellow": "#FFE94D",
        "brightBlue": "#1fb1ff",
        "brightPurple": "#E87CFF",
        "brightCyan": "#4DE9FF",
        "brightWhite": "#FAFAFA",
        "cursorColor": "#E10600",
        "selectionBackground": "#0047AB",
    },
    "greenglass": {
        "name": "greenglass",
        "background": "#004d26",
        "foreground": "#ffffff",
        "black": "#1B1B2F",
        "red": "#E10600",
        "green": "#00FF9F",
        "yellow": "#FFD000",
        "blue": "#1E90FF",
        "purple": "#A200FF",
        "cyan": "#00CFFF",
        "white": "#FFFFFF",
        "brightBlack": "#2C2C3A",
        "brightRed": "#FF2C1F",
        "brightGreen": "#4CFFB0",
        "brightYellow": "#FFE94D",
        "brightBlue": "#1fb1ff",
        "brightPurple": "#E87CFF",
        "brightCyan": "#4DE9FF",
        "brightWhite": "#FAFAFA",
        "cursorColor": "#E10600",
        "selectionBackground": "#0047AB",
    },
    "redglass": {
        "name": "redglass",
        "background": "#660000",
        "foreground": "#ffffff",
        "black": "#1B1B2F",
        "red": "#E10600",
        "green": "#00FF9F",
        "yellow": "#FFD000",
        "blue": "#1E90FF",
        "purple": "#A200FF",
        "cyan": "#00CFFF",
        "white": "#FFFFFF",
        "brightBlack": "#2C2C3A",
        "brightRed": "#FF2C1F",
        "brightGreen": "#4CFFB0",
        "brightYellow": "#FFE94D",
        "brightBlue": "#1fb1ff",
        "brightPurple": "#E87CFF",
        "brightCyan": "#4DE9FF",
        "brightWhite": "#FAFAFA",
        "cursorColor": "#E10600",
        "selectionBackground": "#0047AB",
    },
    "mint": {
        "name": "mint",
        "background": "#202020",
        "foreground": "#DADADA",
        "black": "#1D1F21",
        "red": "#CC6666",
        "green": "#B5BD68",
        "yellow": "#F0C674",
        "blue": "#81A2BE",
        "purple": "#B294BB",
        "cyan": "#8ABEB7",
        "white": "#C5C8C6",
        "brightBlack": "#666666",
        "brightRed": "#FF6C6B",
        "brightGreen": "#C8E688",
        "brightYellow": "#FFD700",
        "brightBlue": "#9FC6FF",
        "brightPurple": "#E6A8FF",
        "brightCyan": "#A1EFE4",
        "brightWhite": "#FFFFFF",
        "cursorColor": "#A3E97B"
    },
    "nord": {
        "name": "nord",
        "foreground": "#ffffff",
        "background": "#333333",
        "black": "#1B1B2F",
        "red": "#E10600",
        "green": "#00FF9F",
        "yellow": "#FFD000",
        "blue": "#1E90FF",
        "purple": "#A200FF",
        "cyan": "#00CFFF",
        "white": "#FFFFFF",
        "brightBlack": "#2C2C3A",
        "brightRed": "#FF2C1F",
        "brightGreen": "#4CFFB0",
        "brightYellow": "#FFE94D",
        "brightBlue": "#1fb1ff",
        "brightPurple": "#E87CFF",
        "brightCyan": "#4DE9FF",
        "brightWhite": "#FAFAFA",
        "cursorColor": "#E10600",
    },
    "dracula": {
        "name": "Dracula",
        "background": "#282A36",
        "foreground": "#F8F8F2",
        "black": "#21222C",
        "red": "#FF5555",
        "green": "#50FA7B",
        "yellow": "#F1FA8C",
        "blue": "#BD93F9",
        "purple": "#FF79C6",
        "cyan": "#8BE9FD",
        "white": "#F8F8F2",
        "brightBlack": "#6272A4",
        "brightRed": "#FF6E6E",
        "brightGreen": "#69FF94",
        "brightYellow": "#FFFFA5",
        "brightBlue": "#D6ACFF",
        "brightPurple": "#FF92DF",
        "brightCyan": "#A4FFFF",
        "brightWhite": "#FFFFFF",
        "cursorColor": "#FF79C6"
    },
    "solarized_dark": {
        "name": "Solarized Dark",
        "background": "#002B36",
        "foreground": "#839496",
        "black": "#073642",
        "red": "#DC322F",
        "green": "#859900",
        "yellow": "#B58900",
        "blue": "#268BD2",
        "purple": "#D33682",
        "cyan": "#2AA198",
        "white": "#EEE8D5",
        "brightBlack": "#002B36",
        "brightRed": "#CB4B16",
        "brightGreen": "#586E75",
        "brightYellow": "#657B83",
        "brightBlue": "#839496",
        "brightPurple": "#6C71C4",
        "brightCyan": "#93A1A1",
        "brightWhite": "#FDF6E3",
        "cursorColor": "#93A1A1"
    },
    "gruvbox_dark": {
        "name": "Gruvbox Dark",
        "background": "#282828",
        "foreground": "#EBDBB2",
        "black": "#282828",
        "red": "#CC241D",
        "green": "#98971A",
        "yellow": "#D79921",
        "blue": "#458588",
        "purple": "#B16286",
        "cyan": "#689D6A",
        "white": "#A89984",
        "brightBlack": "#928374",
        "brightRed": "#FB4934",
        "brightGreen": "#B8BB26",
        "brightYellow": "#FABD2F",
        "brightBlue": "#83A598",
        "brightPurple": "#D3869B",
        "brightCyan": "#8EC07C",
        "brightWhite": "#EBDBB2",
        "cursorColor": "#FE8019"
    },
    "monokai": {
        "name": "Monokai",
        "background": "#272822",
        "foreground": "#F8F8F2",
        "black": "#272822",
        "red": "#F92672",
        "green": "#A6E22E",
        "yellow": "#F4BF75",
        "blue": "#66D9EF",
        "purple": "#AE81FF",
        "cyan": "#A1EFE4",
        "white": "#F8F8F2",
        "brightBlack": "#75715E",
        "brightRed": "#FD971F",
        "brightGreen": "#A6E22E",
        "brightYellow": "#E6DB74",
        "brightBlue": "#66D9EF",
        "brightPurple": "#AE81FF",
        "brightCyan": "#38CCD1",
        "brightWhite": "#F9F8F5",
        "cursorColor": "#F8F8F0"
    },
    "one_dark": {
        "name": "One Dark",
        "background": "#282C34",
        "foreground": "#ABB2BF",
        "black": "#282C34",
        "red": "#E06C75",
        "green": "#98C379",
        "yellow": "#E5C07B",
        "blue": "#61AFEF",
        "purple": "#C678DD",
        "cyan": "#56B6C2",
        "white": "#ABB2BF",
        "brightBlack": "#5C6370",
        "brightRed": "#E06C75",
        "brightGreen": "#98C379",
        "brightYellow": "#D19A66",
        "brightBlue": "#61AFEF",
        "brightPurple": "#C678DD",
        "brightCyan": "#56B6C2",
        "brightWhite": "#FFFFFF",
        "cursorColor": "#528BFF"
    },
    "material_dark": {
        "name": "Material Dark",
        "background": "#263238",
        "foreground": "#ECEFF1",
        "black": "#263238",
        "red": "#FF5370",
        "green": "#C3E88D",
        "yellow": "#FFCB6B",
        "blue": "#82AAFF",
        "purple": "#C792EA",
        "cyan": "#89DDFF",
        "white": "#ECEFF1",
        "brightBlack": "#546E7A",
        "brightRed": "#FF5370",
        "brightGreen": "#C3E88D",
        "brightYellow": "#FFCB6B",
        "brightBlue": "#82AAFF",
        "brightPurple": "#C792EA",
        "brightCyan": "#89DDFF",
        "brightWhite": "#FFFFFF",
        "cursorColor": "#FFCB6B"
    },
    "tokyo_night": {
        "name": "Tokyo Night",
        "background": "#1A1B26",
        "foreground": "#C0CAF5",
        "black": "#1D202F",
        "red": "#F7768E",
        "green": "#9ECE6A",
        "yellow": "#E0AF68",
        "blue": "#7AA2F7",
        "purple": "#BB9AF7",
        "cyan": "#7DCFFF",
        "white": "#A9B1D6",
        "brightBlack": "#414868",
        "brightRed": "#F7768E",
        "brightGreen": "#9ECE6A",
        "brightYellow": "#E0AF68",
        "brightBlue": "#7AA2F7",
        "brightPurple": "#BB9AF7",
        "brightCyan": "#7DCFFF",
        "brightWhite": "#C0CAF5",
        "cursorColor": "#7AA2F7"
    },
    "arc_dark": {
        "name": "Arc Dark",
        "background": "#212733",
        "foreground": "#D3DAE3",
        "black": "#212733",
        "red": "#E27878",
        "green": "#B4BE82",
        "yellow": "#E2A478",
        "blue": "#82AAFF",
        "purple": "#C792EA",
        "cyan": "#89DDFF",
        "white": "#D3DAE3",
        "brightBlack": "#4C566A",
        "brightRed": "#FF5370",
        "brightGreen": "#C3E88D",
        "brightYellow": "#FFCB6B",
        "brightBlue": "#82AAFF",
        "brightPurple": "#C792EA",
        "brightCyan": "#89DDFF",
        "brightWhite": "#ECEFF4",
        "cursorColor": "#82AAFF"
    },
    "ayu_mirage": {
        "name": "Ayu Mirage",
        "background": "#1F2430",
        "foreground": "#CBCCC6",
        "black": "#191E2A",
        "red": "#FF3333",
        "green": "#BAE67E",
        "yellow": "#FFA759",
        "blue": "#73D0FF",
        "purple": "#D4BFFF",
        "cyan": "#95E6CB",
        "white": "#C7C7C7",
        "brightBlack": "#686868",
        "brightRed": "#FF5454",
        "brightGreen": "#C2E68C",
        "brightYellow": "#FFB378",
        "brightBlue": "#80D6FF",
        "brightPurple": "#E1CFFF",
        "brightCyan": "#B4F0E0",
        "brightWhite": "#FFFFFF",
        "cursorColor": "#FFA759"
    },
    "spiderman": {
        "name": "spiderman",
        "background": "#0F0F1A",
        "black": "#1B1B2F",
        "red": "#E10600",
        "green": "#00FF9F",
        "yellow": "#FFD000",
        "blue": "#1E90FF",
        "purple": "#A200FF",
        "cyan": "#00CFFF",
        "white": "#FFFFFF",
        "brightBlack": "#2C2C3A",
        "brightRed": "#FF2C1F",
        "brightGreen": "#4CFFB0",
        "brightYellow": "#FFE94D",
        "brightBlue": "#1fb1ff",
        "brightPurple": "#E87CFF",
        "brightCyan": "#4DE9FF",
        "brightWhite": "#FAFAFA",
        "selectionBackground": "#0047AB",
        "foreground": "#FFFFFF"
    },
    "p_term": {
        "name": "p_term",
        "background": "#0F0F1A",
        "black": "#1B1B2F",
        "red": "#E10600",
        "green": "#00FF9F",
        "yellow": "#FFD000",
        "blue": "#1E90FF",
        "purple": "#A200FF",
        "cyan": "#00CFFF",
        "white": "#FFFFFF",
        "brightBlack": "#2C2C3A",
        "brightRed": "#FF2C1F",
        "brightGreen": "#4CFFB0",
        "brightYellow": "#FFE94D",
        "brightBlue": "#1fb1ff",
        "brightPurple": "#E87CFF",
        "brightCyan": "#4DE9FF",
        "brightWhite": "#FAFAFA",
        "foreground": "#FFFFFF"
    },
    "mavis_1": {
        "name": "mavis_1",
        "background": "#0F0F1A",
        "black": "#1B1B2F",
        "red": "#E10600",
        "green": "#00FF9F",
        "yellow": "#FFD000",
        "blue": "#1E90FF",
        "purple": "#A200FF",
        "cyan": "#00CFFF",
        "white": "#FFFFFF",
        "brightBlack": "#2C2C3A",
        "brightRed": "#FF2C1F",
        "brightGreen": "#4CFFB0",
        "brightYellow": "#FFE94D",
        "brightBlue": "#1fb1ff",
        "brightPurple": "#E87CFF",
        "brightCyan": "#4DE9FF",
        "brightWhite": "#FAFAFA",
        "foreground": "#FFFFFF"
    },
    "mavis_3": {
        "name": "mavis_3",
        "background": "#0F0F1A",
        "black": "#1B1B2F",
        "red": "#E10600",
        "green": "#00FF9F",
        "yellow": "#FFD000",
        "blue": "#1E90FF",
        "purple": "#A200FF",
        "cyan": "#00CFFF",
        "white": "#FFFFFF",
        "brightBlack": "#2C2C3A",
        "brightRed": "#FF2C1F",
        "brightGreen": "#4CFFB0",
        "brightYellow": "#FFE94D",
        "brightBlue": "#1fb1ff",
        "brightPurple": "#E87CFF",
        "brightCyan": "#4DE9FF",
        "brightWhite": "#FAFAFA",
        "foreground": "#FFFFFF"
    },
    "mavis_4": {
        "name": "mavis_4",
        "background": "#0F0F1A",
        "black": "#1B1B2F",
        "red": "#E10600",
        "green": "#00FF9F",
        "yellow": "#FFD000",
        "blue": "#1E90FF",
        "purple": "#A200FF",
        "cyan": "#00CFFF",
        "white": "#FFFFFF",
        "brightBlack": "#2C2C3A",
        "brightRed": "#FF2C1F",
        "brightGreen": "#4CFFB0",
        "brightYellow": "#FFE94D",
        "brightBlue": "#1fb1ff",
        "brightPurple": "#E87CFF",
        "brightCyan": "#4DE9FF",
        "brightWhite": "#FAFAFA",
        "foreground": "#FFFFFF"
    },
    "green": {
        "name": "green",
        "background": "#000000",
        "foreground": "#00FF00",
        "black": "#00FF00",
        "red": "#00FF00",
        "green": "#00FF00",
        "yellow": "#00FF00",
        "blue": "#00FF00",
        "purple": "#00FF00",
        "cyan": "#00FF00",
        "white": "#00FF00",
        "brightBlack": "#00FF00",
        "brightRed": "#00FF00",
        "brightGreen": "#00FF00",
        "brightYellow": "#00FF00",
        "brightBlue": "#00FF00",
        "brightPurple": "#00FF00",
        "brightCyan": "#00FF00",
        "brightWhite": "#00FF00",
        "cursorColor": "#00FF00"
    },
    "red": {
        "name": "red",
        "background": "#000000",
        "foreground": "#FF0000",
        "black": "#FF0000",
        "red": "#FF0000",
        "green": "#FF0000",
        "yellow": "#FF0000",
        "blue": "#FF0000",
        "purple": "#FF0000",
        "cyan": "#FF0000",
        "white": "#FF0000",
        "brightBlack": "#FF0000",
        "brightRed": "#FF0000",
        "brightGreen": "#FF0000",
        "brightYellow": "#FF0000",
        "brightBlue": "#FF0000",
        "brightPurple": "#FF0000",
        "brightCyan": "#FF0000",
        "brightWhite": "#FF0000",
        "cursorColor": "#FF0000"
    },
    "blue": {
        "name": "blue",
        "background": "#000000",
        "foreground": "#00BFFF",
        "black": "#00BFFF",
        "red": "#00BFFF",
        "green": "#00BFFF",
        "yellow": "#00BFFF",
        "blue": "#00BFFF",
        "purple": "#00BFFF",
        "cyan": "#00BFFF",
        "white": "#00BFFF",
        "brightBlack": "#00BFFF",
        "brightRed": "#00BFFF",
        "brightGreen": "#00BFFF",
        "brightYellow": "#00BFFF",
        "brightBlue": "#00BFFF",
        "brightPurple": "#00BFFF",
        "brightCyan": "#00BFFF",
        "brightWhite": "#00BFFF",
        "cursorColor": "#00BFFF"
    },
    "fallout_pipboy": {
        "name": "Fallout PipBoy",
        "background": "#000000",
        "black": "#000000",
        "blue": "#2C83FF",
        "brightBlack": "#003300",
        "brightBlue": "#1D55A6",
        "brightCyan": "#4DFFB8",
        "brightGreen": "#32CD32",
        "brightPurple": "#20755E",
        "brightRed": "#5BFF00",
        "brightWhite": "#99FF99",
        "brightYellow": "#8F7C48",
        "cursorColor": "#00FF00",
        "cyan": "#009151",
        "foreground": "#4D9154",
        "green": "#09A600",
        "purple": "#701D43",
        "red": "#3B3A23",
        "selectionBackground": "#415441",
        "white": "#59FF59",
        "yellow": "#8F7500"
    },
    "aurelia": {
        "name": "aurelia",
        "background": "#1a1a1a",
        "black": "#000000",
        "blue": "#579BD5",
        "brightBlack": "#797979",
        "brightBlue": "#9CDCFE",
        "brightCyan": "#2BC4E2",
        "brightGreen": "#1AD69C",
        "brightPurple": "#975EAB",
        "brightRed": "#EB2A88",
        "brightWhite": "#EAEAEA",
        "brightYellow": "#e9ad95",
        "cyan": "#00B6D6",
        "foreground": "#EA549F",
        "green": "#4EC9B0",
        "purple": "#714896",
        "red": "#E92888",
        "white": "#EAEAEA",
        "yellow": "#CE9178"
    },
    "alternative": {
        "name": "alternative",
        "black": "#101116",
        "red": "#ff5680",
        "green": "#00ff9c",
        "yellow": "#fffc58",
        "blue": "#00b0ff",
        "purple": "#d57bff",
        "cyan": "#76c1ff",
        "white": "#c7c7c7",
        "brightBlack": "#686868",
        "brightRed": "#ff6e67",
        "brightGreen": "#5ffa68",
        "brightYellow": "#fffc67",
        "brightBlue": "#6871ff",
        "brightPurple": "#d682ec",
        "brightCyan": "#60fdff",
        "brightWhite": "#ffffff",
        "background": "#1d2342",
        "foreground": "#b8ffe1"
    }
}

# Laden themenspezifischer Standardeinstellungen
try:
    with open(THEMES_PATH, 'r', encoding='utf-8') as f:
        THEME_DEFAULTS = json.load(f)
except (FileNotFoundError, json.JSONDecodeError) as e:
    print(f"[{timestamp()}] [ERROR] Error loading themes.json: {e}")
    THEME_DEFAULTS = {}


def load_json_theme(path: str) -> dict:
    try:
        with open(path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return {}


def save_json_theme(path: str, data: dict) -> None:
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=4, ensure_ascii=False)
    print(f"[{timestamp()}] [INFO] JSON saved: {path}")


"""
def backup_file(path):
    if os.path.exists(path):
        bak = path + BACKUP_SUFFIX
        shutil.copy2(path, bak)
        print(f"[{timestamp()}] INFO: Backup created at {bak}")
"""

"""
def run_script_theme(*args):
    try:
        run(args, shell=True)
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error executing the script: {e}")
"""

def create_backup(file_theme_path: str) -> str:
    backup_path = file_theme_path + BACKUP_SUFFIX
    shutil.copy2(file_theme_path, backup_path)
    print(f"[{timestamp()}] [INFO] Backup created at: {backup_path}")
    return backup_path


def load_settings(file_theme_path: str) -> dict:
    with open(file_theme_path, 'r', encoding='utf-8') as f:
        return json.load(f)


def save_settings(file_theme_path: str, settings: dict) -> None:
    with open(file_theme_path, 'w', encoding='utf-8') as f:
        json.dump(settings, f, indent=4)
    print(f"[{timestamp()}] [INFO] Settings saved to {file_theme_path}")


def apply_color_scheme(settings: dict, scheme_name: str) -> None:
    scheme = COLOR_SCHEMES.get(scheme_name)
    if scheme:
        settings.setdefault('schemes', [])
        settings['schemes'] = [s for s in settings['schemes'] if s.get('name') != scheme.get('name')]
        settings['schemes'].append(scheme)
        for profile in settings.get('profiles', {}).get('list', []):
            profile['colorScheme'] = scheme.get('name')
        settings['theme'] = 'light' if 'light' in scheme_name else 'dark'
        print(f"[{timestamp()}] [INFO] Applied color scheme: {scheme.get('name')}")


def apply_theme_defaults(settings: dict, theme_name: str) -> None:
    defaults = THEME_DEFAULTS.get(theme_name, {}).get('defaults')
    if defaults:
        settings.setdefault('profiles', {})
        settings['profiles']['defaults'] = defaults
        print(f"[{timestamp()}] [INFO] Applied theme defaults for: {theme_name}")


def restart_terminal() -> None:
    subprocess.run(["wt.exe", "new-tab"], check=False)
    print(f"[{timestamp()}] [INFO] Terminal restarted with new tab.")


def move_image(src_path: str) -> str:
    if not os.path.isfile(src_path):
        raise FileNotFoundError(f"Image not found: {src_path}")
    os.makedirs(IMAGE_DEST_DIR, exist_ok=True)
    dest_path = os.path.join(IMAGE_DEST_DIR, os.path.basename(src_path))
    shutil.copy2(src_path, dest_path)
    print(f"[{timestamp()}] [INFO] Image copied to: {dest_path}")
    return dest_path


def prompt_colors(name: str) -> dict:
    keys = [
        'black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'white',
        'brightBlack', 'brightRed', 'brightGreen', 'brightYellow',
        'brightBlue', 'brightPurple', 'brightCyan', 'brightWhite',
        'background', 'foreground'
    ]

    print("Choose colors (Hex, e.g. #ff0000). Leave blank to skip a value.")
    theme = {"name": name}

    for key in keys:
        val = input(f"  {key}: ").strip()
        if val:
            theme[key] = val

    return theme

'''
def prompt_defaults():
    d = {}
    # Acrylic
    if input("Enable acrylic? [y/N]: ").strip().lower() == 'y':
        d['useAcrylic'] = True
        ao = input("  Acrylic opacity (0.0–1.0) [0.4]: ").strip()
        if ao: d['acrylicOpacity'] = float(ao)
    # Background image
    img = input("Background image path (jpg/png/heic), leave blank = none: ").strip()
    if img and os.path.isfile(img):
        os.makedirs(IMAGE_DEST_DIR, exist_ok=True)
        dest = os.path.join(IMAGE_DEST_DIR, os.path.basename(img))
        shutil.copy2(img, dest)
        d['backgroundImage'] = dest.replace('\\','/')
        d['backgroundImageStretchMode']    = input("  Stretch mode [uniformToFill]: ").strip() or "uniformToFill"
        d['backgroundImageAlignment']      = input("  Alignment [center]: ").strip() or "center"
        biop = input("  Image opacity (0.0–1.0) [0.8]: ").strip()
        if biop: d['backgroundImageOpacity'] = float(biop)
    # Cursor color
    cc = input("Cursor color hex [#ffffff]: ").strip() or "#ffffff"
    d['cursorColor'] = cc
    return d
'''


def create_custom_theme(name: str):
    code_line = f"Custom Theme: {name}"
    print("")
    print(code_line)
    print('-' * len(code_line))

    # 1) Prompt for colors
    theme_dict = prompt_colors(name)

    # 2) Prompt for background image path
    img_input = input("Path to background image (jpg/png/heic), leave empty = no image: ").strip()
    image_path = move_image(img_input) if img_input else None

    # 3) Load settings JSON and create a backup
    create_backup(SETTINGS_PATH_THEME)
    settings = load_json_theme(SETTINGS_PATH_THEME)

    # 4) Prepare schemes and remove old one if exists
    schemes = settings.setdefault('schemes', [])
    schemes = [s for s in schemes if s.get('name', '').lower() != name.lower()]

    # 5) Add new scheme
    new_scheme = theme_dict.copy()
    schemes.append(new_scheme)
    settings['schemes'] = schemes

    # 6) Apply to all profiles
    for profile in settings.get('profiles', {}).get('list', []):
        profile['colorScheme'] = name

    # 7) Update profile defaults
    defaults = settings.setdefault('profiles', {}).setdefault('defaults', {})
    defaults['colorScheme'] = name
    defaults.setdefault('cursorColor', "#FFFFFF")
    defaults.setdefault('opacity', 40)
    defaults.setdefault('useAcrylic', True)

    if image_path:
        defaults['backgroundImage'] = image_path
        defaults['backgroundImageAlignment'] = "bottomRight"
        defaults['backgroundImageOpacity'] = 0.8
        defaults['backgroundImageStretchMode'] = "none"

    # 8) Save updated settings
    save_json_theme(SETTINGS_PATH_THEME, settings)

    # 9) Restart terminal (optional)
    print(f"[{timestamp()}] [PASS] Custom theme '{name}' created.")
    subprocess.run(["wt.exe", "new-tab"], check=False)


def switch_theme(user_input: str) -> bool:
    if not user_input.lower().startswith("theme "):
        return False

    _, choice = user_input.split(maxsplit=1)
    key = choice.lower().replace('-', '_')

    if key not in COLOR_SCHEMES and key not in THEME_DEFAULTS:
        print(
            f"[{timestamp()}] [ERROR] Unknown theme '{choice}'. Available: {', '.join(sorted(set(COLOR_SCHEMES) | set(THEME_DEFAULTS)))}")
        return True

    try:
        create_backup(SETTINGS_PATH_THEME)
        settings = load_settings(SETTINGS_PATH_THEME)

        if key in COLOR_SCHEMES:
            apply_color_scheme(settings, key)

        if key in THEME_DEFAULTS:
            apply_theme_defaults(settings, key)

        save_settings(SETTINGS_PATH_THEME, settings)
        print(f"[{timestamp()}] [PASS] Theme '{choice}' applied successfully.")

        restart_terminal()

    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Failed to apply theme '{choice}': {e}")

    return True


def run_circuit(circuit: cirq.Circuit, repetitions: int = 1):
    """Helper to run a Cirq circuit and log the result."""
    logging.info(f"[INFO] Constructed circuit:\n{circuit}")
    sim = cirq.Simulator()
    try:
        result = sim.run(circuit, repetitions=repetitions)
        logging.info(f"[INFO] Simulation result: {result}")
    except Exception:
        logging.exception("[ERROR] Error during simulation")
    finally:
        print(f"[{timestamp()}] [INFO] End IQ Command")


def msvc_env_cmd():
    """
    Returns the command prefix to set up the MSVC environment using 'vcvarsall.bat'.
    Adjust the path to 'vcvarsall.bat' according to your Visual Studio installation.
    """
    # Beispielpfad für Visual Studio 2022 Community Edition
    vcvarsall_path = r'"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvarsall.bat"'
    arch = "x64"  # Oder "x86", "x86_amd64" etc.
    return f'call {vcvarsall_path} {arch} && '


def is_windows():
    """Returns True if the OS is Windows."""
    return platform.system().lower() == "windows"


def find_free_port(start: int = 8000, end: int = 9000) -> int:
    """
    Durchläuft Ports von `start` bis `end` und gibt den ersten freien Port zurück.
    Wir öffnen temporär einen Socket, um zu prüfen, ob der Port belegt ist.
    """
    for port in range(start, end):
        with contextlib.closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as sock:
            if sock.connect_ex(("localhost", port)) != 0:
                return port
    raise RuntimeError(f"No free port found between {start} and {end}.")


def start_local_server(directory: str,
                       requested_port: int,
                       port_container: dict,
                       started_event: threading.Event) -> None:
    """
    Startet einen HTTP-Server im angegebenen `directory`:
      1. Versucht zuerst `requested_port`.
      2. Ist dieser belegt, wird mit `find_free_port()` ein neuer freier Port gesucht.
      3. Legt den tatsächlich verwendeten Port in `port_container['port']` ab.
      4. Signalisiert über `started_event`, sobald der Server bereit ist.
      5. Führt dann `serve_forever()` aus (blockierend).

    Args:
        directory (str): Verzeichnis, in dem der Server dienen soll.
        requested_port (int): Gewünschter Startport (z.B. 8000).
        port_container (dict): Dient dazu, den gewählten Port zurückzumelden.
        started_event (threading.Event): Wird gesetzt, sobald der Server läuft.
    """
    # Verzeichnis wechseln
    try:
        os.chdir(directory)
        chosen_port = requested_port

        # Test, ob der gewünschte Port schon belegt ist
        with contextlib.closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as test_sock:
            if test_sock.connect_ex(("localhost", chosen_port)) == 0:
                # Port belegt → Fehler provozieren, damit wir in den Except-Zweig springen
                raise OSError(f"Port {chosen_port} belegt.")
    except OSError:
        print(f"[{timestamp()}] [INFO] Port {requested_port} is busy. Searching for a free port...")
        chosen_port = find_free_port()

    handler = http.server.SimpleHTTPRequestHandler

    # ThreadingTCPServer erlaubt parallele Anfragen
    with socketserver.ThreadingTCPServer(("localhost", chosen_port), handler) as httpd:
        httpd.allow_reuse_address = True
        # Finalen Port weitergeben und Event setzen
        port_container['port'] = chosen_port
        started_event.set()
        print(f"[{timestamp()}] [INFO] Server started: http://localhost:{chosen_port}/")
        httpd.serve_forever()
        # Sobald shutdown() gerufen wurde, endet serve_forever() und wir kommen hierher.
    # Ende: Kontext-Manager schließt den Server automatisch


def is_cmd_command(cmd_name):
    """Check if it's a CMD internal command"""
    try:
        subprocess.check_output(f'cmd /c "{cmd_name} /?"', stderr=subprocess.STDOUT, shell=True, text=True)
        return True
    except subprocess.CalledProcessError:
        return False


def is_powershell_command(cmd_name):
    """Check if it's a Windows PowerShell (powershell.exe) command"""
    try:
        subprocess.check_output(
            ["powershell", "-Command", f"Get-Command {cmd_name}"],
            stderr=subprocess.STDOUT,
            text=True
        )
        return True
    except subprocess.CalledProcessError:
        return False


def is_pwsh_command(cmd_name):
    """Check if it's a PowerShell 7+ (pwsh.exe) command"""
    try:
        subprocess.check_output(
            ["pwsh", "-Command", f"Get-Command {cmd_name}"],
            stderr=subprocess.STDOUT,
            text=True
        )
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


def is_pp_terminal_command(cmd_name):
    """Check if the command is in the autocompletion JSON"""
    json_path = r"C:\Users\julian\p-terminal\pp-term\autocompletion_commands.json"
    if not os.path.exists(json_path):
        return False
    try:
        with open(json_path, "r", encoding="utf-8") as f:
            data = json.load(f)
            # Erwarte Struktur: {"commands": ["pp-start", "pp-stop", ...]}
            commands = data.get("commands", [])
            return cmd_name in commands
    except json.JSONDecodeError:
        return False


def handle_vs_cpp_command(user_input: str) -> bool:
    """
    Verarbeitet den Befehl 'vs-cpp <datei>.cpp' oder direkt '<datei>.cpp' und kompiliert die angegebene C++-Datei
    mit den Visual Studio Build-Tools im aktuellen Arbeitsverzeichnis.

    Gibt True zurück, um die Schleife fortzusetzen.
    """
    parts = user_input.strip().split()

    # Erlaube Eingabe mit oder ohne 'vs-cpp'
    if len(parts) == 1 and parts[0].lower().endswith('.cpp'):
        filename = parts[0]
    elif len(parts) == 2 and parts[0].lower() == 'vs-cpp' and parts[1].lower().endswith('.cpp'):
        filename = parts[1]
    else:
        print(f"[{timestamp()}] [ERROR] Usage: vs-cpp <filename>.cpp, pc-cpp <filename>.cpp or simply <filename>.cpp")
        return True

    # Prüfe Datei im aktuellen Verzeichnis
    filepath = os.path.join(os.getcwd(), filename)
    if not os.path.isfile(filepath):
        print(f"[{timestamp()}] [ERROR] File not found:{filename}")
        return True

    try:
        vcvarsall = find_vcvarsall()
    except FileNotFoundError as e:
        print(e)
        return True

    # Initialisiere VS-Umgebung und kompiliere
    bat_command = f'"{vcvarsall}" x64 && cl /EHsc "{filename}"'
    # '/c' sorgt dafür, dass cmd nach Ausführung schließt
    full_command = f'cmd.exe /c "{bat_command}"'

    logging.info(f"[INFO] Execute:{bat_command}")
    try:
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        # check=True wirft bei Fehler eine CalledProcessError
        subprocess.run(full_command, shell=True, check=True)
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Cancellation by user.")
    except subprocess.CalledProcessError as e:
        print(f"[{timestamp()}] [ERROR] Compilation failed (Exit {e.returncode}).")
    return True


def shutdown_thonny():
    # Beispiel-Funktion, wie du Thonny beenden willst
    print(f"[{timestamp()}] [INFO] Shutting down Thonny...")
    # Hier deine Logik zum Beenden/Shutdown


def shutdown_spy():
    print(f"[{timestamp()}] [INFO] Shutdown requested.")


def handle_vs_c_command(user_input: str) -> bool:
    """
    Verarbeitet C-Befehle 'vs-c <datei>.c' oder '<datei>.c'.
    Gibt True zurück, um die Schleife fortzusetzen.
    """
    parts = user_input.strip().split()
    if len(parts) == 1 and parts[0].lower().endswith('.c'):
        filename = parts[0]
    elif len(parts) == 2 and parts[0].lower() == 'vs-c' and parts[1].lower().endswith('.c'):
        filename = parts[1]
    else:
        return False

    filepath = os.path.join(os.getcwd(), filename)
    if not os.path.isfile(filepath):
        print(f"[{timestamp()}] [ERROR] File not found:{filename}")
        return True

    try:
        vcvarsall = find_vcvarsall_c()
    except FileNotFoundError as e:
        print(e)
        return True

    bat_command = f'"{vcvarsall}" x64 && cl "{filename}"'
    full_command = f'cmd.exe /c "{bat_command}"'

    logging.info(f"[INFO] Run C-Build: {bat_command}")
    try:
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run(full_command, shell=True, check=True)
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Cancellation by user.")
    except subprocess.CalledProcessError as e:
        print(f"[{timestamp()}] [ERROR] Compilation failed (Exit {e.returncode}).")
    return True


def handle_vs_cs_command(user_input: str) -> bool:
    """
    Verarbeitet den Befehl 'vs-cs <datei>.cs' oder direkt '<datei>.cs' und kompiliert die angegebene C#-Datei.
    """
    parts = user_input.strip().split()

    if len(parts) == 1 and parts[0].lower().endswith('.cs'):
        filename = parts[0]
    elif len(parts) == 2 and parts[0].lower() == 'vs-cs' and parts[1].lower().endswith('.cs'):
        filename = parts[1]
    else:
        print(f"[{timestamp()}] [ERROR] Usage: vs-cs <filename>.cs, pc-cs <filename>.cpp  or simply <filename>.cs")
        return True

    filepath = os.path.join(os.getcwd(), filename)
    if not os.path.isfile(filepath):
        print(f"[{timestamp()}] [ERROR] File not found: {filename}")
        return True

    try:
        csc_path = find_csc_path()
    except FileNotFoundError as e:
        print(e)
        return True

    output_exe = os.path.splitext(filename)[0] + '.exe'
    compile_cmd = f'"{csc_path}" /nologo /out:"{output_exe}" "{filename}"'

    logging.info(f"[INFO] Execute: {compile_cmd}")
    try:
        print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
        subprocess.run(compile_cmd, shell=True, check=True)
        print(f"[{timestamp()}] [INFO] Compilation successful: {output_exe}")
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Compilation cancelled by user.")
    except subprocess.CalledProcessError as e:
        print(f"[{timestamp()}] [ERROR] Compilation failed (Exit {e.returncode}).")
    return True


def get_weather():
    print(f"[{timestamp()}] [INFO] Fetching detailed weather for Berlin... (Demo)\n")
    time.sleep(1)

    weather_icons = {
        "Sunny": "☀️",
        "Clear": "🌕",
        "Partly cloudy": "⛅",
        "Cloudy": "☁️",
        "Overcast": "☁️",
        "Mist": "🌫️",
        "Patchy rain": "🌦️",
        "Light rain": "🌧️",
        "Heavy rain": "🌧️🌧️",
        "Thunderstorm": "⛈️",
        "Snow": "❄️",
        "Fog": "🌁",
    }

    try:
        url = "https://wttr.in/Berlin?format=%C+%t+%h+%w+%m+%p+%l+%T"
        response = requests.get(url)

        if response.status_code == 200:
            weather_data = response.text.split()
            condition = weather_data[0]
            temperature = weather_data[1]
            humidity = weather_data[2]
            wind = weather_data[3]
            moon_phase = weather_data[4]
            precipitation = weather_data[5]
            location = weather_data[6]
            observation_time = weather_data[7]

            # Passendes Icon suchen
            icon = weather_icons.get(condition, "🌈")

            # Coole Ausgabe
            print(f"{main_color}Location{reset}: {location}")
            print(f"{main_color}Time{reset}: {observation_time}")
            print(f"{main_color}Condition{reset}: {icon} {condition}")
            print(f"{main_color}Temperature{reset}: {temperature}")
            print(f"{main_color}Humidity{reset}: {humidity}")
            print(f"{main_color}Wind{reset}: {wind}")
            print(f"{main_color}Moon Phase{reset}: {moon_phase}")
            print(f"{main_color}Precipitation{reset}: {precipitation}\n")
        else:
            print(f"[{timestamp()}] [ERROR] Failed to retrieve weather data. Status code: {response.status_code}")
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error fetching weather: {str(e)}")


def type_out_text(text, delay=0.05):
    """Tippt den Text langsam aus."""
    for char in text:
        sys.stdout.write(char)
        sys.stdout.flush()
        time.sleep(delay)
    print()


def ensure_admin():
    """
    Startet das Skript mit Administrator- bzw. Root-Rechten neu, falls nötig.
    - Unter Linux/macOS: sudo
    - Unter Windows: über ctypes (ShellExecute)
    """
    if os.name == 'posix':
        if os.geteuid() != 0:
            print(f"[{timestamp()}] [INFO] Restarting with root privileges...", file=sys.stderr)
            args = ['sudo', sys.executable] + sys.argv
            os.execvp('sudo', args)
    elif os.name == 'nt':
        try:
            if not ctypes.windll.shell32.IsUserAnAdmin():
                print(f"[{timestamp()}] [INFO] Restarting with administrator privileges...", file=sys.stderr)
                params = ' '.join(shlex.quote(arg) for arg in sys.argv)
                ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, params, None, 1)
                sys.exit(0)
        except Exception as e:
            logging.error(f"[{timestamp()}] [ERROR] Admin check failed: {e}")
    else:
        logging.warning(f"[{timestamp()}] [INFO] Unsupported OS for admin elevation: {os.name}")


def copy_files_from_iphone(source_path, destination_path):
    pythoncom.CoInitialize()

    shell = win32com.client.Dispatch("Shell.Application")
    iphone = None

    print(f"[{timestamp()}] [INFO] Search iPhone under 'This PC'...")
    for item in shell.NameSpace(17).Items():  # 17 = "Dieser PC"
        if "iPhone" in item.Name:
            iphone = item.GetFolder
            break

    if not iphone:
        print(f"[{timestamp()}] [ERROR] iPhone not found. Is it connected and unlocked?")
        return

    folders = source_path.strip("\\").split("\\")
    current_folder = iphone

    for folder in folders:
        found = False
        for item in current_folder.Items():
            if item.IsFolder and item.Name == folder:
                current_folder = item.GetFolder
                found = True
                break
        if not found:
            print(f"[{timestamp()}] [ERROR] Folder '{folder}' not found.")
            return

    # Zielordner erstellen, falls nicht vorhanden
    if not os.path.exists(destination_path):
        os.makedirs(destination_path)

    print(f"[{timestamp()}] [INFO] Start copying from '{source_path}' to '{destination_path}' ...")
    for item in current_folder.Items():
        if not item.IsFolder:
            dest_file = os.path.join(destination_path, item.Name)
            print(f"[{timestamp()}] [INFO] Copy: {item.Name}")
            try:
                # Versuch mit native copy (funktioniert nicht immer mit MTP)
                shutil.copy2(item.Path, dest_file)
            except Exception as e:
                print(f"[{timestamp()}] [ERROR] Error when copying directly: {e}")
                try:
                    # Alternativ per Clipboard (Explorer Trick)
                    item.InvokeVerb("Copy")
                    shell.NameSpace(destination_path).Self.InvokeVerb("Paste")
                except Exception as e2:
                    print(f"[{timestamp()}] [ERROR] Error when inserting via Explorer: {e2}")

    print(f"[{timestamp()}] [INFO] Copy process completed.")


def delete_target(path: str):
    """
    Entfernt eine Datei oder ein Verzeichnis (rekursiv).
    Bei Fehlern wird die Ausnahme protokolliert.
    """
    try:
        if os.path.isdir(path):
            shutil.rmtree(path)
            print(f"[{timestamp()}] [INFO] Directory deleted: {path}")
        else:
            os.remove(path)
            print(f"[{timestamp()}] [INFO] File deleted: {path}")
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] {e}", file=sys.stderr)


def get_response_from_ollama(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="qwen3:14b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_qwen0_6(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="qwen3:0.6b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_qwen1_7(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="qwen3:1.7b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_qwen4(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="qwen3:4b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_qwen8(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="qwen3:8b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_qwen32(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="qwen3:32b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_qwen30(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="qwen3:30b-a3b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_qwen235(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="qwen3:235b-a22b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_llama4_scout(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="llama4:scout",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_llama4_maverick(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="llama4:maverick",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_deepseek_r1_1_5(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="deepseek-r1:1.5b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_deepseek_r1_7(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="deepseek-r1:7b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_deepseek_r1_8(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="deepseek-r1:8b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_deepseek_r1_14(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="deepseek-r1:14b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_deepseek_r1_32(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="deepseek-r1:32b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_deepseek_r1_70(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="deepseek-r1:70b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_deepseek_r1_671(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="deepseek-r1:671b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_gemma3_1(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="gemma3:1b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_gemma3_4(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="gemma3:4b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_gemma3_12(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="gemma3:12b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_gemma3_27(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="gemma3:27b",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def get_response_from_ollama_devstral(user_message, ollama):
    """Fragt Ollama nach einer Antwort auf die Benutzereingabe."""
    try:
        response = ollama.chat(
            model="devstral",  # Modellname
            messages=[{"role": "user", "content": user_message}]
        )
        return response['message']['content']
    except Exception as e:
        return f"[{timestamp()}] [ERROR] {e}"


def check_ollama_update():
    """
    Prüft, ob eine neue Version von Ollama verfügbar ist, und bietet ein Update an.
    """
    try:
        result = subprocess.run(["ollama", "version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if result.returncode == 0:
            local_version = result.stdout.strip()
            remote_version = subprocess.run(["curl", "-s", "https://api.ollama.ai/version"],
                                            stdout=subprocess.PIPE, text=True).stdout.strip()

            if local_version != remote_version:
                print(
                    f"[{timestamp()}] [INFO] New Ollama version available: {remote_version} (Current: {local_version})")
                while True:
                    user_input = input("Do you want to update Ollama? [y/n]:").strip().lower()
                    if user_input in ["y", "yes"]:
                        subprocess.run(["ollama", "update"], check=True)
                        print(f"[{timestamp()}] [PASS] Ollama updated successfully! Please restart the script.")
                        exit()
                    elif user_input in ["n", "no"]:
                        print(f"[{timestamp()}] [INFO] Skipping update.")
                        break
                    else:
                        print(f"[{timestamp()}] [INFO] Invalid input. Please enter 'y' for yes or 'n' for no.")

    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error checking for updates: {e}{reset}")


def find_ollama_path():
    """
    Findet den Installationspfad von Ollama basierend auf dem Betriebssystem.
    """
    try:
        if platform.system() == "Windows":
            base_path = os.environ.get("LOCALAPPDATA", "C:\\Users\\Default\\AppData\\Local")
            return os.path.join(base_path, "Programs", "Ollama", "ollama app.exe")
        elif platform.system() == "Darwin":  # macOS
            return "/Applications/Ollama.app/Contents/MacOS/Ollama"
        else:
            raise EnvironmentError(
                f"[{timestamp()}] [INFO] Unsupported Operating System. Ollama is not supported on this platform.")
    except Exception as e:
        raise FileNotFoundError(f"[{timestamp()}] [ERROR] Error finding Ollama path: {e}")


def start_ollama():
    """
    Startet Ollama, falls es noch nicht läuft.
    """
    try:
        # Überprüfen, ob Ollama bereits läuft
        result = subprocess.run(
            ["tasklist"] if platform.system() == "Windows" else ["ps", "aux"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        if "ollama" not in result.stdout.lower():
            print(f"[{timestamp()}] [INFO] Ollama is not running. Starting Ollama...")

            # Pfad zu Ollama finden
            ollama_path = find_ollama_path()

            if not os.path.exists(ollama_path):
                raise FileNotFoundError(f"[{timestamp()}] [ERROR] Ollama executable not found at: {ollama_path}")

            # Ollama starten
            subprocess.Popen([ollama_path], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                             close_fds=True if platform.system() != "Windows" else False)
            time.sleep(5)  # Warten, bis Ollama gestartet ist
            print(f"[{timestamp()}] [PASS] Ollama started successfully.{reset}\n")
        else:
            print(f"[{timestamp()}] [INFO] Ollama is already running.{reset}\n")
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error starting Ollama: {e}{reset}")


def check_command_installed(command):
    """
    Überprüft, ob ein Befehlszeilentool installiert ist (z. B. ollama).
    :param command: Zu prüfender Befehlsname.
    :return: True, wenn installiert, andernfalls False.
    """
    try:
        result = subprocess.run(["which" if os.name != "nt" else "where", command],
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        return result.returncode == 0
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error checking command {command}: {e}")
        return False


def is_tool_installed(tool_name):
    """Prüfen Sie, ob ein Tool installiert ist."""
    result = subprocess.run(["which", tool_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    return result.returncode == 0


def search_websites(command):
    """Sucht mit DuckDuckGo nach Websites, die mit dem Keyword in Zusammenhang stehen, und gibt Links zurück"""
    url = "https://html.duckduckgo.com/html/"
    params = {'q': command}
    headers = {
        'User-Agent': 'Mozilla/5.0'
    }

    print(f"\n[{timestamp()}] [INFO] Searching for: '{command}' ...\n")
    try:
        response = requests.post(url, data=params, headers=headers, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error during request: {e}")
        return

    soup = BeautifulSoup(response.text, 'html.parser')
    links = []

    for i, a in enumerate(soup.find_all('a', class_='result__a', href=True), start=1):
        links.append(a['href'])
        print(f"{main_color}[{i}]{reset} {a['href']}")

    if not links:
        print(f"[{timestamp()}] [ERROR] No results found.")
    else:
        print(f"\n[{timestamp()}] [INFO] {len(links)} results found.\n")


def search_websites_all(command, num_results=50, results_per_page=10):
    """Sucht mit DuckDuckGo nach Websites, die mit dem Keyword in Zusammenhang stehen, und gibt Links zurück"""
    base_url = "https://html.duckduckgo.com/html/"
    headers = {'User-Agent': 'Mozilla/5.0'}
    collected = []

    print(f"\n[{timestamp()}] [INFO] Searching for: '{command}' ...\n")

    for offset in range(0, num_results, results_per_page):
        params = {'q': command, 's': str(offset)}
        try:
            response = requests.post(base_url, data=params, headers=headers, timeout=10)
            response.raise_for_status()
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] Request failed at offset {offset}: {e}")
            break

        soup = BeautifulSoup(response.text, 'html.parser')
        results = soup.find_all('div', class_='result')
        if not results:
            print(f"[{timestamp()}] [INFO] No further results at Offset {offset}.")
            break

        for result in results:
            link_tag = result.find('a', class_='result__a', href=True)
            desc_tag = result.find('a', class_='result__snippet') or result.find('div', class_='result__snippet')
            url = link_tag['href'] if link_tag else None
            snippet = desc_tag.get_text(strip=True) if desc_tag else 'No description available.'

            if url and (url, snippet) not in collected:
                collected.append((url, snippet))
                idx = len(collected)
                print(f"{main_color}[{idx}]{reset} {url}\n{snippet}\n")

            if len(collected) >= num_results:
                break
        if len(collected) >= num_results:
            break

    total = len(collected)
    if total == 0:
        print(f"[{timestamp()}] [ERROR] No results found.")
    else:
        print(f"\n[{timestamp()}] [INFO] {total} Results collected.\n")

    return collected


def search_and_show_first_image(query):
    with DDGS() as ddgs:
        results = ddgs.images(query, max_results=1)
        for result in results:
            image_url = result.get("image")
            if not image_url:
                print(f"[{timestamp()}] [ERROR] No picture found.")
                return

            try:
                print(f"[{timestamp()}] [INFO] Charge picture of: {image_url}")
                response = requests.get(image_url, timeout=10)
                image = Image.open(BytesIO(response.content))
                temp_path = "temp_duck_image.jpg"
                image.convert("RGB").save(temp_path)
                print(f"[{timestamp()}] [INFO] Show picture ...")
                os.startfile(temp_path)  # Nur für Windows
                return
            except Exception as e:
                print(f"[{timestamp()}] [ERROR] Error loading or displaying the image: {e}")
                return


def search_github(command):
    """Durchsucht GitHub mit DuckDuckGo nach Repositories oder Seiten, die mit dem Schlüsselwort in Zusammenhang stehen, und gibt Links zurück"""
    url = "https://html.duckduckgo.com/html/"
    params = {'q': f"site:github.com {command}"}
    headers = {
        'User-Agent': 'Mozilla/5.0'
    }

    print(f"\n[{timestamp()}] [INFO] Searching for: '{command}' ...\n")
    try:
        response = requests.post(url, data=params, headers=headers, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error during request: {e}")
        return

    soup = BeautifulSoup(response.text, 'html.parser')
    links = []

    for i, a in enumerate(soup.find_all('a', class_='result__a', href=True), start=1):
        links.append(a['href'])
        print(f"{main_color}[{i}]{reset} {a['href']}")

    if not links:
        print(f"[{timestamp()}] [ERROR] No results found.")
    else:
        print(f"\n[{timestamp()}] [INFO] {len(links)} results found.\n")


def search_huggingface(command):
    """Durchsucht Hugging Face mithilfe von DuckDuckGo nach Seiten, die mit dem Schlüsselwort in Zusammenhang stehen, und gibt Links zurück"""
    url = "https://html.duckduckgo.com/html/"
    params = {'q': f"site:huggingface.co {command}"}
    headers = {
        'User-Agent': 'Mozilla/5.0'
    }

    print(f"\n[{timestamp()}] [INFO] Searching for: '{command}' ...\n")
    try:
        response = requests.post(url, data=params, headers=headers, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error during request: {e}")
        return

    soup = BeautifulSoup(response.text, 'html.parser')
    links = []

    for i, a in enumerate(soup.find_all('a', class_='result__a', href=True), start=1):
        links.append(a['href'])
        print(f"{main_color}[{i}]{reset} {a['href']}")

    if not links:
        print(f"[{timestamp()}] [ERROR] No results found.")
    else:
        print(f"\n[{timestamp()}] [INFO] {len(links)} results found.\n")


def search_ollama(command):
    """Durchsucht Ollama mit DuckDuckGo nach Seiten, die mit dem Schlüsselwort in Zusammenhang stehen, und gibt Links zurück"""
    url = "https://html.duckduckgo.com/html/"
    params = {'q': f"site:ollama.com {command}"}
    headers = {
        'User-Agent': 'Mozilla/5.0'
    }

    print(f"\n[{timestamp()}] [INFO] Searching for: '{command}' ...\n")
    try:
        response = requests.post(url, data=params, headers=headers, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error during request: {e}")
        return

    soup = BeautifulSoup(response.text, 'html.parser')
    links = []

    for i, a in enumerate(soup.find_all('a', class_='result__a', href=True), start=1):
        links.append(a['href'])
        print(f"{main_color}[{i}]{reset} {a['href']}")

    if not links:
        print(f"[{timestamp()}] [ERROR] No results found.")
    else:
        print(f"\n[{timestamp()}] [INFO] {len(links)} results found.\n")


def search_stackoverflow(command):
    """Durchsucht Stackoverflow mit DuckDuckGo nach Seiten, die mit dem Schlüsselwort in Zusammenhang stehen, und gibt Links zurück"""
    url = "https://html.duckduckgo.com/html/"
    params = {'q': f"site:stackoverflow.com {command}"}
    headers = {
        'User-Agent': 'Mozilla/5.0'
    }

    print(f"\n[{timestamp()}] [INFO] Searching for: '{command}' ...\n")
    try:
        response = requests.post(url, data=params, headers=headers, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error during request: {e}")
        return

    soup = BeautifulSoup(response.text, 'html.parser')
    links = []

    for i, a in enumerate(soup.find_all('a', class_='result__a', href=True), start=1):
        links.append(a['href'])
        print(f"{main_color}[{i}]{reset} {a['href']}")

    if not links:
        print(f"[{timestamp()}] [ERROR] No results found.")
    else:
        print(f"\n[{timestamp()}] [INFO] {len(links)} results found.\n")


def search_stackexchange(command):
    """Durchsucht Stackexchange mit DuckDuckGo nach Seiten, die mit dem Schlüsselwort in Zusammenhang stehen, und gibt Links zurück"""
    url = "https://html.duckduckgo.com/html/"
    params = {'q': f"site:stackexchange.com {command}"}
    headers = {
        'User-Agent': 'Mozilla/5.0'
    }

    print(f"\n[{timestamp()}] [INFO] Searching for: '{command}' ...\n")
    try:
        response = requests.post(url, data=params, headers=headers, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error during request: {e}")
        return

    soup = BeautifulSoup(response.text, 'html.parser')
    links = []

    for i, a in enumerate(soup.find_all('a', class_='result__a', href=True), start=1):
        links.append(a['href'])
        print(f"{main_color}[{i}]{reset} {a['href']}")

    if not links:
        print(f"[{timestamp()}] [ERROR] No results found.")
    else:
        print(f"\n[{timestamp()}] [INFO] {len(links)} results found.\n")


def search_pypi(command):
    """Durchsucht pypi mit DuckDuckGo nach Seiten, die mit dem Schlüsselwort in Zusammenhang stehen, und gibt Links zurück"""
    url = "https://html.duckduckgo.com/html/"
    params = {'q': f"site:pypi.org {command}"}
    headers = {
        'User-Agent': 'Mozilla/5.0'
    }

    print(f"\n[{timestamp()}] [INFO] Searching for: '{command}' ...\n")
    try:
        response = requests.post(url, data=params, headers=headers, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error during request: {e}")
        return

    soup = BeautifulSoup(response.text, 'html.parser')
    links = []

    for i, a in enumerate(soup.find_all('a', class_='result__a', href=True), start=1):
        links.append(a['href'])
        print(f"{main_color}[{i}]{reset} {a['href']}")

    if not links:
        print(f"[{timestamp()}] [ERROR] No results found.")
    else:
        print(f"\n[{timestamp()}] [INFO] {len(links)} results found.\n")


def search_arxiv(command):
    """Durchsucht arxiv mit DuckDuckGo nach Seiten, die mit dem Schlüsselwort in Zusammenhang stehen, und gibt Links zurück"""
    url = "https://html.duckduckgo.com/html/"
    params = {'q': f"site:arxiv.org {command}"}
    headers = {
        'User-Agent': 'Mozilla/5.0'
    }

    print(f"\n[{timestamp()}] [INFO] Searching for: '{command}' ...\n")
    try:
        response = requests.post(url, data=params, headers=headers, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error during request: {e}")
        return

    soup = BeautifulSoup(response.text, 'html.parser')
    links = []

    for i, a in enumerate(soup.find_all('a', class_='result__a', href=True), start=1):
        links.append(a['href'])
        print(f"{main_color}[{i}]{reset} {a['href']}")

    if not links:
        print(f"[{timestamp()}] [ERROR] No results found.")
    else:
        print(f"\n[{timestamp()}] [INFO] {len(links)} results found.\n")


def search_paperswithcode(command):
    """Durchsucht paperswithcode mit DuckDuckGo nach Seiten, die mit dem Schlüsselwort in Zusammenhang stehen, und gibt Links zurück"""
    url = "https://html.duckduckgo.com/html/"
    params = {'q': f"site:paperswithcode.com {command}"}
    headers = {
        'User-Agent': 'Mozilla/5.0'
    }

    print(f"\n[{timestamp()}] [INFO] Searching for: '{command}' ...\n")
    try:
        response = requests.post(url, data=params, headers=headers, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error during request: {e}")
        return

    soup = BeautifulSoup(response.text, 'html.parser')
    links = []

    for i, a in enumerate(soup.find_all('a', class_='result__a', href=True), start=1):
        links.append(a['href'])
        print(f"{main_color}[{i}]{reset} {a['href']}")

    if not links:
        print(f"[{timestamp()}] [ERROR] No results found.")
    else:
        print(f"\n[{timestamp()}] [INFO] {len(links)} results found.\n")


def search_kaggle(command):
    """Durchsucht Kaggle mithilfe von DuckDuckGo nach Seiten, die mit dem Schlüsselwort in Zusammenhang stehen, und gibt Links zurück"""
    url = "https://html.duckduckgo.com/html/"
    params = {'q': f"site:kaggle.com {command}"}
    headers = {
        'User-Agent': 'Mozilla/5.0'
    }

    print(f"\n[{timestamp()}] [INFO] Searching for: '{command}' ...\n")
    try:
        response = requests.post(url, data=params, headers=headers, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error during request: {e}")
        return

    soup = BeautifulSoup(response.text, 'html.parser')
    links = []

    for i, a in enumerate(soup.find_all('a', class_='result__a', href=True), start=1):
        links.append(a['href'])
        print(f"{main_color}[{i}]{reset} {a['href']}")

    if not links:
        print(f"[{timestamp()}] [ERROR] No results found.")
    else:
        print(f"\n[{timestamp()}] [INFO] {len(links)} results found.\n")


def search_geeksforgeeks(command):
    """Durchsucht geeksforgeeks mit DuckDuckGo nach Seiten, die mit dem Schlüsselwort in Zusammenhang stehen, und gibt Links zurück"""
    url = "https://html.duckduckgo.com/html/"
    params = {'q': f"site:geeksforgeeks.org {command}"}
    headers = {
        'User-Agent': 'Mozilla/5.0'
    }

    print(f"\n[{timestamp()}] [INFO] Searching for: '{command}' ...\n")
    try:
        response = requests.post(url, data=params, headers=headers, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error during request: {e}")
        return

    soup = BeautifulSoup(response.text, 'html.parser')
    links = []

    for i, a in enumerate(soup.find_all('a', class_='result__a', href=True), start=1):
        links.append(a['href'])
        print(f"{main_color}[{i}]{reset} {a['href']}")

    if not links:
        print(f"[{timestamp()}] [ERROR] No results found.")
    else:
        print(f"\n[{timestamp()}] [INFO] {len(links)} results found.\n")


def search_realpython(command):
    """Durchsucht realpython mit DuckDuckGo nach Seiten, die mit dem Schlüsselwort in Zusammenhang stehen, und gibt Links zurück"""
    url = "https://html.duckduckgo.com/html/"
    params = {'q': f"site:realpython.com {command}"}
    headers = {
        'User-Agent': 'Mozilla/5.0'
    }

    print(f"\n[{timestamp()}] [INFO] Searching for: '{command}' ...\n")
    try:
        response = requests.post(url, data=params, headers=headers, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error during request: {e}")
        return

    soup = BeautifulSoup(response.text, 'html.parser')
    links = []

    for i, a in enumerate(soup.find_all('a', class_='result__a', href=True), start=1):
        links.append(a['href'])
        print(f"{main_color}[{i}]{reset} {a['href']}")

    if not links:
        print(f"[{timestamp()}] [ERROR] No results found.")
    else:
        print(f"\n[{timestamp()}] [INFO] {len(links)} results found.\n")


def search_w3schools(command):
    """Durchsucht w3schools mit DuckDuckGo nach Seiten, die mit dem Schlüsselwort in Zusammenhang stehen, und gibt Links zurück"""
    url = "https://html.duckduckgo.com/html/"
    params = {'q': f"site:w3schools.com {command}"}
    headers = {
        'User-Agent': 'Mozilla/5.0'
    }

    print(f"\n[{timestamp()}] [INFO] Searching for: '{command}' ...\n")
    try:
        response = requests.post(url, data=params, headers=headers, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error during request: {e}")
        return

    soup = BeautifulSoup(response.text, 'html.parser')
    links = []

    for i, a in enumerate(soup.find_all('a', class_='result__a', href=True), start=1):
        links.append(a['href'])
        print(f"{main_color}[{i}]{reset} {a['href']}")

    if not links:
        print(f"[{timestamp()}] [ERROR] No results found.")
    else:
        print(f"\n[{timestamp()}] [INFO] {len(links)} results found.\n")


def search_developer_mozilla(command):
    """Durchsucht developer.mozilla.org mit DuckDuckGo nach Seiten, die mit dem Schlüsselwort in Zusammenhang stehen, und gibt Links zurück"""
    url = "https://html.duckduckgo.com/html/"
    params = {'q': f"site:developer.mozilla.org.com {command}"}
    headers = {
        'User-Agent': 'Mozilla/5.0'
    }

    print(f"\n[{timestamp()}] [INFO] Searching for: '{command}' ...\n")
    try:
        response = requests.post(url, data=params, headers=headers, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"[{timestamp()}] [ERROR] Error during request: {e}")
        return

    soup = BeautifulSoup(response.text, 'html.parser')
    links = []

    for i, a in enumerate(soup.find_all('a', class_='result__a', href=True), start=1):
        links.append(a['href'])
        print(f"{main_color}[{i}]{reset} {a['href']}")

    if not links:
        print(f"[{timestamp()}] [ERROR] No results found.")
    else:
        print(f"\n[{timestamp()}] [INFO] {len(links)} results found.\n")


def find_vcvarsall():
    """
    Sucht nach der Visual Studio-Initialisierungsdatei (vcvarsall.bat).
    """
    path = r"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvarsall.bat"
    if os.path.isfile(path):
        return path
    raise FileNotFoundError(
        f"[{timestamp()}] [ERROR] vcvarsall.bat not found. Please make sure Visual Studio is installed.")


def find_vcvarsall_c():
    """
    Sucht nach der Visual Studio Entwicklungsumgebung (vcvarsall.bat).
    """
    # Visual Studio Installationspfad (Standardort für VS 2022)
    vs_path = r"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvarsall.bat"
    if not os.path.isfile(vs_path):
        logging.error("[ERROR] Visual Studio vcvarsall.bat file not found.")
        raise FileNotFoundError(
            f"[{timestamp()}] [ERROR] vcvarsall.bat not found. Please ensure Visual Studio is installed.")
    return vs_path


def find_csc_path() -> str:
    """
    Searches for the C# compiler csc.exe in the .NET SDK or Visual Studio directory.
    """
    possible_paths = [
        r"C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe",
        r"C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe",
        r"C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin\Roslyn\csc.exe",
    ]
    for path in possible_paths:
        if os.path.isfile(path):
            logging.info(f"[{timestamp()}] [INFO] Found csc at {path}")
            return path

    logging.error(f"[{timestamp()}] [ERROR] csc.exe not found in known locations.")
    raise FileNotFoundError(f"[{timestamp()}] [ERROR] csc.exe not found. Please install .NET SDK or Visual Studio.")


# --- pp command---

def get_project_paths_mp():
    """
    Ermittelt das p-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    mp_cpp_file = os.path.join(terminal_dir, "run_mp_command.cpp")
    mp_exe_file = os.path.join(terminal_dir, "run_mp_command.exe")
    return mp_cpp_file, mp_exe_file, terminal_dir


def compile_mp_cpp_with_vs(mp_cpp_file, mp_exe_file):
    """
    Kompiliert run_pp_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_pp_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{mp_cpp_file}" /Fe:"{mp_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_command_with_admin_privileges(command):
    """
    Führt einen Powershell interaktiv über den C++-Wrapper aus.

    Falls run_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    mp_cpp_file, mp_exe_file, _ = get_project_paths_mp()

    if not os.path.isfile(mp_exe_file):
        if not compile_mp_cpp_with_vs(mp_cpp_file, mp_exe_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [mp_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- pp-c command---

def get_project_paths_mp_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    mp_c_file = os.path.join(terminal_dir, "run_mp_command.c")
    mp_c_exe_file = os.path.join(terminal_dir, "run_mp_c_command.exe")
    return mp_c_file, mp_c_exe_file, terminal_dir


def compile_mp_c_with_vs(mp_c_file, mp_c_exe_file):
    """
    Kompiliert run_pp_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_mp_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{mp_c_file}" /Fe:"{mp_c_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_command_with_admin_c_privileges(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_mp_c_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    mp_c_file, mp_c_exe_file, _ = get_project_paths_mp_c()

    if not os.path.isfile(mp_c_exe_file):
        if not compile_mp_c_with_vs(mp_c_file, mp_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [mp_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- pp-p command---

# Kritische Befehle – nur mit Warnung
FORBIDDEN_COMMANDS = [
    r"\brm\b",
    r"\bRemove-Item\b",
    r"\bdel\b",
    r"\bFormat-Volume\b",
    r"\bShutdown\b",
    r"\bStop-Computer\b",
    r"\bClear-Content\b",
    r"\bSet-Content\b",
    r"\bRemove-ItemProperty\b",
    r"\bRemove-Module\b",
    r"\bsudo\s+rm\b",
    r"\bmkfs\b",
    r"\bdiskpart\b",
    r"\breg delete\b"
]


def is_dangerous_command(command: str) -> bool:
    """
    Prüft, ob der Befehl als gefährlich eingestuft wird.
    """
    for pattern in FORBIDDEN_COMMANDS:
        if re.search(pattern, command, re.IGNORECASE):
            return True
    return False


# Interaktive Sicherheitsabfrage
def confirm_execution(command: str, dangerous: bool) -> bool:
    """
    Fragt den Benutzer, ob der Befehl ausgeführt werden darf.
    Bei gefährlichen Befehlen erfolgt eine deutliche Warnung.
    """
    logging.warning(f"[INFO] You are about to run the following command with admin privileges: {command}")
    if dangerous:
        logging.warning(
            f"[WARING] This command is considered potentially {red}critical{reset} or {red}system-threatening{reset}!")

    answer = input("\nContinue? [y/n]: ").strip().lower()
    print("")
    return answer in ['y', 'yes']


# Admin-Befehl ausführen (plattformsicher)
def run_command_with_admin_python_privileges(command: str):
    """
    Führt einen Shell-/PowerShell-Befehl mit Adminrechten aus,
    erlaubt auch gefährliche Befehle nach ausdrücklicher Zustimmung.
    """
    working_dir = os.getcwd()
    dangerous = is_dangerous_command(command)

    if not confirm_execution(command, dangerous):
        logging.warning("Aborted.")
        return

    if sys.platform == "win32":
        try:
            if ctypes.windll.shell32.IsUserAnAdmin():
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
                subprocess.run(command, shell=True, cwd=working_dir, check=True)
            else:
                ps_script = (
                    f"Set-Location -LiteralPath '{working_dir}'; "
                    f"{command}; "
                    "Read-Host 'Press Enter to exit…'"
                )

                args = [
                    "-NoProfile",
                    "-NoExit",
                    "-Command",
                    ps_script.replace('"', '`"')
                ]

                arg_list_literal = "@(" + ",".join(f'"{a}"' for a in args) + ")"

                ps_cmd = [
                    "powershell",
                    "-NoProfile",
                    "-Command",
                    "Start-Process",
                    "-FilePath", "powershell",
                    "-ArgumentList", arg_list_literal,
                    "-Verb", "RunAs"
                ]

                subprocess.run(ps_cmd, check=True)
            logging.warning("[PASS] Execution completed.")
        except subprocess.CalledProcessError as e:
            logging.warning(f"[ERROR] {e}")
        except Exception as e:
            logging.warning(f"[ERROR] Unexpected error: {e}")

    else:
        safe_cmd = command.replace("'", "'\"'\"'")
        full_script = f"cd '{working_dir}' && {safe_cmd}; echo; read -p '[Drücke Enter zum Schließen]' _"
        try:
            subprocess.run(
                ["sudo", "bash", "-c", full_script],
                check=True
            )
            logging.warning("[PASS] Execution completed.")
        except subprocess.CalledProcessError as e:
            logging.warning(f"[ERROR] Execution error: {e}")
        except Exception as e:
            logging.warning(f"[ERROR] Unexpected error: {e}")


def is_wsl_installed():
    """Überprüfen Sie, ob WSL installiert ist, indem Sie versuchen, einen grundlegenden WSL-Befehl auszuführen."""
    try:
        # Versuchen Sie, „wsl --list“ auszuführen, das die installierten WSL-Distributionen auflistet
        subprocess.check_call(["wsl", "--list"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return True
    except FileNotFoundError:
        # Ausführbare WSL-Datei nicht gefunden, d. h. WSL ist nicht installiert
        print(f"[{timestamp()}] [ERROR] WSL is not installed or not found on the system.")
        return False
    except subprocess.CalledProcessError:
        # WSL wurde gefunden, aber beim Ausführen des Befehls ist ein Fehler aufgetreten
        print(f"[{timestamp()}] [ERROR] WSL is installed, but an error occurred while executing the command.")
        return False
    except Exception as e:
        # Fangen Sie alle unerwarteten Ausnahmen ab
        print(f"[{timestamp()}] [ERROR] Unexpected error occurred while checking if WSL is installed: {e}")
        return False


# --- lx command---

def get_project_paths_lx():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    lx_cpp_file = os.path.join(terminal_dir, "run_lx_command.cpp")
    lx_exe_file = os.path.join(terminal_dir, "run_lx_command.exe")
    return lx_cpp_file, lx_exe_file, terminal_dir


def compile_lx_cpp_with_vs(lx_cpp_file, lx_exe_file):
    """
    Kompiliert run_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_lx_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{lx_cpp_file}" /Fe:"{lx_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_linux_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C++-Wrapper aus.

    Falls run_lx_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    lx_cpp_file, lx_exe_file, _ = get_project_paths_lx()

    if not os.path.isfile(lx_exe_file):
        if not compile_lx_cpp_with_vs(lx_cpp_file, lx_exe_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [lx_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARING] Cancellation by user.")


# --- lx-cpp-c command---

def get_project_cpp_c_paths_lx():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    lx_cpp_c_file = os.path.join(terminal_dir, "run_lx_c_command.cpp")
    lx_exe_c_file = os.path.join(terminal_dir, "run_cpp_lx_c_command.exe")
    return lx_cpp_c_file, lx_exe_c_file, terminal_dir


def compile_lx_cpp_c_with_vs(lx_cpp_c_file, lx_exe_c_file):
    """
    Kompiliert run_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_lx_c_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{lx_cpp_c_file}" /Fe:"{lx_exe_c_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_linux_cpp_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C++-Wrapper aus.

    Falls run_lx_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    lx_cpp_c_file, lx_exe_c_file, _ = get_project_cpp_c_paths_lx()

    if not os.path.isfile(lx_exe_c_file):
        if not compile_lx_cpp_c_with_vs(lx_cpp_c_file, lx_exe_c_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [lx_exe_c_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- lx-c command---

def get_project_paths_lx_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    lx_c_file = os.path.join(terminal_dir, "run_lx_command.c")
    lx_c_exe_file = os.path.join(terminal_dir, "run_c_lx_command.exe")
    return lx_c_file, lx_c_exe_file, terminal_dir


def compile_lx_c_with_vs(lx_c_file, lx_c_exe_file):
    """
    Kompiliert run_lx_c_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_lx_c_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{lx_c_file}" /Fe:"{lx_c_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_linux_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_lx_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    lx_c_file, lx_c_exe_file, _ = get_project_paths_lx_c()

    if not os.path.isfile(lx_c_exe_file):
        if not compile_lx_c_with_vs(lx_c_file, lx_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [lx_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- lx-c-c command---

def get_project_paths_lx_c_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    lx_c_c_file = os.path.join(terminal_dir, "run_lx_c_command.c")
    lx_c_c_exe_file = os.path.join(terminal_dir, "run_c_lx_c_command.exe")
    return lx_c_c_file, lx_c_c_exe_file, terminal_dir


def compile_lx_c_c_with_vs(lx_c_c_file, lx_c_c_exe_file):
    """
    Kompiliert run_lx_c_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_lx_c_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{lx_c_c_file}" /Fe:"{lx_c_c_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_linux_c_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_lx_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    lx_c_c_file, lx_c_c_exe_file, _ = get_project_paths_lx_c_c()

    if not os.path.isfile(lx_c_c_exe_file):
        if not compile_lx_c_c_with_vs(lx_c_c_file, lx_c_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [lx_c_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- lx-p command---

def run_linux_python_command(command):
    if isinstance(command, str):
        command = f"wsl -e {command}"

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

    try:
        process.wait()
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Process interrupted by user. Terminating...")
        process.terminate()


# --- lx-p-c command---

def run_linux_p_c_command(command):
    if isinstance(command, str):
        command = f"wsl -c {command}"

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

    try:
        process.wait()
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Process interrupted by user. Terminating...")
        process.terminate()


# --- ubuntu command---

def get_project_paths_ubuntu():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    ubuntu_cpp_file = os.path.join(terminal_dir, "run_ubuntu_command.cpp")
    ubuntu_exe_file = os.path.join(terminal_dir, "run_ubuntu_command.exe")
    return ubuntu_cpp_file, ubuntu_exe_file, terminal_dir


def compile_ubuntu_cpp_with_vs(ubuntu_cpp_file, ubuntu_exe_file):
    """
    Kompiliert run_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_ubuntu_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{ubuntu_cpp_file}" /Fe:"{ubuntu_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_ubuntu_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C++-Wrapper aus.

    Falls run_ubuntu_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    ubuntu_cpp_file, ubuntu_exe_file, _ = get_project_paths_ubuntu()

    if not os.path.isfile(ubuntu_exe_file):
        if not compile_ubuntu_cpp_with_vs(ubuntu_cpp_file, ubuntu_exe_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [ubuntu_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- ubuntu-c command---

def get_project_paths_ubuntu_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    ubuntu_c_file = os.path.join(terminal_dir, "run_ubuntu_command.c")
    ubuntu_c_exe_file = os.path.join(terminal_dir, "run_ubuntu_c_command.exe")
    return ubuntu_c_file, ubuntu_c_exe_file, terminal_dir


def compile_ubuntu_c_with_vs(ubuntu_c_file, ubuntu_c_exe_file):
    """
    Kompiliert run_ubuntu_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_ubuntu_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{ubuntu_c_file}" /Fe:"{ubuntu_c_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_ubuntu_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_ubuntu_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    ubuntu_c_file, ubuntu_c_exe_file, _ = get_project_paths_ubuntu_c()

    if not os.path.isfile(ubuntu_c_exe_file):
        if not compile_ubuntu_c_with_vs(ubuntu_c_file, ubuntu_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [ubuntu_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- ubuntu-p command---

def run_ubuntu_python_command(command):
    if isinstance(command, str):
        command = f"wsl -d ubuntu {command}"

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

    try:
        process.wait()
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Process interrupted by user. Terminating...")
        process.terminate()


# --- debian command---

def get_project_paths_debian():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    debian_cpp_file = os.path.join(terminal_dir, "run_debian_command.cpp")
    debian_exe_file = os.path.join(terminal_dir, "run_debian_command.exe")
    return debian_cpp_file, debian_exe_file, terminal_dir


def compile_debian_cpp_with_vs(debian_cpp_file, debian_exe_file):
    """
    Kompiliert run_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_debian_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{debian_cpp_file}" /Fe:"{debian_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_debian_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C++-Wrapper aus.

    Falls run_debian_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    debian_cpp_file, debian_exe_file, _ = get_project_paths_debian()

    if not os.path.isfile(debian_exe_file):
        if not compile_debian_cpp_with_vs(debian_cpp_file, debian_exe_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [debian_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- debian-c command---

def get_project_paths_debian_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    debian_c_file = os.path.join(terminal_dir, "run_debian_command.c")
    debian_c_exe_file = os.path.join(terminal_dir, "run_debian_c_command.exe")
    return debian_c_file, debian_c_exe_file, terminal_dir


def compile_debian_c_with_vs(debian_c_file, debian_c_exe_file):
    """
    Kompiliert run_debian_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_debian_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{debian_c_file}" /Fe:"{debian_c_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_debian_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_debian_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    debian_c_file, debian_c_exe_file, _ = get_project_paths_debian_c()

    if not os.path.isfile(debian_c_exe_file):
        if not compile_debian_c_with_vs(debian_c_file, debian_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [debian_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- debian-p command---

def run_debian_python_command(command):
    if isinstance(command, str):
        command = f"wsl -d debian {command}"

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

    try:
        process.wait()
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Process interrupted by user. Terminating...")
        process.terminate()


# --- kali command---

def get_project_paths_kali():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    kali_cpp_file = os.path.join(terminal_dir, "run_kali_command.cpp")
    kali_exe_file = os.path.join(terminal_dir, "run_kali_command.exe")
    return kali_cpp_file, kali_exe_file, terminal_dir


def compile_kali_cpp_with_vs(kali_cpp_file, kali_exe_file):
    """
    Kompiliert run_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_kali_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{kali_cpp_file}" /Fe:"{kali_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_kali_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C++-Wrapper aus.

    Falls run_kali_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    kali_cpp_file, kali_exe_file, _ = get_project_paths_kali()

    if not os.path.isfile(kali_exe_file):
        if not compile_kali_cpp_with_vs(kali_cpp_file, kali_exe_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [kali_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- kali-c command---

def get_project_paths_kali_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    kali_c_file = os.path.join(terminal_dir, "run_kali_command.c")
    kali_c_exe_file = os.path.join(terminal_dir, "run_kali_c_command.exe")
    return kali_c_file, kali_c_exe_file, terminal_dir


def compile_kali_c_with_vs(kali_c_file, kali_c_exe_file):
    """
    Kompiliert run_kali_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_kali_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{kali_c_file}" /Fe:"{kali_c_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_kali_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_lx_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    kali_c_file, kali_c_exe_file, _ = get_project_paths_kali_c()

    if not os.path.isfile(kali_c_exe_file):
        if not compile_kali_c_with_vs(kali_c_file, kali_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [kali_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- kali-p command---

def run_kali_python_command(command):
    if isinstance(command, str):
        command = f"wsl -d kali-linux {command}"

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

    try:
        process.wait()
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Process interrupted by user. Terminating...")
        process.terminate()


# --- arch command---

def get_project_paths_arch():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    arch_cpp_file = os.path.join(terminal_dir, "run_arch_command.cpp")
    arch_exe_file = os.path.join(terminal_dir, "run_arch_command.exe")
    return arch_cpp_file, arch_exe_file, terminal_dir


def compile_arch_cpp_with_vs(arch_cpp_file, arch_exe_file):
    """
    Kompiliert run_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_arch_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{arch_cpp_file}" /Fe:"{arch_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_arch_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C++-Wrapper aus.

    Falls run_arch_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    arch_cpp_file, arch_exe_file, _ = get_project_paths_arch()

    if not os.path.isfile(arch_exe_file):
        if not compile_arch_cpp_with_vs(arch_cpp_file, arch_exe_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [arch_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- arch-c command---

def get_project_paths_arch_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    arch_c_file = os.path.join(terminal_dir, "run_arch_command.c")
    arch_c_exe_file = os.path.join(terminal_dir, "run_arch_c_command.exe")
    return arch_c_file, arch_c_exe_file, terminal_dir


def compile_arch_c_with_vs(arch_c_file, arch_c_exe_file):
    """
    Kompiliert run_arch_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_arch_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{arch_c_file}" /Fe:"{arch_c_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_arch_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_larch_c_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    arch_c_file, arch_c_exe_file, _ = get_project_paths_arch_c()

    if not os.path.isfile(arch_c_exe_file):
        if not compile_arch_c_with_vs(arch_c_file, arch_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [arch_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- arch-p command---

def run_arch_python_command(command):
    if isinstance(command, str):
        command = f"wsl -d Arch {command}"

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

    try:
        process.wait()
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Process interrupted by user. Terminating...")
        process.terminate()


# --- opensuse command---

def get_project_paths_opensuse():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    opensuse_cpp_file = os.path.join(terminal_dir, "run_opensuse_command.cpp")
    opensuse_exe_file = os.path.join(terminal_dir, "run_opensuse_command.exe")
    return opensuse_cpp_file, opensuse_exe_file, terminal_dir


def compile_opensuse_cpp_with_vs(opensuse_cpp_file, opensuse_exe_file):
    """
    Kompiliert run_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_opensuse_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{opensuse_cpp_file}" /Fe:"{opensuse_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_opensuse_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C++-Wrapper aus.

    Falls run_arch_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    opensuse_cpp_file, opensuse_exe_file, _ = get_project_paths_opensuse()

    if not os.path.isfile(opensuse_exe_file):
        if not compile_opensuse_cpp_with_vs(opensuse_cpp_file, opensuse_exe_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [opensuse_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- opensuse-c command---

def get_project_paths_opensuse_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    opensuse_c_file = os.path.join(terminal_dir, "run_opensuse_command.c")
    opensuse_c_exe_file = os.path.join(terminal_dir, "run_opensuse_c_command.exe")
    return opensuse_c_file, opensuse_c_exe_file, terminal_dir


def compile_opensuse_c_with_vs(opensuse_c_file, opensuse_c_exe_file):
    """
    Kompiliert run_opensuse_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_opensuse_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{opensuse_c_file}" /Fe:"{opensuse_c_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_opensuse_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_opensuse_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    opensuse_c_file, opensuse_c_exe_file, _ = get_project_paths_opensuse_c()

    if not os.path.isfile(opensuse_c_exe_file):
        if not compile_opensuse_c_with_vs(opensuse_c_file, opensuse_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [opensuse_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- opensuse-p command---

def run_opensuse_python_command(command):
    if isinstance(command, str):
        command = f"wsl -d openSUSE-Leap {command}"

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

    try:
        process.wait()
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Process interrupted by user. Terminating...")
        process.terminate()


# --- mint command---

def get_project_paths_mint():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    mint_cpp_file = os.path.join(terminal_dir, "run_mint_command.cpp")
    mint_exe_file = os.path.join(terminal_dir, "run_mint_command.exe")
    return mint_cpp_file, mint_exe_file, terminal_dir


def compile_mint_cpp_with_vs(mint_cpp_file, mint_exe_file):
    """
    Kompiliert run_mint_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_mint_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{mint_cpp_file}" /Fe:"{mint_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_mint_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C++-Wrapper aus.

    Falls run_arch_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    mint_cpp_file, mint_exe_file, _ = get_project_paths_mint()

    if not os.path.isfile(mint_exe_file):
        if not compile_mint_cpp_with_vs(mint_cpp_file, mint_exe_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [mint_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- mint-c command---

def get_project_paths_mint_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    mint_c_file = os.path.join(terminal_dir, "run_mint_command.c")
    mint_c_exe_file = os.path.join(terminal_dir, "run_mint_c_command.exe")
    return mint_c_file, mint_c_exe_file, terminal_dir


def compile_mint_c_with_vs(mint_c_file, mint_c_exe_file):
    """
    Kompiliert run_mint_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_mint_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{mint_c_file}" /Fe:"{mint_c_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_mint_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_mint_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    mint_c_file, mint_c_exe_file, _ = get_project_paths_mint_c()

    if not os.path.isfile(mint_c_exe_file):
        if not compile_mint_c_with_vs(mint_c_file, mint_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [mint_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- mint-p command---

def run_mint_python_command(command):
    if isinstance(command, str):
        command = f"wsl -d mint {command}"

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

    try:
        process.wait()
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Process interrupted by user. Terminating...")
        process.terminate()


# --- fedora command---

def get_project_paths_fedora():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    fedora_cpp_file = os.path.join(terminal_dir, "run_fedora_command.cpp")
    fedora_exe_file = os.path.join(terminal_dir, "run_fedora_command.exe")
    return fedora_cpp_file, fedora_exe_file, terminal_dir


def compile_fedora_cpp_with_vs(fedora_cpp_file, fedora_exe_file):
    """
    Kompiliert run_fedora_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_fedora_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{fedora_cpp_file}" /Fe:"{fedora_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_fedora_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C++-Wrapper aus.

    Falls run_arch_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    fedora_cpp_file, fedora_exe_file, _ = get_project_paths_fedora()

    if not os.path.isfile(fedora_exe_file):
        if not compile_fedora_cpp_with_vs(fedora_cpp_file, fedora_exe_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [fedora_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- fedora-c command---

def get_project_paths_fedora_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    fedora_c_file = os.path.join(terminal_dir, "run_fedora_command.c")
    fedora_c_exe_file = os.path.join(terminal_dir, "run_fedora_c_command.exe")
    return fedora_c_file, fedora_c_exe_file, terminal_dir


def compile_fedora_c_with_vs(fedora_c_file, fedora_c_exe_file):
    """
    Kompiliert run_fedora_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_fedora_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{fedora_c_file}" /Fe:"{fedora_c_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_fedora_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_fedora_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    fedora_c_file, fedora_c_exe_file, _ = get_project_paths_fedora_c()

    if not os.path.isfile(fedora_c_exe_file):
        if not compile_fedora_c_with_vs(fedora_c_file, fedora_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [fedora_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- fedora-p command---

def run_fedora_python_command(command):
    if isinstance(command, str):
        command = f"wsl -d -d Fedora-Remix {command}"

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

    try:
        process.wait()
    except KeyboardInterrupt:
        process.terminate()


# --- redhat command---

def get_project_paths_redhat():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    redhat_cpp_file = os.path.join(terminal_dir, "run_redhat_command.cpp")
    redhat_exe_file = os.path.join(terminal_dir, "run_redhat_command.exe")
    return redhat_cpp_file, redhat_exe_file, terminal_dir


def compile_redhat_cpp_with_vs(redhat_cpp_file, redhat_exe_file):
    """
    Kompiliert run_redhat_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_redhat_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{redhat_cpp_file}" /Fe:"{redhat_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_redhat_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C++-Wrapper aus.

    Falls run_redhat_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    redhat_cpp_file, redhat_exe_file, _ = get_project_paths_redhat()

    if not os.path.isfile(redhat_exe_file):
        if not compile_redhat_cpp_with_vs(redhat_cpp_file, redhat_exe_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [redhat_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- redhat-c command---

def get_project_paths_redhat_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    redhat_c_file = os.path.join(terminal_dir, "run_redhat_command.c")
    redhat_c_exe_file = os.path.join(terminal_dir, "run_redhat_c_command.exe")
    return redhat_c_file, redhat_c_exe_file, terminal_dir


def compile_redhat_c_with_vs(redhat_c_file, redhat_c_exe_file):
    """
    Kompiliert run_redhat_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_redhat_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{redhat_c_file}" /Fe:"{redhat_c_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_redhat_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_redhat_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    redhat_c_file, redhat_c_exe_file, _ = get_project_paths_redhat_c()

    if not os.path.isfile(redhat_c_exe_file):
        if not compile_redhat_c_with_vs(redhat_c_file, redhat_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [redhat_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- redhat-p command---

def run_redhat_python_command(command):
    if isinstance(command, str):
        command = f"wsl -d RedHat {command}"

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

    try:
        process.wait()
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Process interrupted by user. Terminating...")
        process.terminate()


# --- sles command---

def get_project_paths_sles():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    sles_cpp_file = os.path.join(terminal_dir, "run_sles_command.cpp")
    sles_exe_file = os.path.join(terminal_dir, "run_sles_command.exe")
    return sles_cpp_file, sles_exe_file, terminal_dir


def compile_sles_cpp_with_vs(sles_cpp_file, sles_exe_file):
    """
    Kompiliert run_sles_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_sles_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{sles_cpp_file}" /Fe:"{sles_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_sles_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C++-Wrapper aus.

    Falls run_sles_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    sles_cpp_file, sles_exe_file, _ = get_project_paths_sles()

    if not os.path.isfile(sles_exe_file):
        if not compile_sles_cpp_with_vs(sles_cpp_file, sles_exe_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [sles_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- sles-c command---

def get_project_paths_sles_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    sles_c_file = os.path.join(terminal_dir, "run_sles_command.c")
    sles_c_exe_file = os.path.join(terminal_dir, "run_sles_c_command.exe")
    return sles_c_file, sles_c_exe_file, terminal_dir


def compile_sles_c_with_vs(sles_c_file, sles_c_exe_file):
    """
    Kompiliert run_sles_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_sles_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{sles_c_file}" /Fe:"{sles_c_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_sles_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_sles_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    sles_c_file, sles_c_exe_file, _ = get_project_paths_sles_c()

    if not os.path.isfile(sles_c_exe_file):
        if not compile_sles_c_with_vs(sles_c_file, sles_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [sles_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- sles-p command---

def run_sles_python_command(command):
    if isinstance(command, str):
        command = f"wsl -d SLES {command}"

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

    try:
        process.wait()
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Process interrupted by user. Terminating...")
        process.terminate()


# --- pengwin command---

def get_project_paths_pengwin():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    pengwin_cpp_file = os.path.join(terminal_dir, "run_pengwin_command.cpp")
    pengwin_exe_file = os.path.join(terminal_dir, "run_pengwin_command.exe")
    return pengwin_cpp_file, pengwin_exe_file, terminal_dir


def compile_pengwin_cpp_with_vs(pengwin_cpp_file, pengwin_exe_file):
    """
    Kompiliert run_pengwin_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_pengwin_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{pengwin_cpp_file}" /Fe:"{pengwin_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_pengwin_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C++-Wrapper aus.

    Falls run_pengwin_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    pengwin_cpp_file, pengwin_exe_file, _ = get_project_paths_pengwin()

    if not os.path.isfile(pengwin_exe_file):
        if not compile_pengwin_cpp_with_vs(pengwin_cpp_file, pengwin_exe_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [pengwin_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- pengwin-c command---

def get_project_paths_pengwin_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    pengwin_c_file = os.path.join(terminal_dir, "run_pengwin_command.c")
    pengwin_c_exe_file = os.path.join(terminal_dir, "run_pengwin_c_command.exe")
    return pengwin_c_file, pengwin_c_exe_file, terminal_dir


def compile_pengwin_c_with_vs(pengwin_c_file, pengwin_c_exe_file):
    """
    Kompiliert run_pengwin_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_pengwin_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{pengwin_c_file}" /Fe:"{pengwin_c_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_pengwin_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_pengwin_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    pengwin_c_file, pengwin_c_exe_file, _ = get_project_paths_pengwin_c()

    if not os.path.isfile(pengwin_c_exe_file):
        if not compile_pengwin_c_with_vs(pengwin_c_file, pengwin_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [pengwin_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- pengwin-p command---

def run_pengwin_python_command(command):
    if isinstance(command, str):
        command = f"wsl -d Pengwin {command}"

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

    try:
        process.wait()
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Process interrupted by user. Terminating...")
        process.terminate()


# --- oracle command---

def get_project_paths_oracle():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    oracle_cpp_file = os.path.join(terminal_dir, "run_oracle_command.cpp")
    oracle_exe_file = os.path.join(terminal_dir, "run_oracle_command.exe")
    return oracle_cpp_file, oracle_exe_file, terminal_dir


def compile_oracle_cpp_with_vs(oracle_cpp_file, oracle_exe_file):
    """
    Kompiliert run_oracle_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_oracle_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{oracle_cpp_file}" /Fe:"{oracle_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_oracle_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C++-Wrapper aus.

    Falls run_oracle_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    oracle_cpp_file, oracle_exe_file, _ = get_project_paths_oracle()

    if not os.path.isfile(oracle_exe_file):
        if not compile_oracle_cpp_with_vs(oracle_cpp_file, oracle_exe_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [oracle_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- oracle-c command---

def get_project_paths_oracle_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    oracle_c_file = os.path.join(terminal_dir, "run_oracle_command.c")
    oracle_c_exe_file = os.path.join(terminal_dir, "run_oracle_c_command.exe")
    return oracle_c_file, oracle_c_exe_file, terminal_dir


def compile_oracle_c_with_vs(oracle_c_file, oracle_c_exe_file):
    """
    Kompiliert run_oracle_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_oracle_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{oracle_c_file}" /Fe:"{oracle_c_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_oracle_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_oracle_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    oracle_c_file, oracle_c_exe_file, _ = get_project_paths_oracle_c()

    if not os.path.isfile(oracle_c_exe_file):
        if not compile_oracle_c_with_vs(oracle_c_file, oracle_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [oracle_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- oracle-p command---

def run_oracle_python_command(command):
    if isinstance(command, str):
        command = f"wsl -d OracleLinux {command}"

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

    try:
        process.wait()
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Process interrupted by user. Terminating...")
        process.terminate()


# --- alpine command---

def get_project_paths_alpine():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    alpine_cpp_file = os.path.join(terminal_dir, "run_alpine_command.cpp")
    alpine_exe_file = os.path.join(terminal_dir, "run_alpine_command.exe")
    return alpine_cpp_file, alpine_exe_file, terminal_dir


def compile_alpine_cpp_with_vs(alpine_cpp_file, alpine_exe_file):
    """
    Kompiliert run_alpine_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_alpine_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{alpine_cpp_file}" /Fe:"{alpine_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_alpine_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C++-Wrapper aus.

    Falls run_alpine_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    alpine_cpp_file, alpine_exe_file, _ = get_project_paths_alpine()

    if not os.path.isfile(alpine_exe_file):
        if not compile_alpine_cpp_with_vs(alpine_cpp_file, alpine_exe_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [alpine_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- alpine-c command---

def get_project_paths_alpine_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    alpine_c_file = os.path.join(terminal_dir, "run_alpine_command.c")
    alpine_c_exe_file = os.path.join(terminal_dir, "run_alpine_c_command.exe")
    return alpine_c_file, alpine_c_exe_file, terminal_dir


def compile_alpine_c_with_vs(alpine_c_file, alpine_c_exe_file):
    """
    Kompiliert run_alpine_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_alpine_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{alpine_c_file}" /Fe:"{alpine_c_exe_file}"'

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_alpine_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_alpine_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    alpine_c_file, alpine_c_exe_file, _ = get_project_paths_alpine_c()

    if not os.path.isfile(alpine_c_exe_file):
        if not compile_alpine_c_with_vs(alpine_c_file, alpine_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [alpine_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- alpine-p command---

def run_alpine_python_command(command):
    if isinstance(command, str):
        command = f"wsl -d Alpine {command}"

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

    try:
        process.wait()
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Process interrupted by user. Terminating...")
        process.terminate()


# --- clear command---

def get_project_paths_clear():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C++-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    clear_cpp_file = os.path.join(terminal_dir, "run_clear_command.cpp")
    clear_exe_file = os.path.join(terminal_dir, "run_clear_command.exe")
    return clear_cpp_file, clear_exe_file, terminal_dir


def compile_clear_cpp_with_vs(clear_cpp_file, clear_exe_file):
    """
    Kompiliert run_clear_command.cpp mit cl.exe über die Visual Studio-Umgebung.
    Die Ausgabe wird im UTF-8 Format eingelesen – ungültige Zeichen werden ersetzt.
    """
    logging.info("[INFO] Compile run_clear_command.cpp with the MSVC compiler from Visual Studio...")
    vcvarsall = find_vcvarsall()
    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe /EHsc "{clear_cpp_file}" /Fe:"{clear_exe_file}"'

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_clear_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C++-Wrapper aus.

    Falls run_clear_command.exe noch nicht existiert, wird das C++-Programm kompiliert.
    Der C++-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    clear_cpp_file, clear_exe_file, _ = get_project_paths_clear()

    if not os.path.isfile(clear_exe_file):
        if not compile_clear_cpp_with_vs(clear_cpp_file, clear_exe_file):
            logging.error("[ERROR] Abort: C++ compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C++-Code
    cmd = [clear_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C++-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- clear-c command---

def get_project_paths_clear_c():
    """
    Ermittelt das P-terminal-Projektverzeichnis, den Ordner 'p-terminal',
    sowie die Pfade zur C-Quelle und zur Executable.
    """
    username = getpass.getuser()
    base_dir = os.path.join("C:\\Users", username, "p-terminal", "pp-term")
    terminal_dir = os.path.join(base_dir, "pp-commands")
    clear_c_file = os.path.join(terminal_dir, "run_clear_command.c")
    clear_c_exe_file = os.path.join(terminal_dir, "run_clear_c_command.exe")
    return clear_c_file, clear_c_exe_file, terminal_dir


def compile_clear_c_with_vs(clear_c_file, clear_c_exe_file):
    """
    Kompiliert run_clear_command.c mit cl.exe über die Visual Studio-Umgebung.
    """
    logging.info("[INFO] Compiling run_clear_command.c with Visual Studio...")
    vcvarsall = find_vcvarsall_c()

    # Initialisiere die VS-Umgebung (x64) und rufe cl.exe auf
    command = f'"{vcvarsall}" x64 && cl.exe "{clear_c_file}" /Fe:"{clear_c_exe_file}"'

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        encoding="utf-8",
        errors="replace"
    )

    if result.returncode != 0:
        logging.error("[ERROR] Compilation failed.")
        logging.error(result.stdout)
        logging.error(result.stderr)
        return False

    logging.info("[INFO] Compilation successful.")
    return True


def run_clear_c_command(command):
    """
    Führt einen Linux-Befehl interaktiv über den C-Wrapper aus.

    Falls run_clear_command.exe noch nicht existiert, wird das C-Programm kompiliert.
    Der C-Code öffnet dann ein neues Terminalfenster, in dem WSL interaktiv gestartet wird.
    """
    clear_c_file, clear_c_exe_file, _ = get_project_paths_clear_c()

    if not os.path.isfile(clear_c_exe_file):
        if not compile_clear_c_with_vs(clear_c_file, clear_c_exe_file):
            logging.error("[ERROR] Abort: C compilation was unsuccessful.")
            return

    # Erstelle die Befehlsliste. Bei mehreren Argumenten werden diese getrennt übertragen.
    if isinstance(command, str):
        # Zerlege die Eingabe (z.B. "nano test.py") in Parameter, falls möglich
        args = command.split()  # Achtung: Bei komplexen Befehlen mit Leerzeichen evtl. anders behandeln!
    else:
        args = command

    # Baue die Kommandozeile, ohne zusätzliche Anführungszeichen – das übernimmt der C-Code
    cmd = [clear_c_exe_file] + args

    try:
        logging.info(f"[INFO] Execute: {' '.join(cmd)}")
        # Der C-Wrapper startet ein neues Terminalfenster, in dem der Befehl interaktiv ausgeführt wird.
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"[ERROR] Command failed: {e}")
    except KeyboardInterrupt:
        logging.warning("[WARNING] Cancellation by user.")


# --- clear-p command---

def run_clear_python_command(command):
    if isinstance(command, str):
        command = f"wsl -d ClearLinux {command}"

    print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")

    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, shell=True, text=True)

    try:
        process.wait()
    except KeyboardInterrupt:
        print(f"[{timestamp()}] [INFO] Process interrupted by user. Terminating...")
        process.terminate()


def run_scoop_command(
        command: Union[str, List[str]],
        timeout: Optional[int] = None,
        capture_output: bool = False,
        retries: int = 2,
        retry_delay: float = 1.0,
        logger: Optional[logging.Logger] = None
) -> subprocess.CompletedProcess:
    """
    Führt einen Scoop-Befehl aus – superschnell, stabil und mit robustem Logger-Fallback.

    Argumente:
    Befehl: Scoop-Befehl als String oder Liste.
    Timeout: Maximale Laufzeit in Sekunden.
    Capture_Output: Gibt stdout/stderr zurück, wenn True.
    Retrys: Anzahl der Wiederholungsversuche bei Exit-Fehlern.
    Retry_Delay: Basisverzögerung (Sekunden) für exponentielles Backoff.
    Logger: Optionaler Logger; falls keiner, wird ein Standard-Logger konfiguriert.

    Rückgabewert:
    subprocess.CompletedProcess mit .stdout/.stderr, wenn capture_output.

    Löst aus:
    RuntimeError: Wenn scoop.exe nicht gefunden wird.
    subprocess.CalledProcessError: Bei Exit-Code ≠ 0 (nach Wiederholungsversuchen).
    subprocess.TimeoutExpired: Bei Timeout.
    KeyboardInterrupt: Bei Benutzerunterbrechung.
    """
    # Logger-Fallback und -Konfiguration
    if logger is None:
        logger = logging.getLogger("run_scoop_command")
    if not logger.handlers:
        # Wenn kein Handler vorhanden ist: Standard-Stream-Handler hinzufügen
        handler = logging.StreamHandler()
        fmt = logging.Formatter("[%(asctime)s] [%(levelname)s] %(name)s: %(message)s")
        handler.setFormatter(fmt)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)

    # Zwischenspeichern des Scoop-Pfads
    if not hasattr(run_scoop_command, "_scoop_path"):
        path = shutil.which("scoop")
        if not path:
            msg = "Scoop not found – please install and check PATH."
            logger.error(msg)
            raise RuntimeError(msg)
        run_scoop_command._scoop_path = path
    scoop_path = run_scoop_command._scoop_path

    # Tokenisierung
    args = command if isinstance(command, list) else shlex.split(command)
    cmd = [scoop_path] + args

    logger.debug(f"Starting Scoop: {' '.join(cmd)} (timeout={timeout}, retries={retries})")

    # Ausführung mit Wiederholungsversuchen
    attempt = 0
    while True:
        attempt += 1
        try:
            start = time.perf_counter()
            result = subprocess.run(
                cmd,
                shell=False,
                stdout=subprocess.PIPE if capture_output else None,
                stderr=subprocess.PIPE if capture_output else None,
                text=True,
                timeout=timeout,
                check=True
            )
            duration = time.perf_counter() - start
            logger.info(f"Scoop succeeded in {duration:.2f}s (attempt {attempt})")
            return result

        except subprocess.CalledProcessError as e:
            stderr = (e.stderr or "").strip() or "<no stderr>"
            logger.error(f"Exit code {e.returncode} (attempt {attempt}): {stderr}")
            if attempt <= retries:
                wait = retry_delay * (2 ** (attempt - 1))
                logger.warning(f"Retrying in {wait:.1f}s…")
                time.sleep(wait)
                continue
            raise  # Nach Wiederholungsversuchen den CalledProcessError weitergeben

        except subprocess.TimeoutExpired as e:
            logger.error(f"Timeout after {timeout}s (attempt {attempt})")
            raise

        except KeyboardInterrupt:
            logger.warning("Aborted by user")
            raise


def run_choco_command(
        command: Union[str, List[str]],
        timeout: Optional[int] = None,
        capture_output: bool = False,
        retries: int = 2,
        retry_delay: float = 1.0,
        logger: Optional[logging.Logger] = None
) -> subprocess.CompletedProcess:
    """
    Führt einen Chocolatey-Befehl aus – superschnell, stabil und mit robustem Logger-Fallback.

    Argumente:
    command: Chocolatey-Befehl als String oder Liste.
    timeout: Maximale Laufzeit in Sekunden.
    capture_output: Gibt stdout und stderr zurück, wenn True.
    retries: Anzahl der Wiederholungsversuche bei Exit-Fehlern.
    retry_delay: Basisverzögerung (in Sekunden) für exponentielles Backoff.
    logger: Optionaler Logger; falls keiner, wird ein Standard-Logger konfiguriert.

    Rückgabewert:
    subprocess.CompletedProcess mit .stdout und .stderr (wenn capture_output True ist).

    Löst aus:
    RuntimeError: Wenn choco.exe nicht gefunden wird.
    subprocess.CalledProcessError: Bei Exit-Code ≠ 0 (nach Wiederholungsversuchen).
    subprocess.TimeoutExpired: Bei Timeout.
    KeyboardInterrupt: Bei Benutzerunterbrechung.
    """
    # Logger-Fallback und -Konfiguration
    if logger is None:
        logger = logging.getLogger("run_choco_command")
    if not logger.handlers:
        # Standard-Stream-Handler hinzufügen, falls keiner vorhanden ist
        handler = logging.StreamHandler()
        fmt = logging.Formatter("[%(asctime)s] [%(levelname)s] %(name)s: %(message)s")
        handler.setFormatter(fmt)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)

    # Zwischenspeichern des Choco-Pfads
    if not hasattr(run_choco_command, "_choco_path"):
        path = shutil.which("choco")
        if not path:
            msg = "Chocolatey (choco) not found – please install and check PATH."
            logger.error(msg)
            raise RuntimeError(msg)
        run_choco_command._choco_path = path
    choco_path = run_choco_command._choco_path

    # --- Tokenizing the command ---
    args = command if isinstance(command, list) else shlex.split(command)
    cmd = [choco_path] + args

    logger.debug(f"Starting Chocolatey: {' '.join(cmd)} (timeout={timeout}, retries={retries})")

    # Ausführung mit Wiederholungsversuchen
    attempt = 0
    while True:
        attempt += 1
        try:
            start = time.perf_counter()
            result = subprocess.run(
                cmd,
                shell=False,
                stdout=subprocess.PIPE if capture_output else None,
                stderr=subprocess.PIPE if capture_output else None,
                text=True,
                timeout=timeout,
                check=True
            )
            duration = time.perf_counter() - start
            logger.info(f"Chocolatey succeeded in {duration:.2f}s (attempt {attempt})")
            return result

        except subprocess.CalledProcessError as e:
            stderr = (e.stderr or "").strip() or "<no stderr>"
            logger.error(f"Exit code {e.returncode} (attempt {attempt}): {stderr}")
            if attempt <= retries:
                wait = retry_delay * (2 ** (attempt - 1))
                logger.warning(f"Retrying in {wait:.1f}s…")
                time.sleep(wait)
                continue
            raise  # Fehler nach Wiederholungsversuchen weitergeben

        except subprocess.TimeoutExpired as e:
            logger.error(f"Timeout after {timeout}s (attempt {attempt})")
            raise

        except KeyboardInterrupt:
            logger.warning("Aborted by user")
            raise


def run_winget_command(
        command: Union[str, List[str]],
        timeout: Optional[int] = None,
        capture_output: bool = False,
        retries: int = 2,
        retry_delay: float = 1.0,
        logger: Optional[logging.Logger] = None
) -> subprocess.CompletedProcess:
    """
    Führt einen Winget-Befehl aus – superschnell, stabil und mit robustem Logger-Fallback.

    Argumente:
    command: Winget-Befehl als String oder Liste.
    timeout: Maximale Laufzeit in Sekunden.
    capture_output: Gibt stdout und stderr zurück, wenn True.
    retries: Anzahl der Wiederholungsversuche bei Exit-Fehlern.
    retry_delay: Basisverzögerung (in Sekunden) für exponentielles Backoff.
    logger: Optionaler Logger; falls keiner, wird ein Standard-Logger konfiguriert.

    Rückgabewert:
    subprocess.CompletedProcess mit .stdout und .stderr (wenn capture_output True ist).

    Löst aus:
    RuntimeError: Wenn Winget nicht gefunden wird.
    subprocess.CalledProcessError: Bei Exit-Code ≠ 0 (nach Wiederholungsversuchen).
    subprocess.TimeoutExpired: Bei Timeout.
    KeyboardInterrupt: Bei Benutzerunterbrechung.
    """
    # Logger-Fallback und -Konfiguration
    if logger is None:
        logger = logging.getLogger("run_winget_command")
    if not logger.handlers:
        handler = logging.StreamHandler()
        fmt = logging.Formatter("[%(asctime)s] [%(levelname)s] %(name)s: %(message)s")
        handler.setFormatter(fmt)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)

    # Zwischenspeichern des Winget-Pfads
    if not hasattr(run_winget_command, "_winget_path"):
        path = shutil.which("winget")
        if not path:
            msg = "winget not found – please install and check PATH."
            logger.error(msg)
            raise RuntimeError(msg)
        run_winget_command._winget_path = path
    winget_path = run_winget_command._winget_path

    # Tokenisieren des Befehls
    args = command if isinstance(command, list) else shlex.split(command)
    cmd = [winget_path] + args

    logger.debug(f"Starting winget: {' '.join(cmd)} (timeout={timeout}, retries={retries})")

    # Ausführung mit Wiederholungsversuchen
    attempt = 0
    while True:
        attempt += 1
        try:
            start = time.perf_counter()
            result = subprocess.run(
                cmd,
                shell=False,
                stdout=subprocess.PIPE if capture_output else None,
                stderr=subprocess.PIPE if capture_output else None,
                text=True,
                timeout=timeout,
                check=True
            )
            duration = time.perf_counter() - start
            logger.info(f"winget succeeded in {duration:.2f}s (attempt {attempt})")
            return result

        except subprocess.CalledProcessError as e:
            stderr = (e.stderr or "").strip() or "<no stderr>"
            logger.error(f"Exit code {e.returncode} (attempt {attempt}): {stderr}")
            if attempt <= retries:
                wait = retry_delay * (2 ** (attempt - 1))
                logger.warning(f"Retrying in {wait:.1f}s…")
                time.sleep(wait)
                continue
            raise  # Fehler nach Wiederholungsversuchen weitergeben

        except subprocess.TimeoutExpired as e:
            logger.error(f"Timeout after {timeout}s (attempt {attempt})")
            raise

        except KeyboardInterrupt:
            logger.warning("Aborted by user")
            raise


def run_ninite_command(
        command: Union[str, List[str]],
        timeout: Optional[int] = None,
        capture_output: bool = False,
        retries: int = 2,
        retry_delay: float = 1.0,
        logger: Optional[logging.Logger] = None
) -> subprocess.CompletedProcess:
    """
    Führt einen Ninite-Befehl aus – superschnell, stabil und mit robustem Logger-Fallback.

    Argumente:
    command: Ninite-Befehl als String oder Liste.
    timeout: Maximale Laufzeit in Sekunden.
    capture_output: Gibt stdout/stderr zurück, wenn True.
    retries: Anzahl der Wiederholungsversuche bei Exit-Fehlern.
    retry_delay: Basisverzögerung (Sekunden) für exponentielles Backoff.
    logger: Optionaler Logger; falls keiner, wird ein Standard-Logger konfiguriert.

    Rückgabewert:
    subprocess.CompletedProcess mit .stdout/.stderr, wenn capture_output.

    Löst aus:
    RuntimeError: Wenn ninite.exe nicht gefunden wird.
    subprocess.CalledProcessError: Bei Exit-Code ≠ 0 (nach Wiederholungsversuchen).
    subprocess.TimeoutExpired: Bei Timeout.
    KeyboardInterrupt: Bei Benutzerunterbrechung.
    """
    # Logger-Fallback und -Konfiguration
    if logger is None:
        logger = logging.getLogger("run_ninite_command")
    if not logger.handlers:
        handler = logging.StreamHandler()
        fmt = logging.Formatter("[%(asctime)s] [%(levelname)s] %(name)s: %(message)s")
        handler.setFormatter(fmt)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)

    # Zwischenspeichern des Ninite-Pfads
    if not hasattr(run_ninite_command, "_ninite_path"):
        path = shutil.which("ninite")
        if not path:
            msg = "Ninite not found – please install and check PATH."
            logger.error(msg)
            raise RuntimeError(msg)
        run_ninite_command._ninite_path = path
    ninite_path = run_ninite_command._ninite_path

    # Tokenisierung
    args = command if isinstance(command, list) else shlex.split(command)
    cmd = [ninite_path] + args

    logger.debug(f"Starting Ninite: {' '.join(cmd)} (timeout={timeout}, retries={retries})")

    # Ausführung mit Wiederholungsversuchen
    attempt = 0
    while True:
        attempt += 1
        try:
            start = time.perf_counter()
            result = subprocess.run(
                cmd,
                shell=False,
                stdout=subprocess.PIPE if capture_output else None,
                stderr=subprocess.PIPE if capture_output else None,
                text=True,
                timeout=timeout,
                check=True
            )
            duration = time.perf_counter() - start
            logger.info(f"Ninite succeeded in {duration:.2f}s (attempt {attempt})")
            return result

        except subprocess.CalledProcessError as e:
            stderr = (e.stderr or "").strip() or "<no stderr>"
            logger.error(f"Exit code {e.returncode} (attempt {attempt}): {stderr}")
            if attempt <= retries:
                wait = retry_delay * (2 ** (attempt - 1))
                logger.warning(f"Retrying in {wait:.1f}s…")
                time.sleep(wait)
                continue
            raise

        except subprocess.TimeoutExpired as e:
            logger.error(f"Timeout after {timeout}s (attempt {attempt})")
            raise

        except KeyboardInterrupt:
            logger.warning("Aborted by user")
            raise


def run_justinstall_command(
        command: Union[str, List[str]],
        timeout: Optional[int] = None,
        capture_output: bool = False,
        retries: int = 2,
        retry_delay: float = 1.0,
        logger: Optional[logging.Logger] = None
) -> subprocess.CompletedProcess:
    """
    Führt einen Just-Install-Befehl aus – superschnell, stabil und mit robustem Logger-Fallback.

    Argumente:
    command: Just-Install-Befehl als String oder Liste.
    timeout: Maximale Laufzeit in Sekunden.
    capture_output: Gibt stdout/stderr zurück, wenn True.
    retries: Anzahl der Wiederholungsversuche bei Exit-Fehlern.
    retry_delay: Basisverzögerung (Sekunden) für exponentielles Backoff.
    logger: Optionaler Logger; falls keiner, wird ein Standard-Logger konfiguriert.

    Rückgabewert:
    subprocess.CompletedProcess mit .stdout/.stderr, wenn capture_output.

    Löst aus:
    RuntimeError: Wenn just-install.exe nicht gefunden wird.
    subprocess.CalledProcessError: Bei Exit-Code ≠ 0 (nach Wiederholungsversuchen).
    subprocess.TimeoutExpired: Bei Timeout.
    KeyboardInterrupt: Bei Benutzerunterbrechung.
    """
    # Logger-Fallback und -Konfiguration
    if logger is None:
        logger = logging.getLogger("run_justinstall_command")
    if not logger.handlers:
        handler = logging.StreamHandler()
        fmt = logging.Formatter("[%(asctime)s] [%(levelname)s] %(name)s: %(message)s")
        handler.setFormatter(fmt)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)

    # Zwischenspeichern des Just-Install-Pfads
    if not hasattr(run_justinstall_command, "_justinstall_path"):
        path = shutil.which("just-install")
        if not path:
            msg = "Just-Install not found – please install and check PATH."
            logger.error(msg)
            raise RuntimeError(msg)
        run_justinstall_command._justinstall_path = path
    justinstall_path = run_justinstall_command._justinstall_path

    # Tokenisierung
    args = command if isinstance(command, list) else shlex.split(command)
    cmd = [justinstall_path] + args

    logger.debug(f"Starting Just-Install: {' '.join(cmd)} (timeout={timeout}, retries={retries})")

    # Ausführung mit Wiederholungsversuchen
    attempt = 0
    while True:
        attempt += 1
        try:
            start = time.perf_counter()
            result = subprocess.run(
                cmd,
                shell=False,
                stdout=subprocess.PIPE if capture_output else None,
                stderr=subprocess.PIPE if capture_output else None,
                text=True,
                timeout=timeout,
                check=True
            )
            duration = time.perf_counter() - start
            logger.info(f"Just-Install succeeded in {duration:.2f}s (attempt {attempt})")
            return result

        except subprocess.CalledProcessError as e:
            stderr = (e.stderr or "").strip() or "<no stderr>"
            logger.error(f"Exit code {e.returncode} (attempt {attempt}): {stderr}")
            if attempt <= retries:
                wait = retry_delay * (2 ** (attempt - 1))
                logger.warning(f"Retrying in {wait:.1f}s…")
                time.sleep(wait)
                continue
            raise

        except subprocess.TimeoutExpired as e:
            logger.error(f"Timeout after {timeout}s (attempt {attempt})")
            raise

        except KeyboardInterrupt:
            logger.warning("Aborted by user")
            raise


def run_oneget_command(
        command: Union[str, List[str]],
        timeout: Optional[int] = None,
        capture_output: bool = False,
        retries: int = 2,
        retry_delay: float = 1.0,
        logger: Optional[logging.Logger] = None
) -> subprocess.CompletedProcess:
    """
    Führt einen OneGet-Befehl aus – superschnell, stabil und mit robustem Logger-Fallback.

    Argumente:
    command: OneGet/PackageManagement-Befehl als String oder Liste.
    timeout: Maximale Laufzeit in Sekunden.
    capture_output: Gibt stdout/stderr zurück, wenn True.
    retries: Anzahl der Wiederholungsversuche bei Exit-Fehlern.
    retry_delay: Basisverzögerung (Sekunden) für exponentielles Backoff.
    logger: Optionaler Logger; falls keiner, wird ein Standard-Logger konfiguriert.

    Rückgabewert:
    subprocess.CompletedProcess mit .stdout/.stderr, wenn capture_output.

    Löst aus:
    RuntimeError: Wenn oneget/PackageManagement nicht gefunden wird.
    subprocess.CalledProcessError: Bei Exit-Code ≠ 0 (nach Wiederholungsversuchen).
    subprocess.TimeoutExpired: Bei Timeout.
    KeyboardInterrupt: Bei Benutzerunterbrechung.
    """
    # Logger-Fallback und -Konfiguration
    if logger is None:
        logger = logging.getLogger("run_oneget_command")
    if not logger.handlers:
        handler = logging.StreamHandler()
        fmt = logging.Formatter("[%(asctime)s] [%(levelname)s] %(name)s: %(message)s")
        handler.setFormatter(fmt)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)

    # Zwischenspeichern des OneGet-Pfads (PowerShell erforderlich)
    if not hasattr(run_oneget_command, "_powershell_path"):
        path = shutil.which("powershell")
        if not path:
            msg = "PowerShell not found – please install and check PATH."
            logger.error(msg)
            raise RuntimeError(msg)
        run_oneget_command._powershell_path = path
    powershell_path = run_oneget_command._powershell_path

    # Tokenisierung und Befehlszusammenbau
    # OneGet läuft als PowerShell-Modul, daher wird das Kommando als PowerShell-Argument übergeben
    ps_command = command if isinstance(command, str) else " ".join(command)
    # Sicherstellen, dass das Kommando in Anführungszeichen ist, falls nötig
    ps_args = [
        powershell_path,
        "-NoProfile",
        "-NonInteractive",
        "-Command",
        ps_command
    ]

    logger.debug(f"Starting OneGet: {' '.join(ps_args)} (timeout={timeout}, retries={retries})")

    # Ausführung mit Wiederholungsversuchen
    attempt = 0
    while True:
        attempt += 1
        try:
            start = time.perf_counter()
            result = subprocess.run(
                ps_args,
                shell=False,
                stdout=subprocess.PIPE if capture_output else None,
                stderr=subprocess.PIPE if capture_output else None,
                text=True,
                timeout=timeout,
                check=True
            )
            duration = time.perf_counter() - start
            logger.info(f"OneGet succeeded in {duration:.2f}s (attempt {attempt})")
            return result

        except subprocess.CalledProcessError as e:
            stderr = (e.stderr or "").strip() or "<no stderr>"
            logger.error(f"Exit code {e.returncode} (attempt {attempt}): {stderr}")
            if attempt <= retries:
                wait = retry_delay * (2 ** (attempt - 1))
                logger.warning(f"Retrying in {wait:.1f}s…")
                time.sleep(wait)
                continue
            raise

        except subprocess.TimeoutExpired as e:
            logger.error(f"Timeout after {timeout}s (attempt {attempt})")
            raise

        except KeyboardInterrupt:
            logger.warning("Aborted by user")
            raise


def run_boxstarter_command(
        command: Union[str, List[str]],
        timeout: Optional[int] = None,
        capture_output: bool = False,
        retries: int = 2,
        retry_delay: float = 1.0,
        logger: Optional[logging.Logger] = None
) -> subprocess.CompletedProcess:
    """
    Führt einen Boxstarter-Befehl aus – superschnell, stabil und mit robustem Logger-Fallback.

    Argumente:
    command: Boxstarter-Befehl als String oder Liste.
    timeout: Maximale Laufzeit in Sekunden.
    capture_output: Gibt stdout/stderr zurück, wenn True.
    retries: Anzahl der Wiederholungsversuche bei Exit-Fehlern.
    retry_delay: Basisverzögerung (Sekunden) für exponentielles Backoff.
    logger: Optionaler Logger; falls keiner, wird ein Standard-Logger konfiguriert.

    Rückgabewert:
    subprocess.CompletedProcess mit .stdout/.stderr, wenn capture_output.

    Löst aus:
    RuntimeError: Wenn Boxstarter (BoxstarterShell) nicht gefunden wird.
    subprocess.CalledProcessError: Bei Exit-Code ≠ 0 (nach Wiederholungsversuchen).
    subprocess.TimeoutExpired: Bei Timeout.
    KeyboardInterrupt: Bei Benutzerunterbrechung.
    """
    # Logger-Fallback und -Konfiguration
    if logger is None:
        logger = logging.getLogger("run_boxstarter_command")
    if not logger.handlers:
        handler = logging.StreamHandler()
        fmt = logging.Formatter("[%(asctime)s] [%(levelname)s] %(name)s: %(message)s")
        handler.setFormatter(fmt)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)

    # Zwischenspeichern des PowerShell-Pfads (Boxstarter ist ein PowerShell-Modul)
    if not hasattr(run_boxstarter_command, "_powershell_path"):
        path = shutil.which("powershell")
        if not path:
            msg = "PowerShell not found – please install and check PATH."
            logger.error(msg)
            raise RuntimeError(msg)
        run_boxstarter_command._powershell_path = path
    powershell_path = run_boxstarter_command._powershell_path

    # Tokenisierung und Befehlskonstruktion
    # Boxstarter läuft als PowerShell-Modul, daher: Import-Module und dann Befehl ausführen
    box_command = command if isinstance(command, str) else " ".join(command)
    ps_command = f"Import-Module -Name Boxstarter; {box_command}"

    ps_args = [
        powershell_path,
        "-NoProfile",
        "-NonInteractive",
        "-Command",
        ps_command
    ]

    logger.debug(f"Starting Boxstarter: {' '.join(ps_args)} (timeout={timeout}, retries={retries})")

    # Ausführung mit Wiederholungsversuchen
    attempt = 0
    while True:
        attempt += 1
        try:
            start = time.perf_counter()
            result = subprocess.run(
                ps_args,
                shell=False,
                stdout=subprocess.PIPE if capture_output else None,
                stderr=subprocess.PIPE if capture_output else None,
                text=True,
                timeout=timeout,
                check=True
            )
            duration = time.perf_counter() - start
            logger.info(f"Boxstarter succeeded in {duration:.2f}s (attempt {attempt})")
            return result

        except subprocess.CalledProcessError as e:
            stderr = (e.stderr or "").strip() or "<no stderr>"
            logger.error(f"Exit code {e.returncode} (attempt {attempt}): {stderr}")
            if attempt <= retries:
                wait = retry_delay * (2 ** (attempt - 1))
                logger.warning(f"Retrying in {wait:.1f}s…")
                time.sleep(wait)
                continue
            raise

        except subprocess.TimeoutExpired as e:
            logger.error(f"Timeout after {timeout}s (attempt {attempt})")
            raise

        except KeyboardInterrupt:
            logger.warning("Aborted by user")
            raise


def run_npackd_command(
        command: Union[str, List[str]],
        timeout: Optional[int] = None,
        capture_output: bool = False,
        retries: int = 2,
        retry_delay: float = 1.0,
        logger: Optional[logging.Logger] = None
) -> subprocess.CompletedProcess:
    """
    Führt einen Npackd-Befehl aus – superschnell, stabil und mit robustem Logger-Fallback.

    Argumente:
    command: NpackdCL-Befehl als String oder Liste.
    timeout: Maximale Laufzeit in Sekunden.
    capture_output: Gibt stdout/stderr zurück, wenn True.
    retries: Anzahl der Wiederholungsversuche bei Exit-Fehlern.
    retry_delay: Basisverzögerung (Sekunden) für exponentielles Backoff.
    logger: Optionaler Logger; falls keiner, wird ein Standard-Logger konfiguriert.

    Rückgabewert:
    subprocess.CompletedProcess mit .stdout/.stderr, wenn capture_output.

    Löst aus:
    RuntimeError: Wenn NpackdCL.exe nicht gefunden wird.
    subprocess.CalledProcessError: Bei Exit-Code ≠ 0 (nach Wiederholungsversuchen).
    subprocess.TimeoutExpired: Bei Timeout.
    KeyboardInterrupt: Bei Benutzerunterbrechung.
    """
    # Logger-Fallback und -Konfiguration
    if logger is None:
        logger = logging.getLogger("run_npackd_command")
    if not logger.handlers:
        handler = logging.StreamHandler()
        fmt = logging.Formatter("[%(asctime)s] [%(levelname)s] %(name)s: %(message)s")
        handler.setFormatter(fmt)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)

    # Zwischenspeichern des NpackdCL-Pfads
    if not hasattr(run_npackd_command, "_npackdcl_path"):
        path = shutil.which("NpackdCL") or shutil.which("npackdcl")
        if not path:
            msg = "NpackdCL.exe not found – please install and check PATH."
            logger.error(msg)
            raise RuntimeError(msg)
        run_npackd_command._npackdcl_path = path
    npackdcl_path = run_npackd_command._npackdcl_path

    # Tokenisierung
    args = command if isinstance(command, list) else shlex.split(command)
    cmd = [npackdcl_path] + args

    logger.debug(f"Starting Npackd: {' '.join(cmd)} (timeout={timeout}, retries={retries})")

    # Ausführung mit Wiederholungsversuchen
    attempt = 0
    while True:
        attempt += 1
        try:
            start = time.perf_counter()
            result = subprocess.run(
                cmd,
                shell=False,
                stdout=subprocess.PIPE if capture_output else None,
                stderr=subprocess.PIPE if capture_output else None,
                text=True,
                timeout=timeout,
                check=True
            )
            duration = time.perf_counter() - start
            logger.info(f"Npackd succeeded in {duration:.2f}s (attempt {attempt})")
            return result

        except subprocess.CalledProcessError as e:
            stderr = (e.stderr or "").strip() or "<no stderr>"
            logger.error(f"Exit code {e.returncode} (attempt {attempt}): {stderr}")
            if attempt <= retries:
                wait = retry_delay * (2 ** (attempt - 1))
                logger.warning(f"Retrying in {wait:.1f}s…")
                time.sleep(wait)
                continue
            raise

        except subprocess.TimeoutExpired as e:
            logger.error(f"Timeout after {timeout}s (attempt {attempt})")
            raise

        except KeyboardInterrupt:
            logger.warning("Aborted by user")
            raise


def run_zero_install_command(
        command: Union[str, List[str]],
        timeout: Optional[int] = None,
        capture_output: bool = False,
        retries: int = 2,
        retry_delay: float = 1.0,
        logger: Optional[logging.Logger] = None
) -> subprocess.CompletedProcess:
    """
    Führt einen Zero Install (0install)-Befehl aus – stabil, performant, mit Wiederholungslogik und Logging.

    Argumente:
    Befehl: 0install-Befehl als String oder Liste.
    Timeout: Maximale Ausführungszeit in Sekunden.
    Capture_Output: Wenn True, werden stdout/stderr erfasst.
    Retrys: Anzahl der Wiederholungen bei Fehlern.
    Retry_Delay: Anfangsverzögerung für Backoff (Sekunden).
    Logger: Optionaler Logger; bei None wird ein Standardlogger genutzt.

    Rückgabewert:
    subprocess.CompletedProcess – enthält stdout/stderr bei Bedarf.

    Löst aus:
    RuntimeError: Wenn 0install nicht gefunden wird.
    subprocess.CalledProcessError: Wenn der Befehl mit Fehlercode endet.
    subprocess.TimeoutExpired: Wenn ein Timeout erreicht wird.
    KeyboardInterrupt: Bei Benutzerunterbrechung.
    """
    if logger is None:
        logger = logging.getLogger("run_zero_install_command")
    if not logger.handlers:
        handler = logging.StreamHandler()
        fmt = logging.Formatter("[%(asctime)s] [%(levelname)s] %(name)s: %(message)s")
        handler.setFormatter(fmt)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)

    # Suche und Cache von 0install
    if not hasattr(run_zero_install_command, "_zinst_path"):
        path = shutil.which("0install")
        if not path:
            msg = "Zero Install (0install) not found – please install and ensure it's in PATH."
            logger.error(msg)
            raise RuntimeError(msg)
        run_zero_install_command._zinst_path = path
    zinst_path = run_zero_install_command._zinst_path

    # Kommando parsen
    args = command if isinstance(command, list) else shlex.split(command)
    cmd = [zinst_path] + args

    logger.debug(f"Running Zero Install: {' '.join(cmd)} (timeout={timeout}, retries={retries})")

    attempt = 0
    while True:
        attempt += 1
        try:
            start = time.perf_counter()
            result = subprocess.run(
                cmd,
                shell=False,
                stdout=subprocess.PIPE if capture_output else None,
                stderr=subprocess.PIPE if capture_output else None,
                text=True,
                timeout=timeout,
                check=True
            )
            duration = time.perf_counter() - start
            logger.info(f"Zero Install succeeded in {duration:.2f}s (attempt {attempt})")
            return result

        except subprocess.CalledProcessError as e:
            stderr = (e.stderr or "").strip() or "<no stderr>"
            logger.error(f"Exit code {e.returncode} (attempt {attempt}): {stderr}")
            if attempt <= retries:
                wait = retry_delay * (2 ** (attempt - 1))
                logger.warning(f"Retrying in {wait:.1f}s…")
                time.sleep(wait)
                continue
            raise

        except subprocess.TimeoutExpired:
            logger.error(f"Timeout after {timeout}s (attempt {attempt})")
            raise

        except KeyboardInterrupt:
            logger.warning("Aborted by user")
            raise


def run_appget_command(
        command: Union[str, List[str]],
        timeout: Optional[int] = None,
        capture_output: bool = False,
        retries: int = 2,
        retry_delay: float = 1.0,
        logger: Optional[logging.Logger] = None
) -> subprocess.CompletedProcess:
    """
    Führt einen AppGet-Befehl aus – superschnell, stabil und mit robustem Logger-Fallback.

    Argumente:
    command: AppGet-Befehl als String oder Liste.
    timeout: Maximale Laufzeit in Sekunden.
    capture_output: Gibt stdout/stderr zurück, wenn True.
    retries: Anzahl der Wiederholungsversuche bei Exit-Fehlern.
    retry_delay: Basisverzögerung (Sekunden) für exponentielles Backoff.
    logger: Optionaler Logger; falls keiner, wird ein Standard-Logger konfiguriert.

    Rückgabewert:
    subprocess.CompletedProcess mit .stdout/.stderr, wenn capture_output.

    Löst aus:
    RuntimeError: Wenn appget.exe nicht gefunden wird.
    subprocess.CalledProcessError: Bei Exit-Code ≠ 0 (nach Wiederholungsversuchen).
    subprocess.TimeoutExpired: Bei Timeout.
    KeyboardInterrupt: Bei Benutzerunterbrechung.
    """
    # Logger-Fallback und -Konfiguration
    if logger is None:
        logger = logging.getLogger("run_appget_command")
    if not logger.handlers:
        handler = logging.StreamHandler()
        fmt = logging.Formatter("[%(asctime)s] [%(levelname)s] %(name)s: %(message)s")
        handler.setFormatter(fmt)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)

    # Zwischenspeichern des AppGet-Pfads
    if not hasattr(run_appget_command, "_appget_path"):
        path = shutil.which("appget")
        if not path:
            msg = "AppGet not found – please install and check PATH."
            logger.error(msg)
            raise RuntimeError(msg)
        run_appget_command._appget_path = path
    appget_path = run_appget_command._appget_path

    # Tokenisierung
    args = command if isinstance(command, list) else shlex.split(command)
    cmd = [appget_path] + args

    logger.debug(f"Starting AppGet: {' '.join(cmd)} (timeout={timeout}, retries={retries})")

    # Ausführung mit Wiederholungsversuchen
    attempt = 0
    while True:
        attempt += 1
        try:
            start = time.perf_counter()
            result = subprocess.run(
                cmd,
                shell=False,
                stdout=subprocess.PIPE if capture_output else None,
                stderr=subprocess.PIPE if capture_output else None,
                text=True,
                timeout=timeout,
                check=True
            )
            duration = time.perf_counter() - start
            logger.info(f"AppGet succeeded in {duration:.2f}s (attempt {attempt})")
            return result

        except subprocess.CalledProcessError as e:
            stderr = (e.stderr or "").strip() or "<no stderr>"
            logger.error(f"Exit code {e.returncode} (attempt {attempt}): {stderr}")
            if attempt <= retries:
                wait = retry_delay * (2 ** (attempt - 1))
                logger.warning(f"Retrying in {wait:.1f}s…")
                time.sleep(wait)
                continue
            raise

        except subprocess.TimeoutExpired as e:
            logger.error(f"Timeout after {timeout}s (attempt {attempt})")
            raise

        except KeyboardInterrupt:
            logger.warning("Aborted by user")
            raise


def get_main_pin(current_dir, env_indicator_10):
    return (
            f"\n{white}┌──({reset}{blue}{getpass.getuser()}"
            + colored("㋐", attrs=["bold"])
            + f"{blue}Peharge{reset}{white})-[{reset}{blue}{current_dir}{reset}{white}]-{reset}{env_indicator_10}"
              f"\n{white}└─{reset}{blue}${reset} "
    )


def get_main_2_pin(current_dir, env_indicator_9):
    return (
            f"\n{blue}┌──({reset}{getpass.getuser()}"
            + colored("㋐", attrs=["bold"])
            + f"Peharge{blue})-[{reset}{current_dir}{blue}]-{reset}{env_indicator_9}"
              f"\n{blue}└─{reset}{blue}${reset} "
    )


def get_main_3_pin(current_dir, env_indicator_5):
    return (
            f"\n{green}┌──({reset}{blue}{getpass.getuser()}"
            + colored("㋐", attrs=["bold"])
            + f"{blue}Peharge{reset}{green})-[{reset}{current_dir}{green}]-{reset}{env_indicator_5}"
              f"\n{green}└─{reset}{blue}${reset} "
    )


def get_main_4_pin(current_dir, env_indicator_3):
    print("")

    return (
        f"{env_indicator_3} {blue}PP{reset} {current_dir}:~{blue}${reset} "
    )


def get_main_5_pin(current_dir, env_indicator_3):
    print("")

    return (
            f"{env_indicator_3} {blue}{getpass.getuser()}" + colored("㋐", attrs=[
        "bold"]) + f"{blue}Peharge{reset} {current_dir}:~{blue}${reset} "
    )


def get_main_6_pin(current_dir, env_indicator_main):
    return (
            f"\n{blue}🌌 [{white}{bold}{getpass.getuser()}" + colored("㋐", attrs=["bold"]) + f"Peharge{reset}{blue}]"
                                                                                            f" {dim}{timestamp()}{reset} "
                                                                                            f"{white}[{current_dir}]{reset} {env_indicator_main}"
                                                                                            f"\n{blue}➤{reset} "
    )


def get_main_7_pin(current_dir, env_indicator_main):
    return (
            f"\n{blue}╭─ {white}{bold}{getpass.getuser()}" + colored("㋐", attrs=["bold"]) + f"Peharge{reset}{blue}"
                                                                                            f"\n├─ 📁 {white}{current_dir}{blue}"
                                                                                            f"\n╰─ 🌐 {env_indicator_main}{reset}"
                                                                                            f"\n{blue}λ{reset} "
    )


def get_main_8_pin(current_dir, env_indicator_main):
    return (
            f"\n{blue}[{white}{getpass.getuser()}" + colored("㋐", attrs=[
        "bold"]) + f"Peharge{blue}]{reset}:{white}{current_dir}{reset} {blue}{env_indicator_main}{reset} ➤ "
    )


def get_main_9_pin(current_dir, env_indicator_main):
    brain = "🧠"
    return (
            f"\n{blue}{brain} {bold}AI{reset} {white}| {getpass.getuser()}" + colored("㋐", attrs=["bold"]) + "Peharge"
                                                                                                             f" | {current_dir} | {env_indicator_main}"
                                                                                                             f"\n{blue}└─▶{reset} "
    )


def get_main_10_pin(current_dir, env_indicator_main):
    chip = "🧬"
    bolt = "⚡"
    return (
            f"\n{blue}{chip} SYSTEM {white}| {bold}{getpass.getuser()}" + colored("㋐", attrs=[
        "bold"]) + f"Peharge{reset} {blue}| {current_dir}{reset}"
                   f"\n{white}{bolt} ENV: {env_indicator_main}{reset}"
                   f"\n{blue}⟩{reset} "
    )


def get_main_11_pin(current_dir, env_indicator_main):
    circuit = colored('❖❖', 'blue')
    return (
        f"\n{circuit} {colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + f'Peharge', 'white', attrs=['bold'])}"
        f" {colored('⟿', 'blue')} {colored(current_dir, 'white')}"
        f" {colored('⟿', 'blue')} {env_indicator_main}"
        f"\n{circuit} {colored(timestamp(), 'white')} {colored('❯', 'blue')} "
    )


def get_main_12_pin(current_dir, env_indicator_main):
    wave = colored('〰️', 'blue')
    return (
            f"\n{wave}{wave}{colored('╼', 'white')} {colored(getpass.getuser(), 'white')}" + colored("㋐", attrs=[
        "bold"]) + f"{colored('Peharge', 'white')}"
                   f" {wave}{wave}{colored('╾', 'white')} {colored(current_dir, 'white')}"
                   f" {wave}{wave}{colored('╼', 'white')} {env_indicator_main}"
                   f"\n{colored('▶', 'blue')} "
    )


def get_main_13_pin(current_dir, env_indicator_main):
    diamond = colored('◆', 'blue')
    return (
        f"\n{diamond * 3} {colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'white', attrs=['bold'])} {diamond * 3}"
        f"\n {colored(current_dir, 'blue')} {colored('|', 'white')} {env_indicator_main}"
        f"\n{colored('⇨', 'blue')} "
    )


def get_main_14_pin(current_dir, env_indicator_main):
    pulse = colored('•', 'blue')
    return (
            f"\n{pulse} {colored('GRID>', 'white', attrs=['bold'])} {colored(getpass.getuser(), 'blue')}" + colored("㋐",
                                                                                                                    attrs=[
                                                                                                                        "bold"]) + f"{colored('Peharge', 'white')}"
                                                                                                                                   f" {pulse}\n{pulse} {colored(current_dir, 'blue')} {pulse} {env_indicator_main}"
                                                                                                                                   f"\n{pulse} {colored('»', 'blue')} "
    )


def get_main_15_pin(current_dir, env_indicator_main):
    sl = colored('⧸', 'blue')
    return (
        f"\n{sl}{sl}{sl} {colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'white', attrs=['bold'])} {sl}{sl}{sl}"
        f"\n {colored(current_dir, 'blue')} {sl} {env_indicator_main}"
        f"\n{colored('❯', 'blue')} "
    )


def get_main_16_pin(current_dir, env_indicator_main):
    return (
        f"\n{colored('▯▯▯▯', 'blue')} {colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'white', attrs=['bold'])}"
        f" {colored('⇢', 'blue')} {colored(current_dir, 'white')}"
        f" {colored('⇢', 'blue')} {env_indicator_main}"
        f"\n{colored('▯▯▯▯', 'blue')} {colored(timestamp(), 'white')} {colored('›', 'blue')} "
    )


def get_main_17_pin(current_dir, env_indicator_main):
    bar = colored('▮', 'blue')
    return (
        f"\n{bar * 3} {colored('DATAPULSE', 'white', attrs=['bold'])} {bar * 3}"
        f"\n{bar} {colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'blue')} {bar}"
        f"\n{bar} {colored(current_dir, 'white')} {bar} {env_indicator_main}"
        f"\n{bar * 3} {colored('▶', 'white')} "
    )


def get_main_18_pin(current_dir, env_indicator_main):
    node = colored('◉', 'blue')
    return (
            f"\n{node} {colored(getpass.getuser(), 'white')}" + colored("㋐",
                                                                        attrs=["bold"]) + "{colored('Peharge', 'blue')}"
                                                                                          f" {node} {colored(current_dir, 'white')} {node} {env_indicator_main}"
                                                                                          f"\n{node} {colored('❯', 'white')} "
    )


def get_main_19_pin(current_dir, env_indicator_main):
    grid = colored('⊡', 'blue')
    return (
        f"\n{grid}{grid}{grid} {colored('QUANTUM', 'white', attrs=['bold'])} {grid}{grid}{grid}"
        f"\n{colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'blue')} | {colored(current_dir, 'white')} | {env_indicator_main}"
        f"\n{colored('▸▸', 'blue')} "
    )


def get_main_20_pin(current_dir, env_indicator_main):
    return (
        f"\n{colored('~', 'blue')} {colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'white')} {colored('~', 'blue')}"
        f" {colored(current_dir, 'blue')} {colored('/', 'white')} {env_indicator_main}"
        f"\n{colored('❯', 'blue')} "
    )


def get_main_21_pin(current_dir, env_indicator_main):
    flow = colored('»', 'blue')
    return (
        f"\n{flow * 2} {colored('BYTEFLOW', 'white', attrs=['bold'])} {flow * 2}"
        f"\n{flow} {colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'blue')} {flow}"
        f"\n{flow} {colored(current_dir, 'white')} {flow} {env_indicator_main}"
        f"\n{flow * 2} {colored('›', 'white')} "
    )


def get_main_22_pin(current_dir, env_indicator_main):
    prism = colored('◇', 'blue')
    return (
        f"\n{prism * 2} {colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'white')} {prism * 2}"
        f"\n{colored(current_dir, 'blue')} {colored('⇄', 'white')} {env_indicator_main}"
        f"\n{colored('❯❯', 'blue')} "
    )


def get_main_23_pin(current_dir, env_indicator_main):
    return (
        f"\n{colored('[', 'blue')}{colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'white')}{colored(']', 'blue')}"
        f"{colored('<', 'white')}{colored(current_dir, 'blue')}{colored('>', 'white')}"
        f"{colored('[', 'blue')}{env_indicator_main}{colored(']', 'white')}"
        f"\n{colored('›', 'blue')} "
    )


def get_main_24_pin(current_dir, env_indicator_main):
    slash = colored('╱', 'blue')
    return (
        f"\n{slash * 3} {colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'white')} {slash * 3}"
        f"\n{slash} {colored(current_dir, 'blue')} {slash} {env_indicator_main}"
        f"\n{colored('❯', 'blue')} "
    )


def get_main_25_pin(current_dir, env_indicator_main):
    ring = colored('◯', 'blue')
    return (
        f"\n{ring} {colored('PEHARGE', 'white', attrs=['bold'])} {ring}"
        f"\n{colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'blue')} · {colored(current_dir, 'white')} · {env_indicator_main}"
        f"\n{colored('➤', 'blue')} "
    )


def get_main_26_pin(current_dir, env_indicator_main):
    aurora = colored('≈≈≈', 'blue')
    return (
        f"\n{aurora} {colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'white', attrs=['bold'])} {aurora}"
        f"\n{colored(current_dir, 'blue')} {colored('~', 'white')} {env_indicator_main}"
        f"\n{colored('➤', 'blue')} "
    )


def get_main_27_pin(current_dir, env_indicator_main):
    hexg = colored('⬡', 'blue')
    return (
        f"\n{hexg * 2} {colored('HEXGRID', 'white', attrs=['bold'])} {hexg * 2}"
        f"\n{colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'blue')} {hexg} {colored(current_dir, 'white')} {hexg} {env_indicator_main}"
        f"\n{colored('›', 'blue')} "
    )


def get_main_28_pin(current_dir, env_indicator_main):
    beacon = colored('✦', 'blue')
    return (
            f"\n{beacon} {colored(getpass.getuser(), 'white')}" + colored("㋐", attrs=[
        "bold"]) + f"{colored('Peharge', 'blue')} {beacon}"
                   f"\n{colored('Dir:', 'white')} {colored(current_dir, 'blue')} {beacon} {env_indicator_main}"
                   f"\n{colored('❯', 'blue')} "
    )


def get_main_29_pin(current_dir, env_indicator_main):
    binf = colored('1010', 'blue')
    return (
        f"\n{binf} {colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'white', attrs=['bold'])} {binf}"
        f"\n{colored(current_dir, 'blue')} | {env_indicator_main}"
        f"\n{colored('►', 'blue')} "
    )


def get_main_30_pin(current_dir, env_indicator_main):
    mesh = colored('╳', 'blue')
    return (
            f"\n{mesh}{mesh}{mesh} {colored(getpass.getuser(), 'white')}" + colored("㋐", attrs=[
        "bold"]) + f"{colored('Peharge', 'blue')} {mesh}{mesh}{mesh}"
                   f"\n{colored(current_dir, 'blue')} {mesh} {env_indicator_main}"
                   f"\n{colored('❯', 'blue')} "
    )


def get_main_31_pin(current_dir, env_indicator_main):
    star = colored('✺', 'blue')
    return (
        f"\n{star * 2} {colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'white', attrs=['bold'])} {star * 2}"
        f"\n{colored('📂', 'white')} {colored(current_dir, 'blue')}   {env_indicator_main}"
        f"\n{colored('➤', 'blue')} "
    )


def get_main_32_pin(current_dir, env_indicator_main):
    # Sicherstellen, dass current_dir ein String ist
    if isinstance(current_dir, Path):
        current_dir = str(current_dir)

    lf = colored('╔═', 'blue')
    rt = colored('═╗', 'blue')
    lb = colored('╚═', 'blue')
    rb = colored('═╝', 'blue')

    user = getpass.getuser()
    user_display = colored(user + colored("㋐", attrs=["bold"]) + 'Peharge', 'white')
    header = f"{lf}{user_display}{rt}"
    footer = f"{lb}{colored(current_dir + ' | ' + env_indicator_main, 'blue')}{rb}"

    return f"\n{header}\n{footer}\n{colored('►', 'blue')} "


def get_main_33_pin(current_dir, env_indicator_main):
    q = colored('⟐', 'blue')
    return (
        f"\n{q} {colored('Q-PULSE', 'white', attrs=['bold'])} {q}"
        f"\n{colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'blue')} • {colored(current_dir, 'white')} • {env_indicator_main}"
        f"\n{colored('❯', 'blue')} "
    )


def get_main_34_pin(current_dir, env_indicator_main):
    arc = colored('◥◣', 'blue')
    return (
            f"\n{arc} {colored(getpass.getuser(), 'white')}" + colored("㋐", attrs=[
        "bold"]) + f"{colored('Peharge', 'blue')} {arc}"
                   f"\n{colored(current_dir, 'blue')} [{env_indicator_main}]"
                   f"\n{colored('➤', 'blue')} "
    )


def get_main_35_pin(current_dir, env_indicator_main):
    bar = colored('━', 'blue')
    return (
        f"\n{bar * 4} {colored(getpass.getuser() + colored("㋐", attrs=["bold"]) + 'Peharge', 'white', attrs=['bold'])} {bar * 4}"
        f"\n{colored(current_dir, 'blue')} {bar} {env_indicator_main}"
        f"\n{colored('›', 'blue')} "
    )


def get_evil_pin(current_dir, env_indicator_11):
    return (
            f"\n{white}┌──({reset}{red}root"
            + colored("㋐", attrs=["bold"])
            + f"{red}Peharge{reset}{white})-[{reset}{red}{current_dir}{reset}{white}]-{reset}{env_indicator_11}"
              f"\n{white}└─{reset}{red}#{reset} "
    )


def get_evil_2_pin(current_dir, env_indicator_4):
    return (
            f"\n{red}┌──({reset}root"
            + colored("㋐", attrs=["bold"])
            + f"Peharge{red})-[{reset}{current_dir}{red}]-{reset}{env_indicator_4}"
              f"\n{red}└─{reset}{red}#{reset} "
    )


def get_evil_3_pin(current_dir, env_indicator_9):
    return (
            f"\n{blue}┌──({reset}{red}root"
            + colored("㋐", attrs=["bold"])
            + f"{red}Peharge{reset}{blue})-[{reset}{current_dir}{blue}]-{reset}{env_indicator_9}"
              f"\n{blue}└─{reset}{red}#{reset} "
    )


def get_evil_4_pin(current_dir, env_indicator_3):
    print("")

    return (
        f"{env_indicator_3} {red}PP{reset} {current_dir}:~{red}#{reset} "
    )


def get_evil_5_pin(current_dir, env_indicator_3):
    print("")

    return (
            f"{env_indicator_3} {red}root" + colored("㋐", attrs=[
        "bold"]) + f"{red}Peharge{reset} {current_dir}:~{red}#{reset} "
    )


def get_adv_pin(current_dir, env_indicator_12):
    return (
            f"\n{white}┌──({reset}{green}{getpass.getuser()}"
            + colored("㋐", attrs=["bold"])
            + f"{green}Peharge{reset}{white})-[{reset}{green}{current_dir}{reset}{white}]-{reset}{env_indicator_12}"
              f"\n{white}└─{reset}{green}§{reset} "
    )


def get_adv_2_pin(current_dir, env_indicator_4):
    return (
            f"\n{green}┌──({reset}{getpass.getuser()}"
            + colored("㋐", attrs=["bold"])
            + f"Peharge{green})-[{reset}{current_dir}{green}]-{reset}{env_indicator_4}"
              f"\n{green}└─{reset}{green}§{reset} "
    )


def get_adv_3_pin(current_dir, env_indicator_9):
    return (
            f"\n{blue}┌──({reset}{green}{getpass.getuser()}"
            + colored("㋐", attrs=["bold"])
            + f"{green}Peharge{reset}{blue})-[{reset}{current_dir}{blue}]-{reset}{env_indicator_9}"
              f"\n{blue}└─{reset}{green}§{reset} "
    )


def get_adv_4_pin(current_dir, env_indicator_3):
    print("")

    return (
        f"{env_indicator_3} {green}PP{reset} {current_dir}:~{green}§{reset} "
    )


def get_adv_5_pin(current_dir, env_indicator_3):
    print("")

    return (
            f"{env_indicator_3} {green}{getpass.getuser()}" + colored("㋐", attrs=[
        "bold"]) + f"{green}Peharge{reset} {current_dir}:~{green}§{reset} "
    )


def get_stable_pin(current_dir, env_indicator_6):
    return (
            f"\n┌──({getpass.getuser()}"
            + colored("㋐", attrs=["bold"])
            + f"Peharge)-[{current_dir}]-{env_indicator_6}"
              f"\n└─$ "
    )


def get_stable_2_pin(current_dir, env_indicator_8):
    print("")

    return (
        f"{env_indicator_8} PP {current_dir}:~$ "
    )


def get_stable_3_pin(current_dir, env_indicator_3):
    print("")

    return (
            f"{env_indicator_3} {getpass.getuser()}" + colored("㋐",
                                                               attrs=["bold"]) + f"Peharge{reset} {current_dir}:~$ "
    )


def get_stable_4_pin(current_dir, env_indicator_6):
    return (
            f"\n┌──(root"
            + colored("㋐", attrs=["bold"])
            + f"Peharge)-[{current_dir}]-{env_indicator_6}"
              f"\n└─# "
    )


def get_stable_5_pin(current_dir, env_indicator_8):
    print("")

    return (
        f"{env_indicator_8} PP {current_dir}:~# "
    )


def get_stable_6_pin(current_dir, env_indicator_8):
    print("")

    return (
            f"{env_indicator_8} root" + colored("㋐", attrs=["bold"]) + f"Peharge{reset} {current_dir}:~# "
    )


def get_cool_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """

    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\powerlevel10k_rainbow.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_2_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\atomicBit.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_3_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\jandedobbeleer.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_4_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """

    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\p10k_classic.omp.jso"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_5_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\amro.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_6_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\M365Princess.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_7_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\blue-owl.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_8_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\aliens.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_9_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\agnoster.minimal.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_10_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\agnosterplus.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_11_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\atomic.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_12_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\free-ukraine.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_13_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\easy-term.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_14_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\grandpa-style.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_15_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\lambdageneration.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_16_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\lightgreen.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_17_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\bubbles.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_18_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\negligible.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_19_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\slimfat.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_20_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\stelbent.minimal.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_21_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\tonybaloney.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_22_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\emodipt.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


def get_cool_23_pin():
    """
    Ruft eine gerenderte Oh-My-Posh-Prompt basierend auf einer bestimmten Theme-Konfiguration ab.
    """
    print("")

    config_path = os.path.expanduser(
        r"~\AppData\Local\Programs\oh-my-posh\themes\tokyo.omp.json"
    )
    working_dir = os.getcwd()  # oder spezifisch: r"C:\Users\julian"

    try:
        result = subprocess.run(
            [
                "oh-my-posh",
                "print",
                "primary",
                "--config", config_path,
                "--pwd", working_dir,
                "--shell", "pwsh"
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',  # wichtig für korrekte Grafikzeichen
            shell=True  # in Windows häufig nötig für PATH-Auflösung
        )
    except FileNotFoundError:
        return f"[{timestamp()}] [ERROR] oh-my-posh was not found. Is it in the PATH?"
    except Exception as e:
        return f"[{timestamp()}] [ERROR] Unexpected error: {e}"

    if result.returncode == 0:
        return result.stdout
    else:
        return f"[{timestamp()}] [ERROR] Error running oh-my-posh:\n{result.stderr}"


with open(f"C:/Users/{user_name}/p-terminal/pp-term/autocompletion_commands.json", "r", encoding="utf-8") as file:
    commands_data = json.load(file)

# COMMANDS aus der JSON-Datei extrahieren
COMMANDS = commands_data.get("commands", [])

# Verlauf und Index
history = []
history_index = -1


def setup_autocomplete(commands=None):
    """
    Aktiviert Tab-Autocomplete für eine gegebene Befehlsliste.
    Nur Befehle, die mit dem bereits getippten Text beginnen, werden vorgeschlagen.
    """
    if commands is None:
        commands = COMMANDS.copy()

    # Definiere, welche Zeichen als Worttrenner gelten (hier nur Leerzeichen)
    readline.set_completer_delims(' \t\n')

    def completer(text, state):
        # Bei jedem Aufruf filtern wir die Befehle anhand des Präfixes 'text'
        matches = [cmd for cmd in commands if cmd.startswith(text)]
        try:
            return matches[state]
        except IndexError:
            return None

    # Setze den Completer und die Key-Bindings
    readline.set_completer(completer)
    readline.parse_and_bind('tab: complete')
    # show-all-if-ambiguous = bei mehreren Treffern sofort alle anzeigen
    readline.parse_and_bind('set show-all-if-ambiguous on')
    # completion-ignore-case = Groß-/Kleinschreibung ignorieren
    readline.parse_and_bind('set completion-ignore-case on')


def get_completions(prefix):
    """Gibt alle COMMANDS zurück, die mit prefix anfangen (für tab-Vervollständigung)."""
    return [cmd for cmd in COMMANDS if cmd.startswith(prefix)]


def input_line(prompt):
    """Lesen einer Zeile mit History (Up/Down) und Tab-Completion."""
    sys.stdout.write(prompt)
    sys.stdout.flush()

    buf = ''
    global history_index
    history_index = len(history)

    while True:
        ch = msvcrt.getwch()

        # Enter
        if ch in ('\r', '\n'):
            print()
            if buf:
                history.append(buf)
            return buf

        # Backspace
        if ch == '\b':
            if buf:
                buf = buf[:-1]
                sys.stdout.write('\b \b')
                sys.stdout.flush()
            continue

        # Tab = Completion
        if ch == '\t':
            comps = get_completions(buf)
            if comps:
                # Spaltenorientierte Ausgabe
                sys.stdout.write('\n')
                cols, _ = shutil.get_terminal_size((80, 20))
                maxlen = max(len(c) for c in comps) + 2  # +2 für Abstand
                per_line = cols // maxlen

                for i, c in enumerate(comps):
                    sys.stdout.write(c.ljust(maxlen))
                    if (i + 1) % per_line == 0:
                        sys.stdout.write('\n')
                sys.stdout.write('\n')

                # Prompt und bisherigen Puffer neu ausgeben
                sys.stdout.write(prompt + buf)
                sys.stdout.flush()
            continue

        # Pfeiltasten: Spezialcode '\xe0'
        if ch == '\xe0':
            arrow = msvcrt.getwch()
            # Up arrow
            if arrow == 'H' and history and history_index > 0:
                history_index -= 1
                new_buf = history[history_index]
            # Down arrow
            elif arrow == 'P':
                if history_index < len(history) - 1:
                    history_index += 1
                    new_buf = history[history_index]
                else:
                    history_index = len(history)
                    new_buf = ''
            else:
                continue
            # Lösche bisherigen Buffer vom Bildschirm
            sys.stdout.write('\b' * len(buf))
            sys.stdout.write(' ' * len(buf))
            sys.stdout.write('\b' * len(buf))
            buf = new_buf
            sys.stdout.write(buf)
            sys.stdout.flush()
            continue

        # Normale Zeichen
        if ch.isprintable():
            buf += ch
            sys.stdout.write(ch)
            sys.stdout.flush()


def handle_history_command():
    """
    Gibt alle Einträge in history aus.
    Rückgabe True signalisiert, dass das Kommando history verarbeitet wurde.
    """
    if not history:
        print(f"[{timestamp()}] [ERROR] No commands in the history.")
    else:
        print(f"[{timestamp()}] [INFO] Previous commands:\n")
        for idx, cmd in enumerate(history, start=1):
            print(f"  {main_color}[{idx}]{reset} {cmd}")
    return True


def main():
    state = state_info()

    active = Path(find_active_env()).resolve()

    print_banner()
    set_python_path(active)
    # setup_autocomplete()

    while True:
        try:
            current_dir = Path.cwd().resolve()
            json_path = Path(f"C:/Users/{user_name}/p-terminal/pp-term/current_env.json")

            try:
                with open(json_path, 'r') as file:
                    data = json.load(file)
                    active = data.get("active_env")

                if active:
                    active_env_path = Path(active)  # Convert to Path object

                    # Example usage
                    # python_exe = active_env_path / "Scripts" / "python.exe"

            except FileNotFoundError:
                print(f"File not found: {json_path}")
            except json.JSONDecodeError:
                print(f"Error decoding JSON file: {json_path}")

            # Prüfe python.exe an typischen Stellen
            env_active = (
                # Windows-Pfade
                    (active_env_path / "Scripts/python.exe").exists() or
                    (active_env_path / "python.exe").exists() or
                    (active_env_path / "condabin/conda.bat").exists() or
                    (active_env_path / "conda.exe").exists() or

                    # (Unix/Linux-Pfade - eigetnlich unötig)
                    (active_env_path / "bin/python").exists() or
                    (active_env_path / "bin/python1.4").exists() or
                    (active_env_path / "bin/python1.5").exists() or
                    (active_env_path / "bin/python1.6").exists() or
                    (active_env_path / "bin/python2").exists() or
                    (active_env_path / "bin/python2.0").exists() or
                    (active_env_path / "bin/python2.1").exists() or
                    (active_env_path / "bin/python2.2").exists() or
                    (active_env_path / "bin/python2.3").exists() or
                    (active_env_path / "bin/python2.4").exists() or
                    (active_env_path / "bin/python2.5").exists() or
                    (active_env_path / "bin/python2.6").exists() or
                    (active_env_path / "bin/python2.7").exists() or
                    (active_env_path / "bin/python3").exists() or
                    (active_env_path / "bin/python3.0").exists() or
                    (active_env_path / "bin/python3.1").exists() or
                    (active_env_path / "bin/python3.2").exists() or
                    (active_env_path / "bin/python3.3").exists() or
                    (active_env_path / "bin/python3.4").exists() or
                    (active_env_path / "bin/python3.5").exists() or
                    (active_env_path / "bin/python3.6").exists() or
                    (active_env_path / "bin/python3.7").exists() or
                    (active_env_path / "bin/python3.8").exists() or
                    (active_env_path / "bin/python3.9").exists() or
                    (active_env_path / "bin/python3.10").exists() or
                    (active_env_path / "bin/python3.11").exists() or
                    (active_env_path / "bin/python3.12").exists() or
                    (active_env_path / "bin/python3.13").exists() or
                    (active_env_path / "bin/conda").exists()
            )

            try:
                if current_dir in active_env_path.parents or current_dir == active_env_path:
                    display_env_path_main = Path(".") / active_env_path.relative_to(current_dir)
                    display_env_path = ".\\" + str(display_env_path_main)
                else:
                    display_env_path = str(active_env_path)
            except Exception:
                display_env_path = str(active_env_path)

            env_indicator_main = (
                f"{display_env_path}"
                if env_active else
                f"{red}no venv{reset}"
            )

            env_indicator = (
                f"{white}[{reset}{display_env_path}{white}]{reset}"
                if env_active else
                f"{white}[{reset}{red}no venv recorded{reset}{white}]{reset}"
            )

            env_indicator_3 = (
                f"({display_env_path})"
                if env_active else
                f"({red}venv{reset})"
            )

            env_indicator_4 = (
                f"{red}[{reset}{display_env_path}{red}]{reset}"
                if env_active else
                f"{red}[no venv recorded]{reset}"
            )

            env_indicator_5 = (
                f"{green}[{reset}{display_env_path}{green}]{reset}"
                if env_active else
                f"{green}[{reset}{red}no venv recorded{reset}{green}]{reset}"
            )

            env_indicator_6 = (
                f"[{display_env_path}]"
                if env_active else
                f"[no venv recorded]"
            )

            env_indicator_8 = (
                f"({display_env_path})"
                if env_active else
                f"(no venv)"
            )

            env_indicator_9 = (
                f"{blue}[{reset}{display_env_path}{blue}]{reset}"
                if env_active else
                f"{blue}[{reset}{red}no venv recorded{reset}{blue}]{reset}"
            )

            env_indicator_10 = (
                f"{white}[{reset}{blue}{display_env_path}{reset}{white}]{reset}"
                if env_active else
                f"{white}[{reset}{red}no venv{reset}{white}]{reset}"
            )

            env_indicator_11 = (
                f"{white}[{reset}{red}{display_env_path}{reset}{white}]{reset}"
                if env_active else
                f"{white}[{reset}{red}no venv{reset}{white}]{reset}"
            )

            env_indicator_12 = (
                f"{white}[{reset}{green}{display_env_path}{reset}{white}]{reset}"
                if env_active else
                f"{white}[{reset}{red}no venv{reset}{white}]{reset}"
            )

            env_indicator_13 = (
                f"{green}[{reset}{display_env_path}{green}]{reset}"
                if env_active else
                f"{green}[no venv recorded]{reset}"
            )

            # PIN-Design je nach state
            if state == "main":
                setup_autocomplete()
                pin = get_main_pin(current_dir, env_indicator_10)
                print(pin, end='')
                # print(pin, end='', flush=True)
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-2":
                setup_autocomplete()
                pin = get_main_2_pin(current_dir, env_indicator_9)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-3":
                setup_autocomplete()
                pin = get_main_3_pin(current_dir, env_indicator_5)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-4":
                setup_autocomplete()
                pin = get_main_4_pin(current_dir, env_indicator_3)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-5":
                setup_autocomplete()
                pin = get_main_5_pin(current_dir, env_indicator_3)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-6":
                setup_autocomplete()
                pin = get_main_6_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)


            elif state == "main-7":
                setup_autocomplete()
                pin = get_main_7_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-8":
                setup_autocomplete()
                pin = get_main_8_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-9":
                setup_autocomplete()
                pin = get_main_9_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-10":
                setup_autocomplete()
                pin = get_main_10_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-11":
                setup_autocomplete()
                pin = get_main_11_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-12":
                setup_autocomplete()
                pin = get_main_12_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-13":
                setup_autocomplete()
                pin = get_main_13_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-14":
                setup_autocomplete()
                pin = get_main_14_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-15":
                setup_autocomplete()
                pin = get_main_15_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-16":
                setup_autocomplete()
                pin = get_main_16_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-17":
                setup_autocomplete()
                pin = get_main_17_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-18":
                setup_autocomplete()
                pin = get_main_18_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-19":
                setup_autocomplete()
                pin = get_main_19_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-20":
                setup_autocomplete()
                pin = get_main_20_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-21":
                setup_autocomplete()
                pin = get_main_21_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-22":
                setup_autocomplete()
                pin = get_main_22_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-23":
                setup_autocomplete()
                pin = get_main_23_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-24":
                setup_autocomplete()
                pin = get_main_24_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-25":
                setup_autocomplete()
                pin = get_main_25_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-26":
                setup_autocomplete()
                pin = get_main_26_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-27":
                setup_autocomplete()
                pin = get_main_27_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-28":
                setup_autocomplete()
                pin = get_main_28_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-29":
                setup_autocomplete()
                pin = get_main_29_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-30":
                setup_autocomplete()
                pin = get_main_30_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-31":
                setup_autocomplete()
                pin = get_main_31_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-32":
                setup_autocomplete()
                pin = get_main_32_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-33":
                setup_autocomplete()
                pin = get_main_33_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-34":
                setup_autocomplete()
                pin = get_main_34_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "main-35":
                setup_autocomplete()
                pin = get_main_35_pin(current_dir, env_indicator_main)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "evil":
                setup_autocomplete()
                pin = get_evil_pin(current_dir, env_indicator_11)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "evil-2":
                setup_autocomplete()
                pin = get_evil_2_pin(current_dir, env_indicator_4)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "evil-3":
                setup_autocomplete()
                pin = get_evil_3_pin(current_dir, env_indicator_9)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "evil-4":
                setup_autocomplete()
                pin = get_evil_4_pin(current_dir, env_indicator_3)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "evil-5":
                setup_autocomplete()
                pin = get_evil_5_pin(current_dir, env_indicator_3)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "adv":
                setup_autocomplete()
                pin = get_adv_pin(current_dir, env_indicator_12)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "adv-2":
                setup_autocomplete()
                pin = get_adv_2_pin(current_dir, env_indicator_13)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "adv-3":
                setup_autocomplete()
                pin = get_adv_3_pin(current_dir, env_indicator_9)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "adv-4":
                setup_autocomplete()
                pin = get_adv_4_pin(current_dir, env_indicator_3)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "adv-5":
                setup_autocomplete()
                pin = get_adv_5_pin(current_dir, env_indicator_3)
                print(pin, end='')
                user_input = input().strip()
                history.append(user_input)

            elif state == "stable":
                setup_autocomplete()
                pin = get_stable_pin(current_dir, env_indicator_6)
                user_input = input(pin).strip()
                history.append(user_input)

            elif state == "stable-2":
                setup_autocomplete()
                pin = get_stable_2_pin(current_dir, env_indicator_6)
                user_input = input(pin).strip()
                history.append(user_input)

            elif state == "stable-3":
                setup_autocomplete()
                pin = get_stable_3_pin(current_dir, env_indicator_8)
                user_input = input(pin).strip()
                history.append(user_input)

            elif state == "stable-4":
                setup_autocomplete()
                pin = get_stable_4_pin(current_dir, env_indicator_8)
                user_input = input(pin).strip()
                history.append(user_input)

            elif state == "stable-5":
                setup_autocomplete()
                pin = get_stable_5_pin(current_dir, env_indicator_8)
                user_input = input(pin).strip()
                history.append(user_input)

            elif state == "stable-6":
                setup_autocomplete()
                pin = get_stable_6_pin(current_dir, env_indicator_8)
                user_input = input(pin).strip()
                history.append(user_input)

            elif state == "cool":
                pin = get_cool_pin()
                user_input = input_line(pin)

            elif state == "cool-2":
                pin = get_cool_2_pin()
                user_input = input_line(pin)

            elif state == "cool-3":
                pin = get_cool_3_pin()
                user_input = input_line(pin)

            elif state == "cool-4":
                pin = get_cool_4_pin()
                user_input = input_line(pin)

            elif state == "cool-5":
                pin = get_cool_5_pin()
                user_input = input_line(pin)

            elif state == "cool-6":
                pin = get_cool_6_pin()
                user_input = input_line(pin)

            elif state == "cool-7":
                pin = get_cool_7_pin()
                user_input = input_line(pin)

            elif state == "cool-8":
                pin = get_cool_8_pin()
                user_input = input_line(pin)

            elif state == "cool-9":
                pin = get_cool_9_pin()
                user_input = input_line(pin)

            elif state == "cool-10":
                pin = get_cool_10_pin()
                user_input = input_line(pin)

            elif state == "cool-11":
                pin = get_cool_11_pin()
                user_input = input_line(pin)

            elif state == "cool-12":
                pin = get_cool_12_pin()
                user_input = input_line(pin)

            elif state == "cool-13":
                pin = get_cool_13_pin()
                user_input = input_line(pin)

            elif state == "cool-14":
                pin = get_cool_14_pin()
                user_input = input_line(pin)

            elif state == "cool-15":
                pin = get_cool_15_pin()
                user_input = input_line(pin)

            elif state == "cool-16":
                pin = get_cool_16_pin()
                user_input = input_line(pin)

            elif state == "cool-17":
                pin = get_cool_17_pin()
                user_input = input_line(pin)

            elif state == "cool-18":
                pin = get_cool_18_pin()
                user_input = input_line(pin)

            elif state == "cool-19":
                pin = get_cool_19_pin()
                user_input = input_line(pin)

            elif state == "cool-20":
                pin = get_cool_20_pin()
                user_input = input_line(pin)

            elif state == "cool-21":
                pin = get_cool_21_pin()
                user_input = input_line(pin)

            elif state == "cool-22":
                pin = get_cool_22_pin()
                user_input = input_line(pin)

            elif state == "cool-23":
                pin = get_cool_23_pin()
                user_input = input_line(pin)

            else:
                pin = get_main_pin(current_dir, env_indicator)
                user_input = input_line(pin)

            if handle_special_commands(user_input):
                continue

            elif user_input.lower() == "pin main":
                state = "main"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-1":
                state = "main"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-2":
                state = "main-2"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-3":
                state = "main-3"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-4":
                state = "main-4"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-5":
                state = "main-5"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-6":
                state = "main-6"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-7":
                state = "main-7"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-8":
                state = "main-8"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-9":
                state = "main-9"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-10":
                state = "main-10"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-11":
                state = "main-11"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-12":
                state = "main-12"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-13":
                state = "main-13"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-14":
                state = "main-14"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-15":
                state = "main-15"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-16":
                state = "main-16"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-17":
                state = "main-17"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-18":
                state = "main-18"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-19":
                state = "main-19"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-20":
                state = "main-20"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-21":
                state = "main-21"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-22":
                state = "main-22"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-23":
                state = "main-23"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-24":
                state = "main-24"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-25":
                state = "main-25"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-26":
                state = "main-26"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-27":
                state = "main-27"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-28":
                state = "main-28"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-29":
                state = "main-29"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-30":
                state = "main-30"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-31":
                state = "main-31"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-32":
                state = "main-32"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-33":
                state = "main-33"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-34":
                state = "main-34"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin main-35":
                state = "main-35"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin evil":
                state = "evil"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin evil-1":
                state = "evil"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin evil-2":
                state = "evil-2"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin evil-3":
                state = "evil-3"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin evil-4":
                state = "evil-4"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin evil-5":
                state = "evil-5"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin adv":
                state = "adv"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin adv-1":
                state = "adv"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin adv-2":
                state = "adv-2"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin adv-3":
                state = "adv-3"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin adv-4":
                state = "adv-4"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin adv-5":
                state = "adv-5"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin stable":
                state = "stable"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin stable-1":
                state = "stable"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin stable-2":
                state = "stable-2"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin stable-3":
                state = "stable-3"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin stable-4":
                state = "stable-4"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin stable-5":
                state = "stable-5"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin stable-6":
                state = "stable-6"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool":
                state = "cool"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-1":
                state = "cool"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-2":
                state = "cool-2"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-3":
                state = "cool-3"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-4":
                state = "cool-4"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-5":
                state = "cool-5"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-6":
                state = "cool-6"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-7":
                state = "cool-7"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-8":
                state = "cool-8"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-9":
                state = "cool-9"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-10":
                state = "cool-10"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-11":
                state = "cool_11"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-12":
                state = "cool-12"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-13":
                state = "cool-13"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-14":
                state = "cool-14"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-15":
                state = "cool-15"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-16":
                state = "cool-16"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-17":
                state = "cool-17"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-18":
                state = "cool-18"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-19":
                state = "cool-19"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-20":
                state = "cool-20"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-21":
                state = "cool-21"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-22":
                state = "cool-22"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "pin cool-23":
                state = "cool-23"

                data = {"state": state}

                with open(f"C:/Users/{user_name}/p-terminal/pp-term/state-info.json", "w") as f:
                    json.dump(data, f, indent=4)

                continue

            elif user_input.lower() == "p-venv-info":
                active_env_path = Path(find_active_env()).resolve()
                print(f"[{timestamp()}] [INFO] Active environment: '{active_env_path}'.")

            elif user_input.startswith("p-venv-c "):
                user_input = user_input[9:].strip()
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()
                command = ["python", "-m", "venv", str(env_path)]

                try:
                    subprocess.run(command, check=True, text=True,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                    print(f"[{timestamp()}] [INFO] The '{user_input}' venv was created at {env_path}.")

                    # Annahme: find_active_env und set_python_path sind irgendwo definiert
                    active = find_active_env(str(env_path))
                    set_python_path(active)
                    print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")

                except subprocess.CalledProcessError as e:
                    print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                except KeyboardInterrupt:
                    print(f"[{timestamp()}] [INFO] Cancellation by user.")
                except Exception as e:
                    print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

            elif user_input.startswith("pp-p-venv-c "):
                user_input = user_input[12:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()
                command = f'python -m venv "{env_path}"'

                try:
                    subprocess.run(command, shell=True, check=True, text=True,
                                   stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                    print(f"[{timestamp()}] [INFO] The '{user_input}' venv was created at {env_path}.")

                    # Annahme: find_active_env und set_python_path sind irgendwo definiert
                    active = find_active_env(str(env_path))
                    set_python_path(active)
                    print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")

                except subprocess.CalledProcessError as e:
                    print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                except KeyboardInterrupt:
                    print(f"[{timestamp()}] [INFO] Cancellation by user.")
                except Exception as e:
                    print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

            elif user_input.startswith("pcv "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[4:].strip()
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # Prüfen, ob dieses venv bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] The virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing venv: {e}")
                else:
                    # venv erstellen
                    command = ["python", "-m", "venv", str(env_path)]
                    try:
                        subprocess.run(command, check=True, text=True,
                                       stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                        print(f"[{timestamp()}] [INFO] The virtual environment '{user_input}' was created at {env_path}.")

                        try:
                            active = find_active_env(str(env_path))
                            set_python_path(active)
                            print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                        except Exception as e:
                            print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                        # Nach anderen vorhandenen venvs im aktuellen Verzeichnis suchen
                        existing_venvs = find_existing_venvs(current_dir)
                        other_venvs = [name for name in existing_venvs if name != user_input]

                        if other_venvs:
                            print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                    except subprocess.CalledProcessError as e:
                        print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                    except KeyboardInterrupt:
                        print(f"[{timestamp()}] [INFO] Cancelled by user.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

            elif user_input.startswith("pp-pcv "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[7:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # Prüfen, ob dieses venv bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] The virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing venv: {e}")
                else:
                    # venv erstellen
                    command = f'python -m venv "{env_path}"'
                    try:
                        subprocess.run(command, shell=True, check=True, text=True,
                                       stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                        print(f"[{timestamp()}] [INFO] The virtual environment '{user_input}' was created at {env_path}.")

                        try:
                            active = find_active_env(str(env_path))
                            set_python_path(active)
                            print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                        except Exception as e:
                            print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                        # Nach anderen vorhandenen venvs im aktuellen Verzeichnis suchen
                        existing_venvs = find_existing_venvs(current_dir)
                        other_venvs = [name for name in existing_venvs if name != user_input]

                        if other_venvs:
                            print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                    except subprocess.CalledProcessError as e:
                        print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                    except KeyboardInterrupt:
                        print(f"[{timestamp()}] [INFO] Cancelled by user.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

            elif user_input.startswith("pcvf "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[5:].strip()
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # Prüfen, ob dieses venv bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] The virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing venv: {e}")
                else:
                    # venv erstellen
                    command = ["python", "-m", "venv", str(env_path)]
                    try:
                        subprocess.run(command, check=True, text=True,
                                       stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                        print(f"[{timestamp()}] [INFO] The virtual environment '{user_input}' was created at {env_path}.")

                        try:
                            active = find_active_env(str(env_path))
                            set_python_path(active)
                            print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                        except Exception as e:
                            print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                        # Nach anderen vorhandenen venvs im aktuellen Verzeichnis suchen
                        existing_venvs = find_existing_venvs(current_dir)
                        other_venvs = [name for name in existing_venvs if name != user_input]

                        if other_venvs:
                            print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                    except subprocess.CalledProcessError as e:
                        print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                    except KeyboardInterrupt:
                        print(f"[{timestamp()}] [INFO] Cancelled by user.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

            elif user_input.startswith("pp-pcvf "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[8:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # Prüfen, ob dieses venv bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] The virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing venv: {e}")
                else:
                    # venv erstellen
                    command = f'python -m venv "{env_path}"'
                    try:
                        subprocess.run(command, shell=True, check=True, text=True,
                                       stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                        print(f"[{timestamp()}] [INFO] The virtual environment '{user_input}' was created at {env_path}.")

                        try:
                            active = find_active_env(str(env_path))
                            set_python_path(active)
                            print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                        except Exception as e:
                            print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                        # Nach anderen vorhandenen venvs im aktuellen Verzeichnis suchen
                        existing_venvs = find_existing_venvs(current_dir)
                        other_venvs = [name for name in existing_venvs if name != user_input]

                        if other_venvs:
                            print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                    except subprocess.CalledProcessError as e:
                        print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                    except KeyboardInterrupt:
                        print(f"[{timestamp()}] [INFO] Cancelled by user.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

            elif user_input.startswith("pcsvf "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[6:].strip()
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # 1. Existiert die gewünschte venv schon?
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] A virtual environment named '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing environment: {e}")
                else:
                    # 2. Erstelle neue venv mit virtualenv
                    command = ["virtualenv", str(env_path)]
                    try:
                        subprocess.run(command, check=True, text=True,
                                       stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                        print(f"[{timestamp()}] [INFO] The virtual environment '{user_input}' was created at {env_path}.")

                        try:
                            active = find_active_env(str(env_path))
                            set_python_path(active)
                            print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                        except Exception as e:
                            print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                        # 3. Finde andere venvs im aktuellen Verzeichnis
                        existing_venvs = find_existing_venvs(current_dir)
                        other_venvs = [name for name in existing_venvs if name != user_input]

                        if other_venvs:
                            print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory:")
                            for venv_name in other_venvs:
                                print(f"  - {venv_name}")

                    except subprocess.CalledProcessError as e:
                        print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                    except KeyboardInterrupt:
                        print(f"[{timestamp()}] [INFO] Cancelled by user.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

            elif user_input.startswith("pp-pcsvf "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[9:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # 1. Existiert die gewünschte venv schon?
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] A virtual environment named '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing environment: {e}")
                else:
                    # 2. Erstelle neue venv mit virtualenv
                    command = f'virtualenv "{env_path}"'
                    try:
                        subprocess.run(command, shell=True, check=True, text=True,
                                       stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                        print(f"[{timestamp()}] [INFO] The virtual environment '{user_input}' was created at {env_path}.")

                        try:
                            active = find_active_env(str(env_path))
                            set_python_path(active)
                            print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                        except Exception as e:
                            print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                        # 3. Finde andere venvs im aktuellen Verzeichnis
                        existing_venvs = find_existing_venvs(current_dir)
                        other_venvs = [name for name in existing_venvs if name != user_input]

                        if other_venvs:
                            print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory:")
                            for venv_name in other_venvs:
                                print(f"  - {venv_name}")

                    except subprocess.CalledProcessError as e:
                        print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                    except KeyboardInterrupt:
                        print(f"[{timestamp()}] [INFO] Cancelled by user.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

            elif user_input.startswith("pcv-p313 "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[9:].strip()
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # 1. Prüfen, ob Environment bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing environment: {e}")
                else:
                    # 2. Nach Python 3.13 suchen
                    try:
                        result = subprocess.run(["where", "python3.13"], capture_output=True, text=True, check=True)
                        paths = result.stdout.strip().splitlines()
                        python_3_13_executable = None
                        for p in paths:
                            if Path(p).exists():
                                python_3_13_executable = p
                                break

                        if not python_3_13_executable:
                            print(f"[{timestamp()}] [ERROR] Python 3.13 executable not found on the system.")
                        else:
                            print(f"[{timestamp()}] [INFO] Found Python 3.13 interpreter at: {python_3_13_executable}")
                            command = [python_3_13_executable, "-m", "venv", str(env_path)]
                            try:
                                subprocess.run(command, check=True, text=True,
                                               stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                                print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' created at {env_path} using Python 3.13.")

                                try:
                                    active = find_active_env(str(env_path))
                                    set_python_path(active)
                                    print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                                except Exception as e:
                                    print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                                # 3. Nach weiteren venvs im Verzeichnis suchen
                                existing_venvs = find_existing_venvs(current_dir)
                                other_venvs = [name for name in existing_venvs if name != user_input]

                                if other_venvs:
                                    print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                            except subprocess.CalledProcessError as e:
                                print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                            except KeyboardInterrupt:
                                print(f"[{timestamp()}] [INFO] Operation cancelled by user.")
                            except Exception as e:
                                print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

                    except subprocess.CalledProcessError:
                        print(f"[{timestamp()}] [ERROR] Failed to execute 'where python3.13'. Make sure Python 3.13 is installed and accessible.")

            elif user_input.startswith("pp-pcv-p313 "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[12:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # 1. Prüfen, ob Environment bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing environment: {e}")
                else:
                    # 2. Nach Python 3.13 suchen
                    try:
                        result = subprocess.run(["where", "python3.13"], capture_output=True, text=True, check=True)
                        paths = result.stdout.strip().splitlines()
                        python_3_13_executable = None
                        for p in paths:
                            if Path(p).exists():
                                python_3_13_executable = p
                                break

                        if not python_3_13_executable:
                            print(f"[{timestamp()}] [ERROR] Python 3.13 executable not found on the system.")
                        else:
                            print(f"[{timestamp()}] [INFO] Found Python 3.13 interpreter at: {python_3_13_executable}")
                            command = f'"{python_3_13_executable}" -m venv "{env_path}"'
                            try:
                                subprocess.run(command, shell=True, check=True, text=True,
                                               stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                                print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' created at {env_path} using Python 3.13.")

                                try:
                                    active = find_active_env(str(env_path))
                                    set_python_path(active)
                                    print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                                except Exception as e:
                                    print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                                # 3. Nach weiteren venvs im Verzeichnis suchen
                                existing_venvs = find_existing_venvs(current_dir)
                                other_venvs = [name for name in existing_venvs if name != user_input]

                                if other_venvs:
                                    print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                            except subprocess.CalledProcessError as e:
                                print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                            except KeyboardInterrupt:
                                print(f"[{timestamp()}] [INFO] Operation cancelled by user.")
                            except Exception as e:
                                print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

                    except subprocess.CalledProcessError:
                        print(f"[{timestamp()}] [ERROR] Failed to execute 'where python3.13'. Make sure Python 3.13 is installed and accessible.")

            elif user_input.startswith("pcv-p312 "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[9:].strip()
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # 1. Prüfen, ob Environment bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing environment: {e}")
                else:
                    # 2. Nach Python 3.12 suchen
                    try:
                        result = subprocess.run(["where", "python3.12"], capture_output=True, text=True, check=True)
                        paths = result.stdout.strip().splitlines()
                        python_3_12_executable = None
                        for p in paths:
                            if Path(p).exists():
                                python_3_12_executable = p
                                break

                        if not python_3_12_executable:
                            print(f"[{timestamp()}] [ERROR] Python 3.12 executable not found on the system.")
                        else:
                            print(f"[{timestamp()}] [INFO] Found Python 3.12 interpreter at: {python_3_12_executable}")
                            command = [python_3_12_executable, "-m", "venv", str(env_path)]
                            try:
                                subprocess.run(command, check=True, text=True,
                                               stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                                print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' created at {env_path} using Python 3.12.")

                                try:
                                    active = find_active_env(str(env_path))
                                    set_python_path(active)
                                    print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                                except Exception as e:
                                    print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                                # 3. Nach weiteren venvs im Verzeichnis suchen
                                existing_venvs = find_existing_venvs(current_dir)
                                other_venvs = [name for name in existing_venvs if name != user_input]

                                if other_venvs:
                                    print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                            except subprocess.CalledProcessError as e:
                                print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                            except KeyboardInterrupt:
                                print(f"[{timestamp()}] [INFO] Operation cancelled by user.")
                            except Exception as e:
                                print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

                    except subprocess.CalledProcessError:
                        print(f"[{timestamp()}] [ERROR] Failed to execute 'where python3.12'. Make sure Python 3.12 is installed and accessible.")

            elif user_input.startswith("pp-pcv-p312 "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[12:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # 1. Prüfen, ob Environment bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing environment: {e}")
                else:
                    # 2. Nach Python 3.12 suchen
                    try:
                        result = subprocess.run(["where", "python3.12"], capture_output=True, text=True, check=True)
                        paths = result.stdout.strip().splitlines()
                        python_3_12_executable = None
                        for p in paths:
                            if Path(p).exists():
                                python_3_12_executable = p
                                break

                        if not python_3_12_executable:
                            print(f"[{timestamp()}] [ERROR] Python 3.12 executable not found on the system.")
                        else:
                            print(f"[{timestamp()}] [INFO] Found Python 3.12 interpreter at: {python_3_12_executable}")
                            command = f'"{python_3_12_executable}" -m venv "{env_path}"'
                            try:
                                subprocess.run(command, shell=True, check=True, text=True,
                                               stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                                print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' created at {env_path} using Python 3.12.")

                                try:
                                    active = find_active_env(str(env_path))
                                    set_python_path(active)
                                    print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                                except Exception as e:
                                    print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                                # 3. Nach weiteren venvs im Verzeichnis suchen
                                existing_venvs = find_existing_venvs(current_dir)
                                other_venvs = [name for name in existing_venvs if name != user_input]

                                if other_venvs:
                                    print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                            except subprocess.CalledProcessError as e:
                                print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                            except KeyboardInterrupt:
                                print(f"[{timestamp()}] [INFO] Operation cancelled by user.")
                            except Exception as e:
                                print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

                    except subprocess.CalledProcessError:
                        print(f"[{timestamp()}] [ERROR] Failed to execute 'where python3.12'. Make sure Python 3.12 is installed and accessible.")

            elif user_input.startswith("pcv-p311 "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[9:].strip()
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # 1. Prüfen, ob Environment bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing environment: {e}")
                else:
                    # 2. Nach Python 3.11 suchen
                    try:
                        result = subprocess.run(["where", "python3.11"], capture_output=True, text=True, check=True)
                        paths = result.stdout.strip().splitlines()
                        python_3_11_executable = None
                        for p in paths:
                            if Path(p).exists():
                                python_3_11_executable = p
                                break

                        if not python_3_11_executable:
                            print(f"[{timestamp()}] [ERROR] Python 3.11 executable not found on the system.")
                        else:
                            print(f"[{timestamp()}] [INFO] Found Python 3.11 interpreter at: {python_3_11_executable}")
                            command = [python_3_11_executable, "-m", "venv", str(env_path)]
                            try:
                                subprocess.run(command, check=True, text=True,
                                               stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                                print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' created at {env_path} using Python 3.11.")

                                try:
                                    active = find_active_env(str(env_path))
                                    set_python_path(active)
                                    print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                                except Exception as e:
                                    print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                                # 3. Weitere vorhandene Environments auflisten
                                existing_venvs = find_existing_venvs(current_dir)
                                other_venvs = [name for name in existing_venvs if name != user_input]

                                if other_venvs:
                                    print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                            except subprocess.CalledProcessError as e:
                                print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                            except KeyboardInterrupt:
                                print(f"[{timestamp()}] [INFO] Operation cancelled by user.")
                            except Exception as e:
                                print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

                    except subprocess.CalledProcessError:
                        print(f"[{timestamp()}] [ERROR] Failed to execute 'where python3.11'. Make sure Python 3.11 is installed and accessible.")

            elif user_input.startswith("pp-pcv-p311 "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[12:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # 1. Prüfen, ob Environment bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing environment: {e}")
                else:
                    # 2. Nach Python 3.11 suchen
                    try:
                        result = subprocess.run(["where", "python3.11"], capture_output=True, text=True, check=True)
                        paths = result.stdout.strip().splitlines()
                        python_3_11_executable = None
                        for p in paths:
                            if Path(p).exists():
                                python_3_11_executable = p
                                break

                        if not python_3_11_executable:
                            print(f"[{timestamp()}] [ERROR] Python 3.11 executable not found on the system.")
                        else:
                            print(f"[{timestamp()}] [INFO] Found Python 3.11 interpreter at: {python_3_11_executable}")
                            command = f'"{python_3_11_executable}" -m venv "{env_path}"'
                            try:
                                subprocess.run(command, shell=True, check=True, text=True,
                                               stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                                print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' created at {env_path} using Python 3.11.")

                                try:
                                    active = find_active_env(str(env_path))
                                    set_python_path(active)
                                    print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                                except Exception as e:
                                    print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                                # 3. Weitere vorhandene Environments auflisten
                                existing_venvs = find_existing_venvs(current_dir)
                                other_venvs = [name for name in existing_venvs if name != user_input]

                                if other_venvs:
                                    print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                            except subprocess.CalledProcessError as e:
                                print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                            except KeyboardInterrupt:
                                print(f"[{timestamp()}] [INFO] Operation cancelled by user.")
                            except Exception as e:
                                print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

                    except subprocess.CalledProcessError:
                        print(f"[{timestamp()}] [ERROR] Failed to execute 'where python3.11'. Make sure Python 3.11 is installed and accessible.")

            elif user_input.startswith("pcv-p310 "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[9:].strip()
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # 1. Prüfen, ob Environment bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing environment: {e}")
                else:
                    # 2. Nach Python 3.10 suchen
                    try:
                        result = subprocess.run(["where", "python3.10"], capture_output=True, text=True, check=True)
                        paths = result.stdout.strip().splitlines()
                        python_3_10_executable = None
                        for p in paths:
                            if Path(p).exists():
                                python_3_10_executable = p
                                break

                        if not python_3_10_executable:
                            print(f"[{timestamp()}] [ERROR] Python 3.10 executable not found on the system.")
                        else:
                            print(f"[{timestamp()}] [INFO] Found Python 3.10 interpreter at: {python_3_10_executable}")
                            command = [python_3_10_executable, "-m", "venv", str(env_path)]
                            try:
                                subprocess.run(command, check=True, text=True,
                                               stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                                print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' created at {env_path} using Python 3.10.")

                                try:
                                    active = find_active_env(str(env_path))
                                    set_python_path(active)
                                    print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                                except Exception as e:
                                    print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                                # 3. Weitere vorhandene Environments auflisten
                                existing_venvs = find_existing_venvs(current_dir)
                                other_venvs = [name for name in existing_venvs if name != user_input]

                                if other_venvs:
                                    print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                            except subprocess.CalledProcessError as e:
                                print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                            except KeyboardInterrupt:
                                print(f"[{timestamp()}] [INFO] Operation cancelled by user.")
                            except Exception as e:
                                print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

                    except subprocess.CalledProcessError:
                        print(f"[{timestamp()}] [ERROR] Failed to execute 'where python3.10'. Make sure Python 3.10 is installed and accessible.")

            elif user_input.startswith("pp-pcv-p310 "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[12:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # 1. Prüfen, ob Environment bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing environment: {e}")
                else:
                    # 2. Nach Python 3.10 suchen
                    try:
                        result = subprocess.run(["where", "python3.10"], capture_output=True, text=True, check=True)
                        paths = result.stdout.strip().splitlines()
                        python_3_10_executable = None
                        for p in paths:
                            if Path(p).exists():
                                python_3_10_executable = p
                                break

                        if not python_3_10_executable:
                            print(f"[{timestamp()}] [ERROR] Python 3.10 executable not found on the system.")
                        else:
                            print(f"[{timestamp()}] [INFO] Found Python 3.10 interpreter at: {python_3_10_executable}")
                            command = f'"{python_3_10_executable}" -m venv "{env_path}"'
                            try:
                                subprocess.run(command, shell=True, check=True, text=True,
                                               stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                                print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' created at {env_path} using Python 3.10.")

                                try:
                                    active = find_active_env(str(env_path))
                                    set_python_path(active)
                                    print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                                except Exception as e:
                                    print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                                # 3. Weitere vorhandene Environments auflisten
                                existing_venvs = find_existing_venvs(current_dir)
                                other_venvs = [name for name in existing_venvs if name != user_input]

                                if other_venvs:
                                    print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                            except subprocess.CalledProcessError as e:
                                print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                            except KeyboardInterrupt:
                                print(f"[{timestamp()}] [INFO] Operation cancelled by user.")
                            except Exception as e:
                                print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

                    except subprocess.CalledProcessError:
                        print(f"[{timestamp()}] [ERROR] Failed to execute 'where python3.10'. Make sure Python 3.10 is installed and accessible.")

            elif user_input.startswith("pcv-p309 "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[9:].strip()
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # 1. Prüfen, ob Environment bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing environment: {e}")
                else:
                    # 2. Nach Python 3.9 suchen
                    try:
                        result = subprocess.run(["where", "python3.9"], capture_output=True, text=True, check=True)
                        paths = result.stdout.strip().splitlines()
                        python_3_9_executable = None
                        for p in paths:
                            if Path(p).exists():
                                python_3_9_executable = p
                                break

                        if not python_3_9_executable:
                            print(f"[{timestamp()}] [ERROR] Python 3.9 executable not found on the system.")
                        else:
                            print(f"[{timestamp()}] [INFO] Found Python 3.9 interpreter at: {python_3_9_executable}")
                            command = [python_3_9_executable, "-m", "venv", str(env_path)]
                            try:
                                subprocess.run(command, check=True, text=True,
                                               stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                                print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' created at {env_path} using Python 3.9.")

                                try:
                                    active = find_active_env(str(env_path))
                                    set_python_path(active)
                                    print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                                except Exception as e:
                                    print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                                # 3. Weitere vorhandene Environments auflisten
                                existing_venvs = find_existing_venvs(current_dir)
                                other_venvs = [name for name in existing_venvs if name != user_input]

                                if other_venvs:
                                    print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                            except subprocess.CalledProcessError as e:
                                print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                            except KeyboardInterrupt:
                                print(f"[{timestamp()}] [INFO] Operation cancelled by user.")
                            except Exception as e:
                                print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

                    except subprocess.CalledProcessError:
                        print(f"[{timestamp()}] [ERROR] Failed to execute 'where python3.9'. Make sure Python 3.9 is installed and accessible.")

            elif user_input.startswith("pp-pcv-p309 "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[12:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # 1. Prüfen, ob Environment bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing environment: {e}")
                else:
                    # 2. Nach Python 3.9 suchen
                    try:
                        result = subprocess.run(["where", "python3.9"], capture_output=True, text=True, check=True)
                        paths = result.stdout.strip().splitlines()
                        python_3_9_executable = None
                        for p in paths:
                            if Path(p).exists():
                                python_3_9_executable = p
                                break

                        if not python_3_9_executable:
                            print(f"[{timestamp()}] [ERROR] Python 3.9 executable not found on the system.")
                        else:
                            print(f"[{timestamp()}] [INFO] Found Python 3.9 interpreter at: {python_3_9_executable}")
                            command = f'"{python_3_9_executable}" -m venv "{env_path}"'
                            try:
                                subprocess.run(command, shell=True, check=True, text=True,
                                               stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                                print(f"[{timestamp()}] [INFO] Virtual environment '{user_input}' created at {env_path} using Python 3.9.")

                                try:
                                    active = find_active_env(str(env_path))
                                    set_python_path(active)
                                    print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                                except Exception as e:
                                    print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                                # 3. Weitere vorhandene Environments auflisten
                                existing_venvs = find_existing_venvs(current_dir)
                                other_venvs = [name for name in existing_venvs if name != user_input]

                                if other_venvs:
                                    print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                            except subprocess.CalledProcessError as e:
                                print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                            except KeyboardInterrupt:
                                print(f"[{timestamp()}] [INFO] Operation cancelled by user.")
                            except Exception as e:
                                print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

                    except subprocess.CalledProcessError:
                        print(f"[{timestamp()}] [ERROR] Failed to execute 'where python3.9'. Make sure Python 3.9 is installed and accessible.")

            elif user_input.lower() == "pv-info":
                active_env_path = Path(find_active_env()).resolve()
                print(f"[{timestamp()}] [INFO] Active environment: '{active_env_path}'.")

            elif user_input.startswith("p-venv-create "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[14:].strip()
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # Prüfen, ob dieses venv bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] The virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing venv: {e}")
                else:
                    # venv erstellen
                    command = ["python", "-m", "venv", str(env_path)]
                    try:
                        subprocess.run(command, check=True, text=True,
                                       stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                        print(f"[{timestamp()}] [INFO] The virtual environment '{user_input}' was created at {env_path}.")

                        try:
                            active = find_active_env(str(env_path))
                            set_python_path(active)
                            print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                        except Exception as e:
                            print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                        # Nach anderen vorhandenen venvs im aktuellen Verzeichnis suchen
                        existing_venvs = find_existing_venvs(current_dir)
                        other_venvs = [name for name in existing_venvs if name != user_input]

                        if other_venvs:
                            print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                    except subprocess.CalledProcessError as e:
                        print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                    except KeyboardInterrupt:
                        print(f"[{timestamp()}] [INFO] Cancelled by user.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

            elif user_input.startswith("pp-p-venv-create "):
                def find_existing_venvs(directory: Path):
                    venvs = []
                    for item in directory.iterdir():
                        if item.is_dir() and (item / "pyvenv.cfg").exists():
                            venvs.append(item.name)
                    return venvs

                user_input = user_input[17:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                current_dir = Path.cwd()
                env_path = (current_dir / user_input).resolve()

                # Prüfen, ob dieses venv bereits existiert
                if (env_path / "pyvenv.cfg").exists():
                    print(f"[{timestamp()}] [INFO] The virtual environment '{user_input}' already exists at {env_path}.")
                    try:
                        active = find_active_env(str(env_path))
                        set_python_path(active)
                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Failed to activate existing venv: {e}")
                else:
                    # venv erstellen
                    command = f'python -m venv "{env_path}"'
                    try:
                        subprocess.run(command, shell=True, check=True, text=True,
                                       stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

                        print(f"[{timestamp()}] [INFO] The virtual environment '{user_input}' was created at {env_path}.")

                        try:
                            active = find_active_env(str(env_path))
                            set_python_path(active)
                            print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                        except Exception as e:
                            print(f"[{timestamp()}] [ERROR] Failed to set active environment: {e}")

                        # Nach anderen vorhandenen venvs im aktuellen Verzeichnis suchen
                        existing_venvs = find_existing_venvs(current_dir)
                        other_venvs = [name for name in existing_venvs if name != user_input]

                        if other_venvs:
                            print(f"[{timestamp()}] [INFO] Other virtual environments found in this directory: {', '.join(other_venvs)}")

                    except subprocess.CalledProcessError as e:
                        print(f"[{timestamp()}] [ERROR] Failed to create venv '{user_input}': {e}")
                    except KeyboardInterrupt:
                        print(f"[{timestamp()}] [INFO] Cancelled by user.")
                    except Exception as e:
                        print(f"[{timestamp()}] [ERROR] Unexpected error: {e}")

            elif user_input.startswith("p-venv "):
                env_name = user_input[7:].strip()
                env_path = (current_dir / env_name).resolve()

                if not env_path.exists():
                    print(f"[{timestamp()}] [INFO] Environment '{env_name}' does not exist at '{env_path}'.")
                    user_confirm = input("Do you want to create this virtual environment? [y/n]: ").strip().lower()
                    if user_confirm == 'y':
                        command = ["python", "-m", "venv", str(env_path)]
                        try:
                            subprocess.run(command, check=True, text=True,
                                           stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)
                            print(f"[{timestamp()}] [INFO] The '{env_name}' venv was created at {env_path}.")
                        except subprocess.CalledProcessError as e:
                            print(f"[{timestamp()}] [ERROR] Failed to create venv: {e}")
                            continue
                    else:
                        print(f"[{timestamp()}] [INFO] Activation cancelled.")
                        continue

                if os.name == "nt":
                    python_exe = env_path / "Scripts" / "python.exe"
                else:
                    python_exe = env_path / "bin" / "python"

                if not python_exe.exists():
                    print(f"[{timestamp()}] [INFO] No Python interpreter found in '{python_exe}'.")
                    user_confirm = input("Do you still want to activate this environment? [y/N)] ").strip().lower()
                    if user_confirm != 'y':
                        print(f"[{timestamp()}] [INFO] Activation cancelled.")
                        continue

                # setzt und speichert das aktive Env
                active = find_active_env(env_path)
                set_python_path(active)

                print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")

            elif user_input.startswith("pp-p-venv "):
                env_name = user_input[10:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                env_path = (current_dir / env_name).resolve()

                if not env_path.exists():
                    print(f"[{timestamp()}] [INFO] Environment '{env_name}' does not exist at '{env_path}'.")
                    user_confirm = input("Do you want to create this virtual environment? [y/n]: ").strip().lower()
                    if user_confirm == 'y':
                        command = f'python -m venv "{env_path}"'
                        try:
                            subprocess.run(command, shell=True, check=True, text=True,
                                           stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)
                            print(f"[{timestamp()}] [INFO] The '{env_name}' venv was created at {env_path}.")
                        except subprocess.CalledProcessError as e:
                            print(f"[{timestamp()}] [ERROR] Failed to create venv: {e}")
                            continue
                    else:
                        print(f"[{timestamp()}] [INFO] Activation cancelled.")
                        continue

                if os.name == "nt":
                    python_exe = env_path / "Scripts" / "python.exe"
                else:
                    python_exe = env_path / "bin" / "python"

                if not python_exe.exists():
                    print(f"[{timestamp()}] [INFO] No Python interpreter found in '{python_exe}'.")
                    user_confirm = input("Do you still want to activate this environment? [y/N)] ").strip().lower()
                    if user_confirm != 'y':
                        print(f"[{timestamp()}] [INFO] Activation cancelled.")
                        continue

                # setzt und speichert das aktive Env
                active = find_active_env(env_path)
                set_python_path(active)

                print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")

            elif user_input.startswith("pav "):
                env_name = user_input[4:].strip()
                env_path = (current_dir / env_name).resolve()

                if not env_path.exists():
                    print(f"[{timestamp()}] [INFO] Environment '{env_name}' does not exist at '{env_path}'.")
                    user_confirm = input("Do you want to create this virtual environment? [y/n]: ").strip().lower()
                    if user_confirm == 'y':
                        command = ["python", "-m", "venv", str(env_path)]
                        try:
                            subprocess.run(command, check=True, text=True,
                                           stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)
                            print(f"[{timestamp()}] [INFO] The '{env_name}' venv was created at {env_path}.")
                        except subprocess.CalledProcessError as e:
                            print(f"[{timestamp()}] [ERROR] Failed to create venv: {e}")
                            continue
                    else:
                        print(f"[{timestamp()}] [INFO] Activation cancelled.")
                        continue

                if os.name == "nt":
                    python_exe = env_path / "Scripts" / "python.exe"
                else:
                    python_exe = env_path / "bin" / "python"

                if not python_exe.exists():
                    print(f"[{timestamp()}] [INFO] No Python interpreter found in '{python_exe}'.")
                    user_confirm = input("Do you still want to activate this environment? [y/N)] ").strip().lower()
                    if user_confirm != 'y':
                        print(f"[{timestamp()}] [INFO] Activation cancelled.")
                        continue

                # setzt und speichert das aktive Env
                active = find_active_env(env_path)
                set_python_path(active)

                print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")

            elif user_input.startswith("pp-pav "):
                env_name = user_input[7:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                env_path = (current_dir / env_name).resolve()

                if not env_path.exists():
                    print(f"[{timestamp()}] [INFO] Environment '{env_name}' does not exist at '{env_path}'.")
                    user_confirm = input("Do you want to create this virtual environment? [y/n]: ").strip().lower()
                    if user_confirm == 'y':
                        command = f'python -m venv "{env_path}"'
                        try:
                            subprocess.run(command, shell=True, check=True, text=True,
                                           stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)
                            print(f"[{timestamp()}] [INFO] The '{env_name}' venv was created at {env_path}.")
                        except subprocess.CalledProcessError as e:
                            print(f"[{timestamp()}] [ERROR] Failed to create venv: {e}")
                            continue
                    else:
                        print(f"[{timestamp()}] [INFO] Activation cancelled.")
                        continue

                if os.name == "nt":
                    python_exe = env_path / "Scripts" / "python.exe"
                else:
                    python_exe = env_path / "bin" / "python"

                if not python_exe.exists():
                    print(f"[{timestamp()}] [INFO] No Python interpreter found in '{python_exe}'.")
                    user_confirm = input("Do you still want to activate this environment? [y/N)] ").strip().lower()
                    if user_confirm != 'y':
                        print(f"[{timestamp()}] [INFO] Activation cancelled.")
                        continue

                # setzt und speichert das aktive Env
                active = find_active_env(env_path)
                set_python_path(active)

                print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")

            elif user_input.strip() == "psv":
                # Suche nach dem ersten venv im gesamten Verzeichnisbaum ab current_dir
                found = False
                for root, dirs, files in os.walk(current_dir):
                    if "pyvenv.cfg" in files:
                        env_path = Path(root).resolve()

                        # setzt und speichert das aktive Env
                        active = find_active_env(str(env_path))
                        set_python_path(active)

                        print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")
                        found = True
                        break

                if not found:
                    print(f"[{timestamp()}] [INFO] No virtual environment found in current directory tree.")

            elif user_input.strip() == "plv":
                print(f"[{timestamp()}] [INFO] Searching for virtual environments in '{current_dir}'...\n")
                venvs = []

                for item in current_dir.rglob("pyvenv.cfg"):
                    env_path = item.parent.resolve()
                    venvs.append(env_path)

                if venvs:
                    print(f"[{timestamp()}] [INFO] Found {len(venvs)} virtual environment(s):\n")
                    for i, env in enumerate(venvs, 1):
                        print(f"  {main_color}[{i}]{reset} {env}")
                else:
                    print(f"[{timestamp()}] [INFO] No virtual environments found in directory tree.")

            elif user_input.strip() == "psvls":
                print(f"[{timestamp()}] [INFO] Searching for virtual environments in '{current_dir}'...\n")
                venvs = []

                for item in current_dir.rglob("pyvenv.cfg"):
                    env_path = item.parent.resolve()
                    venvs.append(env_path)

                if venvs:
                    print(f"[{timestamp()}] [INFO] Found {len(venvs)} virtual environment(s):\n")
                    for i, env in enumerate(venvs, 1):
                        print(f"  {main_color}[{i}]{reset} {env}")
                else:
                    print(f"[{timestamp()}] [INFO] No virtual environments found in directory tree.")

            elif user_input.strip() == "ps&av":
                print(f"[{timestamp()}] [INFO] Searching for virtual environments in '{current_dir}'...\n")
                venvs = []

                # Suche nach pyvenv.cfg-Dateien als Hinweis auf virtuelle Umgebungen
                for item in current_dir.rglob("pyvenv.cfg"):
                    env_path = item.parent.resolve()
                    venvs.append(env_path)

                if venvs:
                    print(f"[{timestamp()}] [INFO] Found {len(venvs)} virtual environment(s):\n")
                    for i, env in enumerate(venvs, 1):
                        print(f"  {main_color}[{i}]{reset} {env}")

                    # Benutzer zur Auswahl auffordern
                    while True:
                        try:
                            selection = int(input("\nWhich environment do you want to activate? Enter the number: "))
                            if 1 <= selection <= len(venvs):
                                selected_env = venvs[selection - 1]
                                env_path = str(selected_env.resolve())

                                # Aktive Umgebung setzen und speichern
                                active = find_active_env(env_path)
                                set_python_path(active)

                                print(f"\n[{timestamp()}] [INFO] Active environment set to '{active}'.")
                                break
                            else:
                                print(f"[{timestamp()}] [INFO] Invalid selection. Please enter a number from the list.")
                        except ValueError:
                            print(f"[{timestamp()}] [INFO] Please enter a valid number.")
                else:
                    print(f"[{timestamp()}] [INFO] No virtual environments found in directory tree.")

            elif user_input.startswith("p-venv-f "):
                env_name = user_input[9:].strip()
                env_path = str(env_name)

                # setzt und speichert das aktive Env
                active = find_active_env(env_path)
                set_python_path(active)

                print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")

            elif user_input.startswith("pavf "):
                env_name = user_input[5:].strip()
                env_path = str(env_name)

                # setzt und speichert das aktive Env
                active = find_active_env(env_path)
                set_python_path(active)

                print(f"[{timestamp()}] [INFO] Active environment set to '{active}'.")

            elif user_input.startswith("pov "):
                user_input = user_input[4:]
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
                print(f"[{timestamp()}] [INFO] Please note that the pov command supports only CMD commands, no PP terminal and the command was specifically developed for managing virtual environments, so not all CMD commands may be compatible.")
                run_command_ov(user_input, shell=True)

            elif user_input.startswith("pp-pov "):
                user_input = user_input[7:]
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                print(f"[{timestamp()}] [INFO] Please note that the pov command supports only CMD commands, no PP terminal and the command was specifically developed for managing virtual environments, so not all CMD commands may be compatible.")
                run_command_ov(user_input, shell=True)

            elif user_input.startswith("pp "):
                user_input = user_input[3:]
                run_command_with_admin_python_privileges(user_input)

            elif user_input.startswith("pp-rm "):
                user_input_file = user_input[6:]
                user_input = f"Remove-Item -LiteralPath '{current_dir}\\{user_input_file}' -Recurse -Force"
                run_command_with_admin_python_privileges(user_input)

            elif user_input.startswith("pp-prm "):
                user_input_file = user_input[7:]
                user_input = f"Remove-Item -LiteralPath '{current_dir}\\{user_input_file}' -Recurse -Force"
                run_command_with_admin_python_privileges(user_input)

            elif user_input.startswith("pp-open "):
                user_input_file = user_input[6:]
                user_input = f"Invoke-Item '{current_dir}\\{user_input_file}'"
                run_command_with_admin_python_privileges(user_input)

            elif user_input.startswith("pp-run "):
                user_input_file = user_input[7:]
                user_input = f"Start-Process '{current_dir}\\{user_input_file}'"
                run_command_with_admin_python_privileges(user_input)

            elif user_input.startswith("pp-pr "):
                user_input_file = user_input[6:]
                user_input = f"Start-Process '{current_dir}\\{user_input_file}'"
                run_command_with_admin_python_privileges(user_input)

            elif user_input.startswith("pp-del "):
                user_input_file = user_input[7:]
                user_input = f"Remove-Item -LiteralPath '{current_dir}\\{user_input_file}' -Recurse -Force"
                run_command_with_admin_python_privileges(user_input)

            elif user_input.startswith("pp-pdel "):
                user_input_file = user_input[7:]
                user_input = f"Remove-Item -LiteralPath '{current_dir}\\{user_input_file}' -Recurse -Force"
                run_command_with_admin_python_privileges(user_input)

            elif user_input.startswith("pp-mkdir "):
                # Create new directory
                folder_name = user_input[9:].strip()
                folder_path = os.path.join(current_dir, folder_name)
                cmd = f"New-Item -ItemType Directory -Path '{folder_path}' -Force"
                run_command_with_admin_python_privileges(cmd)
                logging.info(f"[SUCCESS] Created folder: {folder_path}")

            elif user_input.startswith("pp-pcfo "):
                # Create new directory
                folder_name = user_input[8:].strip()
                folder_path = os.path.join(current_dir, folder_name)
                cmd = f"New-Item -ItemType Directory -Path '{folder_path}' -Force"
                run_command_with_admin_python_privileges(cmd)
                logging.info(f"[SUCCESS] Created folder: {folder_path}")

            elif user_input.startswith("pp-cp "):
                # Copy source to destination
                parts = user_input[6:].strip().split()
                if len(parts) < 2:
                    logging.info("[USAGE] pp-cp <source> <destination>")
                else:
                    source = os.path.join(current_dir, parts[0])
                    destination = os.path.join(current_dir, parts[1])
                    cmd = f"Copy-Item -Path '{source}' -Destination '{destination}' -Recurse -Force"
                    run_command_with_admin_python_privileges(cmd)
                    logging.info(f"[SUCCESS] Copied from '{source}' to '{destination}'")

            elif user_input.startswith("pp-mv "):
                # Move source to destination
                parts = user_input[6:].strip().split()
                if len(parts) < 2:
                    logging.info("[USAGE] pp-mv <source> <destination>")
                else:
                    source = os.path.join(current_dir, parts[0])
                    destination = os.path.join(current_dir, parts[1])
                    cmd = f"Move-Item -Path '{source}' -Destination '{destination}' -Force"
                    run_command_with_admin_python_privileges(cmd)
                    logging.info(f"[SUCCESS] Moved from '{source}' to '{destination}'")

            elif user_input.startswith("pp-touch "):
                # Create new empty file
                file_name = user_input[9:].strip()
                file_path = os.path.join(current_dir, file_name)
                cmd = f"New-Item -ItemType File -Path '{file_path}' -Force"
                run_command_with_admin_python_privileges(cmd)
                logging.info(f"[SUCCESS] Created file: {file_path}")

            elif user_input.startswith("pp-type "):
                # Display content of file
                file_name = user_input[8:].strip()
                file_path = os.path.join(current_dir, file_name)
                if not os.path.isfile(file_path):
                    logging.info(f"[ERROR] File not found: {file_path}")
                else:
                    cmd = f"Get-Content -Path '{file_path}'"
                    run_command_with_admin_python_privileges(cmd)

            elif user_input.startswith("pp-ptype "):
                # Display content of file
                file_name = user_input[9:].strip()
                file_path = os.path.join(current_dir, file_name)
                if not os.path.isfile(file_path):
                    logging.info(f"[ERROR] File not found: {file_path}")
                else:
                    cmd = f"Get-Content -Path '{file_path}'"
                    run_command_with_admin_python_privileges(cmd)

            elif user_input.startswith("pp-cat "):
                # Display content of file
                file_name = user_input[7:].strip()
                file_path = os.path.join(current_dir, file_name)
                if not os.path.isfile(file_path):
                    logging.info(f"[ERROR] File not found: {file_path}")
                else:
                    cmd = f"Get-Content -Path '{file_path}'"
                    run_command_with_admin_python_privileges(cmd)

            elif user_input.startswith("pp-pcat "):
                # Display content of file
                file_name = user_input[8:].strip()
                file_path = os.path.join(current_dir, file_name)
                if not os.path.isfile(file_path):
                    logging.info(f"[ERROR] File not found: {file_path}")
                else:
                    cmd = f"Get-Content -Path '{file_path}'"
                    run_command_with_admin_python_privileges(cmd)

            elif user_input.strip() == "pp-dir":
                # List directory contents
                cmd = f"Get-ChildItem -Path '{current_dir}'"
                run_command_with_admin_python_privileges(cmd)

            elif user_input.strip() == "pp-pdir":
                # List directory contents
                cmd = f"Get-ChildItem -Path '{current_dir}'"
                run_command_with_admin_python_privileges(cmd)

            elif user_input.strip() == "pp-ls":
                # List directory contents
                cmd = f"Get-ChildItem -Path '{current_dir}'"
                run_command_with_admin_python_privileges(cmd)

            elif user_input.strip() == "pp-pls":
                # List directory contents
                cmd = f"Get-ChildItem -Path '{current_dir}'"
                run_command_with_admin_python_privileges(cmd)

            elif user_input.startswith("pp-open "):
                # Open file with default app
                file_name = user_input[8:].strip()
                file_path = os.path.join(current_dir, file_name)
                if not os.path.exists(file_path):
                    logging.info(f"[ERROR] File does not exist: {file_path}")
                else:
                    cmd = f"Start-Process '{file_path}'"
                    run_command_with_admin_python_privileges(cmd)
                    logging.info(f"[SUCCESS] Opened: {file_path}")

            elif user_input.startswith("pp-zip "):
                parts = user_input[7:].strip().split()
                if len(parts) < 2:
                    logging.info("[USAGE] pp-zip <source_folder> <zip_filename>")
                else:
                    source = os.path.join(current_dir, parts[0])
                    zipfile = os.path.join(current_dir, parts[1])
                    cmd = f"Compress-Archive -Path '{source}\\*' -DestinationPath '{zipfile}' -Force"
                    run_command_with_admin_python_privileges(cmd)
                    logging.info(f"[SUCCESS] Compressed '{source}' → '{zipfile}'")

            elif user_input.startswith("pp-pz "):
                parts = user_input[6:].strip().split()
                if len(parts) < 2:
                    logging.info("[USAGE] pp-zip <source_folder> <zip_filename>")
                else:
                    source = os.path.join(current_dir, parts[0])
                    zipfile = os.path.join(current_dir, parts[1])
                    cmd = f"Compress-Archive -Path '{source}\\*' -DestinationPath '{zipfile}' -Force"
                    run_command_with_admin_python_privileges(cmd)
                    logging.info(f"[SUCCESS] Compressed '{source}' → '{zipfile}'")

            elif user_input.startswith("pp-unzip "):
                parts = user_input[9:].strip().split()
                if len(parts) < 2:
                    logging.info("[USAGE] pp-unzip <zip_file> <destination>")
                else:
                    zipfile = os.path.join(current_dir, parts[0])
                    destination = os.path.join(current_dir, parts[1])
                    cmd = f"Expand-Archive -Path '{zipfile}' -DestinationPath '{destination}' -Force"
                    run_command_with_admin_python_privileges(cmd)
                    logging.info(f"[SUCCESS] Extracted '{zipfile}' → '{destination}'")

            elif user_input.startswith("pp-puz "):
                parts = user_input[7:].strip().split()
                if len(parts) < 2:
                    logging.info("[USAGE] pp-unzip <zip_file> <destination>")
                else:
                    zipfile = os.path.join(current_dir, parts[0])
                    destination = os.path.join(current_dir, parts[1])
                    cmd = f"Expand-Archive -Path '{zipfile}' -DestinationPath '{destination}' -Force"
                    run_command_with_admin_python_privileges(cmd)
                    logging.info(f"[SUCCESS] Extracted '{zipfile}' → '{destination}'")

            elif user_input.startswith("pp-search "):
                keyword = user_input[10:].strip()
                cmd = f"Select-String -Path '{current_dir}\\*' -Pattern '{keyword}' -CaseSensitive:$false -SimpleMatch"
                run_command_with_admin_python_privileges(cmd)

            elif user_input.strip() == "pp-netstat":
                cmd = "netstat -ano"
                run_command_with_admin_python_privileges(cmd)

            elif user_input.startswith("pp-ping "):
                host = user_input[8:].strip()
                cmd = f"Test-Connection -ComputerName '{host}' -Count 4"
                run_command_with_admin_python_privileges(cmd)

            elif user_input.strip() == "pp-ipconfig":
                cmd = "ipconfig /all"
                run_command_with_admin_python_privileges(cmd)

            elif user_input.strip() == "pp-users":
                cmd = "Get-LocalUser | Format-Table Name,Enabled,LastLogon"
                run_command_with_admin_python_privileges(cmd)

            elif user_input.strip() == "pp-services":
                cmd = "Get-Service | Where-Object {$_.Status -eq 'Running'} | Sort-Object Status,DisplayName"
                run_command_with_admin_python_privileges(cmd)

            elif user_input.startswith("pp-kill "):
                target = user_input[8:].strip()
                if target.isdigit():
                    cmd = f"Stop-Process -Id {target} -Force"
                else:
                    cmd = f"Stop-Process -Name '{target}' -Force"
                run_command_with_admin_python_privileges(cmd)
                logging.info(f"[SUCCESS] Process '{target}' terminated.")

            elif user_input.strip() == "pp-procs":
                cmd = "Get-Process | Sort-Object CPU -Descending | Select-Object -First 15 Name,Id,CPU,WorkingSet"
                run_command_with_admin_python_privileges(cmd)

            elif user_input.startswith("pp-cpp "):
                user_input = user_input[7:]
                run_command_with_admin_privileges(user_input)

            elif user_input.startswith("pp-c "):
                user_input = user_input[5:]
                run_command_with_admin_c_privileges(user_input)

            elif user_input.startswith("pp-p "):
                user_input = user_input[5:]
                run_command_with_admin_python_privileges(user_input)

            elif user_input.startswith("pp-rust "):
                print(f"[{timestamp()}] [INFO] Please use the pp command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("powershell "):
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
                run_command(user_input, shell=True)

            elif user_input.startswith("pp-powershell "):
                user_input = user_input[3:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                run_command(user_input, shell=True)

            elif user_input.strip() == "powershell":
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
                run_command(user_input, shell=True)

            elif user_input.strip() == "pp-powershell":
                user_input = user_input[3:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                run_command(user_input, shell=True)

            elif user_input.strip() == "pwsh":
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
                run_command(user_input, shell=True)

            elif user_input.strip() == "pp-pwsh":
                user_input = user_input[3:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                run_command(user_input, shell=True)

            elif user_input.startswith("pwsh "):
                user_input = user_input[5:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
                run_command(["pwsh", "-Command", user_input], shell=True)

            elif user_input.startswith("pp-pwsh "):
                user_input = user_input[8:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                run_command(["pwsh", "-Command", user_input], shell=True)

            elif user_input.startswith("shell "):
                user_input = user_input[6:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
                run_command(user_input, shell=True)

            elif user_input.startswith("pp-shell "):
                user_input = user_input[9:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                run_command(user_input, shell=True)

            elif user_input.startswith("pps "):
                user_input = user_input[4:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
                run_command("powershell " + user_input, shell=True)

            elif user_input.startswith("pp-pps "):
                user_input = user_input[7:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                run_command("powershell " + user_input, shell=True)

            elif user_input.startswith("cmd "):
                user_input = user_input[4:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command using shell=True — necessary at this point, but potentially insecure.")
                run_command(user_input, shell=True)

            elif user_input.startswith("pp-cmd "):
                user_input = user_input[7:].strip()
                print(f"[{timestamp()}] [INFO] Executing a privileged (pp) command with shell=True — this can be insecure!")
                run_command(user_input, shell=True)

            elif user_input.startswith("ps "):
                user_input = user_input[3:].strip()
                search_websites(user_input)

            elif user_input.startswith("ps-all "):
                user_input = user_input[7:].strip()
                search_websites_all(user_input)

            elif user_input.startswith("ps-img "):
                user_input = user_input[7:].strip()
                search_and_show_first_image(user_input)

            elif user_input.startswith("ps-github "):
                user_input = user_input[10:].strip()
                search_github(user_input)

            elif user_input.startswith("ps-huggingface "):
                user_input = user_input[15:].strip()
                search_huggingface(user_input)

            elif user_input.startswith("ps-ollama "):
                user_input = user_input[10:].strip()
                search_ollama(user_input)

            elif user_input.startswith("ps-stackoverflow "):
                user_input = user_input[17:].strip()
                search_stackoverflow(user_input)

            elif user_input.startswith("ps-stackexchange "):
                user_input = user_input[17:].strip()
                search_stackexchange(user_input)

            elif user_input.startswith("ps-pypi "):
                user_input = user_input[8:].strip()
                search_pypi(user_input)

            elif user_input.startswith("ps-arxiv "):
                user_input = user_input[9:].strip()
                search_arxiv(user_input)

            elif user_input.startswith("ps-paperswithcode "):
                user_input = user_input[18:].strip()
                search_paperswithcode(user_input)

            elif user_input.startswith("ps-kaggle "):
                user_input = user_input[10:].strip()
                search_kaggle(user_input)

            elif user_input.startswith("ps-geeksforgeeks "):
                user_input = user_input[17:].strip()
                search_geeksforgeeks(user_input)

            elif user_input.startswith("ps-realpython "):
                user_input = user_input[14:].strip()
                search_realpython(user_input)

            elif user_input.startswith("ps-w3schools "):
                user_input = user_input[13:].strip()
                search_w3schools(user_input)

            elif user_input.startswith("ps-developer-mozilla "):
                user_input = user_input[21:].strip()
                search_developer_mozilla(user_input)

            elif user_input.startswith("lx "):
                user_input = user_input[3:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Linux: {user_input}")
                    run_linux_command(user_input)

            elif user_input.startswith("pl "):
                user_input = user_input[3:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Linux: {user_input}")
                    run_linux_command(user_input)

            elif user_input.startswith("lx-cpp "):
                user_input = user_input[7:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Linux: {user_input}")
                    run_linux_command(user_input)

            elif user_input.startswith("pl-cpp "):
                user_input = user_input[7:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Linux: {user_input}")
                    run_linux_command(user_input)

            elif user_input.startswith("lx-cpp-c "):
                user_input = user_input[9:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Linux: {user_input}")
                    run_linux_cpp_c_command(user_input)

            elif user_input.startswith("pl-cpp-c "):
                user_input = user_input[9:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Linux: {user_input}")
                    run_linux_cpp_c_command(user_input)

            elif user_input.startswith("lx-rust "):
                user_input = user_input[8:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the lx command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-rust "):
                user_input = user_input[8:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the lx command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("lx-rust-c "):
                user_input = user_input[10:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the lx command or compile the corresponding Rust file yourself with cargo...")


            elif user_input.startswith("pl-rust-c "):
                user_input = user_input[10:].strip()
                if not is_wsl_installed():
                    print(f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the lx command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("lx-c "):
                user_input = user_input[5:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Linux: {user_input}")
                    run_linux_c_command(user_input)

            elif user_input.startswith("pl-c "):
                user_input = user_input[5:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Linux: {user_input}")
                    run_linux_c_command(user_input)

            elif user_input.startswith("lx-c-c "):
                user_input = user_input[7:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Linux: {user_input}")
                    run_linux_c_c_command(user_input)

            elif user_input.startswith("pl-c-c "):
                user_input = user_input[7:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Linux: {user_input}")
                    run_linux_c_c_command(user_input)

            elif user_input.startswith("lx-p "):
                user_input = user_input[5:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Linux: {user_input}")
                    run_linux_python_command(user_input)

            elif user_input.startswith("pl-p "):
                user_input = user_input[5:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Linux: {user_input}")
                    run_linux_python_command(user_input)

            elif user_input.startswith("lx-p-c "):
                user_input = user_input[6:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Linux: {user_input}")
                    run_linux_p_c_command(user_input)

            elif user_input.startswith("pl-p-c "):
                user_input = user_input[6:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Linux: {user_input}")
                    run_linux_p_c_command(user_input)

            elif user_input.startswith("linux "):
                user_input = user_input[6:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Linux: {user_input}")
                    run_linux_command(user_input)

            elif user_input.startswith("ubuntu "):
                user_input = user_input[7:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Ubuntu: {user_input}")
                    run_ubuntu_command(user_input)

            elif user_input.startswith("pl-u "):
                user_input = user_input[5:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Ubuntu: {user_input}")
                    run_ubuntu_command(user_input)

            elif user_input.startswith("pl-ubuntu "):
                user_input = user_input[10:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Ubuntu: {user_input}")
                    run_ubuntu_command(user_input)

            elif user_input.startswith("ubuntu-rust "):
                user_input = user_input[12:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the ubuntu command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-u-rust "):
                user_input = user_input[10:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the ubuntu command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-ubuntu-rust "):
                user_input = user_input[15:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the ubuntu command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("ubuntu-c "):
                user_input = user_input[9:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Ubuntu: {user_input}")
                    run_ubuntu_c_command(user_input)

            elif user_input.startswith("pl-u-c "):
                user_input = user_input[7:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Ubuntu: {user_input}")
                    run_ubuntu_c_command(user_input)

            elif user_input.startswith("pl-ubuntu-c "):
                user_input = user_input[12:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Ubuntu: {user_input}")
                    run_ubuntu_c_command(user_input)


            elif user_input.startswith("ubuntu-p "):
                user_input = user_input[9:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Ubuntu: {user_input}")
                    run_ubuntu_python_command(user_input)

            elif user_input.startswith("pl-u-p "):
                user_input = user_input[9:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Ubuntu: {user_input}")
                    run_ubuntu_python_command(user_input)

            elif user_input.startswith("pl-ubuntu-p "):
                user_input = user_input[12:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Ubuntu: {user_input}")
                    run_ubuntu_python_command(user_input)

            elif user_input.startswith("debian "):
                user_input = user_input[7:].strip()  # Remove the "debian " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Debian: {user_input}")
                    run_debian_command(user_input)

            elif user_input.startswith("pl-d "):
                user_input = user_input[5:].strip()  # Remove the "debian " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Debian: {user_input}")
                    run_debian_command(user_input)

            elif user_input.startswith("pl-debian "):
                user_input = user_input[10:].strip()  # Remove the "debian " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Debian: {user_input}")
                    run_debian_command(user_input)

            elif user_input.startswith("debian-rust "):
                user_input = user_input[12:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the debian command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-d-rust "):
                user_input = user_input[10:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the debian command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-debian-rust "):
                user_input = user_input[15:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the debian command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("debian-c "):
                user_input = user_input[9:].strip()  # Remove the "debian " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Debian: {user_input}")
                    run_debian_c_command(user_input)

            elif user_input.startswith("pl-d-c "):
                user_input = user_input[7:].strip()  # Remove the "debian " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Debian: {user_input}")
                    run_debian_c_command(user_input)

            elif user_input.startswith("pl-debian-c "):
                user_input = user_input[12:].strip()  # Remove the "debian " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Debian: {user_input}")
                    run_debian_c_command(user_input)

            elif user_input.startswith("debian-p "):
                user_input = user_input[9:].strip()  # Remove the "debian " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Debian: {user_input}")
                    run_debian_python_command(user_input)

            elif user_input.startswith("pl-d-p "):
                user_input = user_input[7:].strip()  # Remove the "debian " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Debian: {user_input}")
                    run_debian_python_command(user_input)

            elif user_input.startswith("pl-debian-p "):
                user_input = user_input[12:].strip()  # Remove the "debian " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Debian: {user_input}")
                    run_debian_python_command(user_input)

            elif user_input.startswith("kali "):
                user_input = user_input[5:].strip()  # Remove the "kali " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Kali: {user_input}")
                    run_kali_command(user_input)

            elif user_input.startswith("pl-k "):
                user_input = user_input[5:].strip()  # Remove the "kali " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Kali: {user_input}")
                    run_kali_command(user_input)

            elif user_input.startswith("pl-kali "):
                user_input = user_input[8:].strip()  # Remove the "kali " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Kali: {user_input}")
                    run_kali_command(user_input)

            elif user_input.startswith("kali-rust "):
                user_input = user_input[10:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the kali command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-k-rust "):
                user_input = user_input[10:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the kali command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-kali-rust "):
                user_input = user_input[13:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the kali command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("kali-c "):
                user_input = user_input[7:].strip()  # Remove the "kali " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Kali: {user_input}")
                    run_kali_c_command(user_input)

            elif user_input.startswith("pl-k-c "):
                user_input = user_input[7:].strip()  # Remove the "kali " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Kali: {user_input}")
                    run_kali_c_command(user_input)

            elif user_input.startswith("pl-kali-c "):
                user_input = user_input[10:].strip()  # Remove the "kali " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Kali: {user_input}")
                    run_kali_c_command(user_input)

            elif user_input.startswith("kali-p "):
                user_input = user_input[7:].strip()  # Remove the "kali " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Kali: {user_input}")
                    run_kali_python_command(user_input)

            elif user_input.startswith("pl-k-p "):
                user_input = user_input[7:].strip()  # Remove the "kali " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Kali: {user_input}")
                    run_kali_python_command(user_input)

            elif user_input.startswith("pl-kali-p "):
                user_input = user_input[10:].strip()  # Remove the "kali " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Kali: {user_input}")
                    run_kali_python_command(user_input)

            elif user_input.startswith("hack "):
                user_input = user_input[5:].strip()  # Remove the "kali " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Kali: {user_input}")
                    run_kali_command(user_input)

            elif user_input.startswith("arch "):
                user_input = user_input[5:].strip()  # Remove the "arch " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Arch: {user_input}")
                    run_arch_command(user_input)

            elif user_input.startswith("pl-a "):
                user_input = user_input[5:].strip()  # Remove the "arch " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Arch: {user_input}")
                    run_arch_command(user_input)

            elif user_input.startswith("pl-arch "):
                user_input = user_input[8:].strip()  # Remove the "arch " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Arch: {user_input}")
                    run_arch_command(user_input)

            elif user_input.startswith("arch-rust "):
                user_input = user_input[10:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the arch command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-a-rust "):
                user_input = user_input[10:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the arch command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-arch-rust "):
                user_input = user_input[13:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the arch command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("arch-c "):
                user_input = user_input[7:].strip()  # Remove the "arch " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Arch: {user_input}")
                    run_arch_c_command(user_input)

            elif user_input.startswith("pl-a-c "):
                user_input = user_input[7:].strip()  # Remove the "arch " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Arch: {user_input}")
                    run_arch_c_command(user_input)

            elif user_input.startswith("pl-arch-c "):
                user_input = user_input[10:].strip()  # Remove the "arch " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Arch: {user_input}")
                    run_arch_c_command(user_input)

            elif user_input.startswith("arch-p "):
                user_input = user_input[7:].strip()  # Remove the "arch " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Arch: {user_input}")
                    run_arch_python_command(user_input)

            elif user_input.startswith("pl-a-p "):
                user_input = user_input[7:].strip()  # Remove the "arch " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Arch: {user_input}")
                    run_arch_python_command(user_input)

            elif user_input.startswith("pl-arch-p "):
                user_input = user_input[10:].strip()  # Remove the "arch " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Arch: {user_input}")
                    run_arch_python_command(user_input)

            elif user_input.startswith("openSUSE "):
                user_input = user_input[9:].strip()  # Remove the "openSUSE " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on openSUSE: {user_input}")
                    run_opensuse_command(user_input)

            elif user_input.startswith("pl-openSUSE "):
                user_input = user_input[12:].strip()  # Remove the "openSUSE " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on openSUSE: {user_input}")
                    run_opensuse_command(user_input)

            elif user_input.startswith("openSUSE-rust "):
                user_input = user_input[14:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the openSUSE command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-openSUSE-rust "):
                user_input = user_input[16:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the openSUSE command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("openSUSE-c "):
                user_input = user_input[11:].strip()  # Remove the "openSUSE " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on openSUSE: {user_input}")
                    run_opensuse_c_command(user_input)

            elif user_input.startswith("pl-openSUSE-c "):
                user_input = user_input[14:].strip()  # Remove the "openSUSE " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on openSUSE: {user_input}")
                    run_opensuse_c_command(user_input)

            elif user_input.startswith("openSUSE-p "):
                user_input = user_input[11:].strip()  # Remove the "openSUSE " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on openSUSE: {user_input}")
                    run_opensuse_python_command(user_input)

            elif user_input.startswith("pl-openSUSE-p "):
                user_input = user_input[14:].strip()  # Remove the "openSUSE " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on openSUSE: {user_input}")
                    run_opensuse_python_command(user_input)

            elif user_input.startswith("mint "):
                user_input = user_input[5:].strip()  # Remove the "mint " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on openSUSE: {user_input}")
                    run_mint_command(user_input)

            elif user_input.startswith("pl-mint "):
                user_input = user_input[8:].strip()  # Remove the "mint " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on openSUSE: {user_input}")
                    run_mint_command(user_input)

            elif user_input.startswith("mint-rust "):
                user_input = user_input[10:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the mint command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-mint-rust "):
                user_input = user_input[13:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the mint command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("mint-c "):
                user_input = user_input[7:].strip()  # Remove the "mint " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on openSUSE: {user_input}")
                    run_mint_c_command(user_input)

            elif user_input.startswith("pl-mint-c "):
                user_input = user_input[10:].strip()  # Remove the "mint " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on openSUSE: {user_input}")
                    run_mint_c_command(user_input)

            elif user_input.startswith("mint-p "):
                user_input = user_input[7:].strip()  # Remove the "mint " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on openSUSE: {user_input}")
                    run_mint_python_command(user_input)

            elif user_input.startswith("pl-mint-p "):
                user_input = user_input[10:].strip()  # Remove the "mint " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on openSUSE: {user_input}")
                    run_mint_python_command(user_input)

            elif user_input.startswith("fedora "):
                user_input = user_input[7:].strip()  # Remove the "fedora " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Fedora: {user_input}")
                    run_fedora_command(user_input)

            elif user_input.startswith("pl-fedora "):
                user_input = user_input[10:].strip()  # Remove the "fedora " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Fedora: {user_input}")
                    run_fedora_command(user_input)

            elif user_input.startswith("fedora-rust "):
                user_input = user_input[12:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the fedora command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-fedora-rust "):
                user_input = user_input[15:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the fedora command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("fedora-c "):
                user_input = user_input[9:].strip()  # Remove the "fedora " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Fedora: {user_input}")
                    run_fedora_c_command(user_input)

            elif user_input.startswith("pl-fedora-c "):
                user_input = user_input[12:].strip()  # Remove the "fedora " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Fedora: {user_input}")
                    run_fedora_c_command(user_input)

            elif user_input.startswith("fedora-p "):
                user_input = user_input[9:].strip()  # Remove the "fedora " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Fedora: {user_input}")
                    run_fedora_python_command(user_input)

            elif user_input.startswith("pl-fedora-p "):
                user_input = user_input[12:].strip()  # Remove the "fedora " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Fedora: {user_input}")
                    run_fedora_python_command(user_input)

            elif user_input.startswith("redhat "):
                user_input = user_input[7:].strip()  # Remove the "redhat " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on RedHat: {user_input}")
                    run_redhat_command(user_input)

            elif user_input.startswith("pl-redhat "):
                user_input = user_input[10:].strip()  # Remove the "redhat " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on RedHat: {user_input}")
                    run_redhat_command(user_input)

            elif user_input.startswith("redhat-rust "):
                user_input = user_input[12:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the redhat command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-redhat-rust "):
                user_input = user_input[15:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the redhat command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("redhat-c "):
                user_input = user_input[9:].strip()  # Remove the "redhat " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on RedHat: {user_input}")
                    run_redhat_c_command(user_input)

            elif user_input.startswith("pl-redhat-c "):
                user_input = user_input[12:].strip()  # Remove the "redhat " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on RedHat: {user_input}")
                    run_redhat_c_command(user_input)

            elif user_input.startswith("redhat-p "):
                user_input = user_input[9:].strip()  # Remove the "redhat " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on RedHat: {user_input}")
                    run_redhat_python_command(user_input)

            elif user_input.startswith("pl-redhat-p "):
                user_input = user_input[12:].strip()  # Remove the "redhat " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on RedHat: {user_input}")
                    run_redhat_python_command(user_input)

            elif user_input.startswith("sles "):
                user_input = user_input[5:].strip()  # Remove the "sles " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on SLES: {user_input}")
                    run_sles_command(user_input)

            elif user_input.startswith("pl-sles "):
                user_input = user_input[8:].strip()  # Remove the "sles " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on SLES: {user_input}")
                    run_sles_command(user_input)

            elif user_input.startswith("sles-rust "):
                user_input = user_input[10:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the sles command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-sles-rust "):
                user_input = user_input[13:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the sles command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("sles-c "):
                user_input = user_input[9:].strip()  # Remove the "sles " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on SLES: {user_input}")
                    run_sles_c_command(user_input)

            elif user_input.startswith("pl-sles-c "):
                user_input = user_input[12:].strip()  # Remove the "sles " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on SLES: {user_input}")
                    run_sles_c_command(user_input)

            elif user_input.startswith("sles-p "):
                user_input = user_input[9:].strip()  # Remove the "sles " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on SLES: {user_input}")
                    run_sles_python_command(user_input)

            elif user_input.startswith("pl-sles-p "):
                user_input = user_input[12:].strip()  # Remove the "sles " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on SLES: {user_input}")
                    run_sles_python_command(user_input)

            elif user_input.startswith("pengwin "):
                user_input = user_input[7:].strip()  # Remove the "pengwin " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Pengwin: {user_input}")
                    run_pengwin_command(user_input)

            elif user_input.startswith("pl-pengwin "):
                user_input = user_input[10:].strip()  # Remove the "pengwin " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Pengwin: {user_input}")
                    run_pengwin_command(user_input)

            elif user_input.startswith("pengwin-rust "):
                user_input = user_input[13:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the pengwin command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-pengwin-rust "):
                user_input = user_input[16:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the pengwin command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pengwin-c "):
                user_input = user_input[9:].strip()  # Remove the "pengwin " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Pengwin: {user_input}")
                    run_pengwin_c_command(user_input)

            elif user_input.startswith("pl-pengwin-c "):
                user_input = user_input[12:].strip()  # Remove the "pengwin " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Pengwin: {user_input}")
                    run_pengwin_c_command(user_input)

            elif user_input.startswith("pengwin-p "):
                user_input = user_input[9:].strip()  # Remove the "pengwin " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Pengwin: {user_input}")
                    run_pengwin_python_command(user_input)

            elif user_input.startswith("pl-pengwin-p "):
                user_input = user_input[12:].strip()  # Remove the "pengwin " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Pengwin: {user_input}")
                    run_pengwin_python_command(user_input)

            elif user_input.startswith("oracle "):
                user_input = user_input[7:].strip()  # Remove the "oracle " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Oracle: {user_input}")
                    run_oracle_command(user_input)

            elif user_input.startswith("pl-oracle "):
                user_input = user_input[10:].strip()  # Remove the "oracle " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Oracle: {user_input}")
                    run_oracle_command(user_input)

            elif user_input.startswith("oracle-rust "):
                user_input = user_input[12:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the oracle command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-oracle-rust "):
                user_input = user_input[15:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the oracle command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("oracle-c "):
                user_input = user_input[9:].strip()  # Remove the "oracle " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Oracle: {user_input}")
                    run_oracle_c_command(user_input)

            elif user_input.startswith("pl-oracle-c "):
                user_input = user_input[12:].strip()  # Remove the "oracle " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Oracle: {user_input}")
                    run_oracle_c_command(user_input)

            elif user_input.startswith("oracle-p "):
                user_input = user_input[9:].strip()  # Remove the "oracle " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Oracle: {user_input}")
                    run_oracle_python_command(user_input)

            elif user_input.startswith("pl-oracle-p "):
                user_input = user_input[12:].strip()  # Remove the "oracle " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Oracle: {user_input}")
                    run_oracle_python_command(user_input)

            elif user_input.startswith("alpine "):
                user_input = user_input[7:].strip()  # Remove the "alpine " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Alpine: {user_input}")
                    run_alpine_command(user_input)

            elif user_input.startswith("pl-alpine "):
                user_input = user_input[10:].strip()  # Remove the "alpine " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Alpine: {user_input}")
                    run_alpine_command(user_input)

            elif user_input.startswith("alpine-rust "):
                user_input = user_input[12:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the alpine command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-alpine-rust "):
                user_input = user_input[15:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the alpine command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("alpine-c "):
                user_input = user_input[9:].strip()  # Remove the "alpine " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Alpine: {user_input}")
                    run_alpine_c_command(user_input)

            elif user_input.startswith("pl-alpine-c "):
                user_input = user_input[12:].strip()  # Remove the "alpine " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Alpine: {user_input}")
                    run_alpine_c_command(user_input)

            elif user_input.startswith("alpine-p "):
                user_input = user_input[9:].strip()  # Remove the "alpine " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Alpine: {user_input}")
                    run_alpine_python_command(user_input)

            elif user_input.startswith("pl-alpine-p "):
                user_input = user_input[12:].strip()  # Remove the "alpine " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Alpine: {user_input}")
                    run_alpine_python_command(user_input)

            elif user_input.startswith("clear "):
                user_input = user_input[7:].strip()  # Remove the "clear " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Clear: {user_input}")
                    run_clear_command(user_input)

            elif user_input.startswith("pl-clear "):
                user_input = user_input[10:].strip()  # Remove the "clear " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Clear: {user_input}")
                    run_clear_command(user_input)

            elif user_input.startswith("clear-rust "):
                user_input = user_input[11:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the clear command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("pl-clear-rust "):
                user_input = user_input[14:].strip()
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Please use the clear command or compile the corresponding Rust file yourself with cargo...")

            elif user_input.startswith("clear-c "):
                user_input = user_input[9:].strip()  # Remove the "clear " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Clear: {user_input}")
                    run_clear_c_command(user_input)

            elif user_input.startswith("pl-clear-c "):
                user_input = user_input[12:].strip()  # Remove the "clear " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Clear: {user_input}")
                    run_clear_c_command(user_input)

            elif user_input.startswith("clear-p "):
                user_input = user_input[9:].strip()  # Remove the "clear " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Clear: {user_input}")
                    run_clear_python_command(user_input)

            elif user_input.startswith("pl-clear-p "):
                user_input = user_input[12:].strip()  # Remove the "clear " prefix
                if not is_wsl_installed():
                    print(
                        f"[{timestamp()}] [ERROR] WSL is not installed or could not be found. Please install WSL to use this feature.")
                else:
                    print(f"[{timestamp()}] [INFO] Executing the following command on Clear: {user_input}")
                    run_clear_python_command(user_input)

            elif user_input.startswith("sc "):
                user_input = user_input[3:].strip()
                print(f"[{timestamp()}] [INFO] Executing the following command with scoop: {user_input}")
                run_scoop_command(user_input)

            elif user_input.startswith("scoop "):
                user_input = user_input[6:].strip()
                print(f"[{timestamp()}] [INFO] Executing the following command with scoop: {user_input}")
                run_scoop_command(user_input)

            elif user_input.startswith("cho "):
                user_input = user_input[4:].strip()
                print(f"[{timestamp()}] [INFO] Executing the following command with choco: {user_input}")
                run_choco_command(user_input)

            elif user_input.startswith("choco "):
                user_input = user_input[6:].strip()
                print(f"[{timestamp()}] [INFO] Executing the following command with choco: {user_input}")
                run_choco_command(user_input)

            elif user_input.startswith("winget "):
                user_input = user_input[6:].strip()
                print(f"[{timestamp()}] [INFO] Executing the following command with winget : {user_input}")
                run_winget_command(user_input)

            elif user_input.startswith("ninite "):
                user_input = user_input[7:].strip()
                print(
                    f"[{timestamp()}] [INFO] Ninite doesn't support individual CLI commands per app. Launching Ninite installer or providing guidance.")
                run_ninite_command(user_input)

            elif user_input.startswith("just-install "):
                user_input = user_input[13:].strip()
                print(f"[{timestamp()}] [INFO] Executing the following command with just-install: {user_input}")
                run_justinstall_command(user_input)

            elif user_input.startswith("oneget "):
                user_input = user_input[7:].strip()
                print(
                    f"[{timestamp()}] [INFO] Executing the following command with OneGet/PackageManagement: {user_input}")
                run_oneget_command(user_input)

            elif user_input.startswith("boxstarter "):
                user_input = user_input[11:].strip()
                print(f"[{timestamp()}] [INFO] Executing the following command with Boxstarter: {user_input}")
                run_boxstarter_command(user_input)

            elif user_input.startswith("npackd "):
                user_input = user_input[7:].strip()
                print(f"[{timestamp()}] [INFO] Executing the following command with Npackd: {user_input}")
                run_npackd_command(user_input)

            elif user_input.startswith("zero-install "):
                user_input = user_input[13:].strip()
                print(f"[{timestamp()}] [INFO] Executing the following command with Zero Install: {user_input}")
                run_zero_install_command(user_input)

            elif user_input.startswith("appget "):
                user_input = user_input[7:].strip()
                print(f"[{timestamp()}] [INFO] AppGet has been discontinued. You may want to use winget instead.")
                run_appget_command(user_input)

            elif user_input.lower() == "pcsc":
                print(f"[{timestamp()}] [INFO] Here, you're creating a custom command that can later be executed by anyone with access to this PC. Therefore, make sure your system is free of security vulnerabilities and that only trusted people have access. Insecure or dangerous paths can put your system at risk!\n")

                cmd_name = input("What should your command be: ").strip()

                if is_cmd_command(cmd_name):
                    print(f"[{timestamp()}] [WARNING] '{cmd_name}' is a CMD command.")
                elif is_powershell_command(cmd_name):
                    print(f"[{timestamp()}] [WARNING] '{cmd_name}' is a Windows PowerShell command.")
                elif is_pwsh_command(cmd_name):
                    print(f"[{timestamp()}] [WARNING] '{cmd_name}' is a PowerShell 7+ (pwsh) command.")
                elif is_pp_terminal_command(cmd_name):
                    print(f"[{timestamp()}] [WARNING] '{cmd_name}' is a PP-Terminal command.")

                if cmd_name in commands:
                    print(f"[{timestamp()}] [WARNING] Command '{cmd_name}' already exists.")

                    while True:
                        choice = input("Do you want to (o)verwrite the path, change (p)ermissions, do (b)oth, or (c)ancel? [o/p/b/c]: ").strip().lower()
                        if choice == 'o':
                            exe_path = input("New path to the executable file: ").strip()
                            commands[cmd_name]["path"] = exe_path
                            break
                        elif choice == 'p':
                            permissions = input("New required rights (user/admin): ").strip().lower()
                            commands[cmd_name]["permissions"] = permissions
                            break
                        elif choice == 'b':
                            exe_path = input("New path to the executable file: ").strip()
                            permissions = input("New required rights (user/admin): ").strip().lower()
                            commands[cmd_name] = {
                                "path": exe_path,
                                "permissions": permissions
                            }
                            break
                        elif choice == 'c':
                            print(f"[{timestamp()}] [INFO] No changes made to '{cmd_name}'.")
                            break
                        else:
                            print("Invalid option. Please enter 'o', 'p', 'b', or 'c'.")
                else:
                    exe_path = input("Path to the executable file: ").strip()
                    permissions = input("Required rights (user/admin): ").strip().lower()

                    commands[cmd_name] = {
                        "path": exe_path,
                        "permissions": permissions
                    }
                    print(f"\n[{timestamp()}] [INFO] Command '{cmd_name}' was saved.")

                # Save the updated commands in any case (if modified)
                with open(COMMANDS_FILE, 'w') as f:
                    json.dump(commands, f, indent=4)

            elif user_input.startswith("pcsc "):
                cmd_name = user_input[5:].strip()
                print(f"[{timestamp()}] [INFO] Here, you're creating a custom command that can later be executed by anyone with access to this PC. Therefore, make sure your system is free of security vulnerabilities and that only trusted people have access. Insecure or dangerous paths can put your system at risk!\n")
                # cmd_name = input("What should your command be: ").strip()

                if is_cmd_command(cmd_name):
                    print(f"[{timestamp()}] [WARNING] '{cmd_name}' is a CMD command.")
                elif is_powershell_command(cmd_name):
                    print(f"[{timestamp()}] [WARNING] '{cmd_name}' is a Windows PowerShell command.")
                elif is_pwsh_command(cmd_name):
                    print(f"[{timestamp()}] [WARNING] '{cmd_name}' is a PowerShell 7+ (pwsh) command.")
                elif is_pp_terminal_command(cmd_name):
                    print(f"[{timestamp()}] [WARNING] '{cmd_name}' is a PP-Terminal command.")

                if cmd_name in commands:
                    print(f"[{timestamp()}] [WARNING] Command '{cmd_name}' already exists.")

                    while True:
                        choice = input("Do you want to (o)verwrite the path, change (p)ermissions, do (b)oth, or (c)ancel? [o/p/b/c]: ").strip().lower()
                        if choice == 'o':
                            exe_path = input("New path to the executable file: ").strip()
                            commands[cmd_name]["path"] = exe_path
                            break
                        elif choice == 'p':
                            permissions = input("New required rights (user/admin): ").strip().lower()
                            commands[cmd_name]["permissions"] = permissions
                            break
                        elif choice == 'b':
                            exe_path = input("New path to the executable file: ").strip()
                            permissions = input("New required rights (user/admin): ").strip().lower()
                            commands[cmd_name] = {
                                "path": exe_path,
                                "permissions": permissions
                            }
                            break
                        elif choice == 'c':
                            print(f"[{timestamp()}] [INFO] No changes made to '{cmd_name}'.")
                            break
                        else:
                            print("Invalid option. Please enter 'o', 'p', 'b', or 'c'.")
                else:
                    exe_path = input("Path to the executable file: ").strip()
                    permissions = input("Required rights (user/admin): ").strip().lower()

                    commands[cmd_name] = {
                        "path": exe_path,
                        "permissions": permissions
                    }
                    print(f"\n[{timestamp()}] [INFO] Command '{cmd_name}' was saved.")

                # Save the updated commands in any case (if modified)
                with open(COMMANDS_FILE, 'w') as f:
                    json.dump(commands, f, indent=4)

            elif user_input.lower() == "prsc":
                cmd_to_delete = input("Which command do you want to delete: ").strip()

                if cmd_to_delete in commands:
                    del commands[cmd_to_delete]

                    with open(COMMANDS_FILE, 'w') as f:
                        json.dump(commands, f, indent=4)

                    print(f"[{timestamp()}] [INFO] Command '{cmd_to_delete}' was deleted.")
                else:
                    print(f"[{timestamp()}] [INFO] Command '{cmd_to_delete}' not found.")

            elif user_input.startswith("prsc "):
                cmd_to_delete = user_input[5:].strip()

                if cmd_to_delete in commands:
                    del commands[cmd_to_delete]

                    with open(COMMANDS_FILE, 'w') as f:
                        json.dump(commands, f, indent=4)

                    print(f"[{timestamp()}] [INFO] Command '{cmd_to_delete}' was deleted.")
                else:
                    print(f"[{timestamp()}] [INFO] Command '{cmd_to_delete}' not found.")

            elif user_input and user_input.split()[0] in commands:
                parts = user_input.split()
                cmd_name = parts[0]
                args = parts[1:]

                cmd_info = commands[cmd_name]
                exe = cmd_info["path"]

                if cmd_info["permissions"] == "admin":
                    print(f"[{timestamp()}] [INFO] '{cmd_name}' needs admin rights!")

                try:
                    full_command = [exe] + args
                    subprocess.run(full_command)
                except Exception as e:
                    print(f"[{timestamp()}] [ERROR] Error while running: {e}")

            elif not user_input.strip():
                print(f"[{timestamp()}] [INFO] PP-Term Kernel has not detected any valid process or instruction. Awaiting input...")

            else:
                print(f"[{timestamp()}] [INFO] Privileged PP-Terminal Kernel activated — 'shell=True' is required to unleash full EToALTA functionality (note: potential security implications).")
                run_command(user_input, shell=True)

            sys.stdout.flush()
            sys.stderr.flush()

        except KeyboardInterrupt:
            print(f"\n[{timestamp()}] [INFO] {yellow}Exiting PP-Terminal... Goodbye {user_name}!{reset}")
            break
        except Exception as e:
            print(f"[{timestamp()}] [ERROR] {str(e)}", file=sys.stderr)


if __name__ == "__main__":
    main()
